(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{318:function(a,t,s){"use strict";s.r(t);var v=s(14),n=Object(v.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"java-jni笔记"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java-jni笔记"}},[a._v("#")]),a._v(" Java JNI笔记")]),a._v(" "),t("h2",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[a._v("#")]),a._v(" 简介")]),a._v(" "),t("ul",[t("li",[a._v("JNI，即Java Native Interface。是Java提供的支持本地方法的接口。该接口提供了让Java调用C/C++等代码的途径")])]),a._v(" "),t("h3",{attrs:{id:"何时需要jni"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#何时需要jni"}},[a._v("#")]),a._v(" 何时需要JNI?")]),a._v(" "),t("ul",[t("li",[a._v("需要使用JNI的情况\n"),t("ul",[t("li",[a._v("应用使用到了Java标准库不支持的依赖于平台的特性")]),a._v(" "),t("li",[a._v("已经有用其他语言写好的库，希望通过JNI来调用")]),a._v(" "),t("li",[a._v("希望用低级语言(如汇编)实现一小部分对时间要求高的关键代码")])])])]),a._v(" "),t("h3",{attrs:{id:"jni能实现的功能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jni能实现的功能"}},[a._v("#")]),a._v(" JNI能实现的功能")]),a._v(" "),t("ul",[t("li",[a._v("使用JNI编程，可使用本地方法来：\n"),t("ul",[t("li",[a._v("创建、检查和更新Java对象（包括数组和字符串）")]),a._v(" "),t("li",[a._v("调用Java方法")]),a._v(" "),t("li",[a._v("捕获和抛出异常")]),a._v(" "),t("li",[a._v("加载类和获得类的信息")]),a._v(" "),t("li",[a._v("执行运行时类型检查")])])]),a._v(" "),t("li",[a._v("也可将JNI与调用API(Invocation API)一起使用，来支持任意本地应用(native application)嵌入到Java虚拟机中")])]),a._v(" "),t("h2",{attrs:{id:"设计概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设计概述"}},[a._v("#")]),a._v(" 设计概述")]),a._v(" "),t("h3",{attrs:{id:"jni接口函数和指针"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jni接口函数和指针"}},[a._v("#")]),a._v(" JNI接口函数和指针")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("本机代码通过JNI函数来使用Java虚拟机得特性。JNI函数可通过"),t("strong",[a._v("接口指针(Interface Pointer)得到，接口指针是指针的指针，该指针指向一个指针数组，而数组中的每个指针指向一个")]),a._v("接口函数(Interface Function)")]),a._v(" "),t("p",[t("img",{attrs:{src:"/jni-pic/1.gif",alt:"designa.gif"}})])]),a._v(" "),t("li",[t("p",[a._v("JNI接口像C++虚函数表或COM接口一样被组织起来。使用接口表而不是硬链接(hard-wired)函数入口的优势在于，JNI的命名空间会因此与本地代码独立。虚拟机能容易地提供多版本的JNI函数表")])]),a._v(" "),t("li",[t("p",[a._v("JNI接口指针仅在当前线程有效，因此，一个本地方法不应该将接口指针从一个线程传递到另一个线程")])]),a._v(" "),t("li",[t("p",[a._v("本地方法接收一个JNI接口指针作为参数，虚拟机会保证在同一个Java线程多次调用某个本地方法时传递相同的接口指针；但一个本地方法可能在多个线程中调用，因此可能会接收到不同的接口指针")])])]),a._v(" "),t("h3",{attrs:{id:"编译、加载和链接本地方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#编译、加载和链接本地方法"}},[a._v("#")]),a._v(" 编译、加载和链接本地方法")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("因为虚拟机时多线程的，所以本地库也应该使用支持多线程的本地编译器编译和链接")])]),a._v(" "),t("li",[t("p",[a._v("本地方法使用"),t("code",[a._v("System.loadLibrary()")]),a._v("方法进行加载，如")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("package")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token namespace"}},[a._v("pkg")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Class")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Test")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("native")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("double")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("f")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" i"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" s"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("loadLibrary")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"pkg_Test"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])])]),a._v(" "),t("li",[t("p",[a._v("开发者可以使用一个库来存储任意数量的类所需要的所有本机方法，只要用相同的类加载器加载这些类即可。VM内部为每个类加载器维护一个已加载的本机库列表")])]),a._v(" "),t("li",[t("p",[a._v("本机库可以与虚拟机静态链接")])]),a._v(" "),t("li",[t("p",[a._v("当且仅当库导出名为"),t("code",[a._v("JNI_OnLoad_L")]),a._v("的函数时，将其映像与VM结合的库L定义为静态链接")])]),a._v(" "),t("li",[t("p",[a._v("一个静态链接库"),t("code",[a._v("L")]),a._v("导出一个叫"),t("code",[a._v("JIN_OnLoad_L")]),a._v("和一个叫"),t("code",[a._v("JNI_OnLoad")]),a._v("的函数时，"),t("code",[a._v("JNI_OnLoad")]),a._v("函数会被忽略")])]),a._v(" "),t("li",[t("p",[a._v("库"),t("code",[a._v("L")]),a._v("被静态链接，然后当第一次调用"),t("code",[a._v('System.loadLibrary("L")')]),a._v("时，一个"),t("code",[a._v("JNI_OnLoad_L")]),a._v("函数会被调用，并且接受和返回与"),t("code",[a._v("JNI_OnLoad")]),a._v("一样的参数和返回值")])]),a._v(" "),t("li",[t("p",[a._v("静态链接的库"),t("code",[a._v("L")]),a._v("会阻止同名的库进行动态加载")])]),a._v(" "),t("li",[t("p",[a._v("当静态链接的库"),t("code",[a._v("L")]),a._v("被垃圾回收时，VM会调用该库导出的名叫"),t("code",[a._v("JNI_OnUnLoad_L")]),a._v("的函数")])]),a._v(" "),t("li",[t("p",[a._v("开发者可调用JNI函数"),t("code",[a._v("RegisterNatives()")]),a._v("来注册与类相关的本地方法")])])]),a._v(" "),t("h3",{attrs:{id:"解析本地方法名"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解析本地方法名"}},[a._v("#")]),a._v(" 解析本地方法名")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("动态链接器通过名字解析其入口。本地方法名由下述部分构成：")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("Java_")]),a._v("前缀")]),a._v(" "),t("li",[a._v("一个符号修饰(mangled)的全限定类名")]),a._v(" "),t("li",[a._v("一个下划线分隔符("),t("code",[a._v("_")]),a._v(")")]),a._v(" "),t("li",[a._v("一个符号修饰的方法名")]),a._v(" "),t("li",[a._v("对于重载的本地方法，两个下划线("),t("code",[a._v("__")]),a._v(")后跟符号修饰的参数签名")])])]),a._v(" "),t("li",[t("p",[a._v("VM检查方法名称是否与驻留在本机库中的方法相匹配；VM首先查找短名称，即没有参数签名的名称，然后查找长名称，即带有参数签名的名称。只有当一个本机方法被另一个本机方法重载时，开发者才需要使用长名称。但是，本机方法与非本地方法可以具有相同的名称，因为非本机方法(Java方法)不驻留在本地库中")])]),a._v(" "),t("li",[t("p",[a._v("JNI采用了一个简单的名称修饰(name-mangling)方案，以确保所有Unicode字符都转换为有效的C函数名。并使用下划线("),t("code",[a._v("_")]),a._v(")代替全限定类名中的斜线("),t("code",[a._v("/")]),a._v(")")])]),a._v(" "),t("li",[t("p",[a._v("因为一个名字或类型描述符不可能以数字开头，因此，使用"),t("code",[a._v("_0、...、_9")]),a._v("作为转义序列：")]),a._v(" "),t("table",[t("thead",[t("tr",[t("th",[a._v("转义序列")]),a._v(" "),t("th",[a._v("含义")])])]),a._v(" "),t("tbody",[t("tr",[t("td",[a._v("_0xxxx")]),a._v(" "),t("td",[a._v("表示一个Unicode字符XXXX。注意：小写字符用于表示非ASCII码字符，如_0abcd而不是_0ABCD")])]),a._v(" "),t("tr",[t("td",[a._v("_1")]),a._v(" "),t("td",[a._v("表示字符"),t("code",[a._v("_")])])]),a._v(" "),t("tr",[t("td",[a._v("_2")]),a._v(" "),t("td",[a._v("表示签名中的"),t("code",[a._v(";")]),a._v("字符")])]),a._v(" "),t("tr",[t("td",[a._v("_3")]),a._v(" "),t("td",[a._v("表示签名中的"),t("code",[a._v("[")]),a._v("字符")])])])])])]),a._v(" "),t("h3",{attrs:{id:"本地方法参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#本地方法参数"}},[a._v("#")]),a._v(" 本地方法参数")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("JNI接口指针是本地方法的第一个参数，其类型为"),t("code",[a._v("JNIEnv")]),a._v("。第二个参数根据本地方法是否是静态方法决定，对于非静态方法，第二参数是对象的引用；对于静态方法，第二参数是其Java类的引用")])]),a._v(" "),t("li",[t("p",[a._v("剩余的参数对应于普通Java方法的参数。本地方法调用通过其返回值像调用它的程序返回结果")])]),a._v(" "),t("li",[t("p",[a._v("使用C函数实现Java本地方法示例：")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("Java中本地方法定义")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("package")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token namespace"}},[a._v("pkg")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Cls")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("native")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("double")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("f")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" i"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" s"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//...")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])])]),a._v(" "),t("li",[t("p",[a._v("长别名为"),t("code",[a._v("Java_pkg_Cls_f_ILjava_lang_String_2")]),a._v("的C函数实现了本地方法"),t("code",[a._v("f")])]),a._v(" "),t("div",{staticClass:"language-c extra-class"},[t("pre",{pre:!0,attrs:{class:"language-c"}},[t("code",[a._v("jdouble "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("Java_pkg_Cls_f__ILjava_lang_String_2")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("\n    JNIEnv "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v("env"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("        "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/* 接口指针*/")]),a._v("\n    jobject obj"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("        "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v('/* "this" 指针 */')]),a._v("\n    jint i"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("             "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/* 参数1 */")]),a._v("\n    jstring s"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("          "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/* 参数2 */")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/* 获取Java String的一份C拷贝 */")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("char")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v("str "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v("env"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("GetStringUTFChars")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("env"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" s"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/* 处理字符串 */")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/* 释放字符串 */")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v("env"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("ReleaseStringUTFChars")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("env"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" s"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" str"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])])])])]),a._v(" "),t("li",[t("p",[a._v("注意：总是使用接口指针env来操作Java对象")])]),a._v(" "),t("li",[t("p",[a._v("使用C++时，可得到稍微整洁的代码：")]),a._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('extern "C" /* 使用C调用约定 */ \n\njdouble Java_pkg_Cls_f__ILjava_lang_String_2 (\n\n    JNIEnv *env,        /* 接口指针 */\n    jobject obj,        /* "this" 指针 */\n    jint i,             /* 参数 #1 */\n    jstring s)          /* 参数 #2 */\n\n{\n    // C++中不再需要额外的 (*env) 解引用\n    const char *str = env->GetStringUTFChars(s, 0);\n\n    // ...\n\n    env->ReleaseStringUTFChars(s, str);\n\n    // return ...\n}\n')])])])])]),a._v(" "),t("h3",{attrs:{id:"引用java对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#引用java对象"}},[a._v("#")]),a._v(" 引用Java对象")]),a._v(" "),t("ul",[t("li",[a._v("原始类型如int、char等在Java传递到本地方法的过程中是按值传递的，而任意的Java对象都是按引用传递的。VM必须跟踪已传递给本机代码的所有对象，以便垃圾收集器不会释放这些对象。反过来，本机代码必须有一种方式通知VM它不再需要这些对象；此外，垃圾收集器必须能够移动本机代码引用的对象")]),a._v(" "),t("li",[t("strong",[a._v("全局和局部引用")]),a._v(" "),t("ul",[t("li",[a._v("JNI把本地代码使用的对象引用分为两种：局部(local)和全局(global)引用。局部引用在本地代码执行期间使用，本地代码返回后会自动释放；全局引用在其被显式释放之前都可用")]),a._v(" "),t("li",[a._v("对象以局部引用的方式传递个本地方法(native method)，所有JNI函数返回的Java对象都是局部引用。JNI允许开发者从局部引用创建全局引用。接收Java对象作为参数的JNI函数可接收全局或局部引用。一个本地方法可返回一个全局或局部引用给VM")]),a._v(" "),t("li",[a._v("在大多数情况下，开发者应该依赖VM在本地方法返回后释放所有局部引用，但在下述情况下开发者应该显式释放：\n"),t("ul",[t("li",[a._v("本地方法访问一个大Java对象，因而创建一个该Java对象的局部引用。然后本地方法在返回给调用者之前执行了一些计算，此时局部引用会阻止对象被垃圾回收器回收，尽管这个对象在后续的计算中已经没有作用")]),a._v(" "),t("li",[a._v("本地方法创建大量的局部引用，尽管它们不会同时被使用。因为VM需要一些空间来跟踪局部引用，创建大量的局部引用可能导致系统耗尽内存资源。例如，一个本地方法在一个很大的对象数组上执行循环，获取元素作为局部引用，在每轮迭代时处理一个对象。在每轮循环后，开发者就不再需要该引用")])])]),a._v(" "),t("li",[a._v("JNI允许开发者在本地代码中的任意时候释放一个局部引用。为了确保开发者可以手动释放局部引用，JNI函数不允许创建额外的局部引用，除了它们作为结果返回的引用")]),a._v(" "),t("li",[a._v("局部引用仅在创建它们的线程中有效。本地代码不能将局部引用从一个线程传递到另一个线程")])])])]),a._v(" "),t("h3",{attrs:{id:"访问java对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#访问java对象"}},[a._v("#")]),a._v(" 访问Java对象")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("JNI在全局和局部引用上提供了很多访问器函数，这是JNI能够被各种VM实现支持的一个关键原因")])]),a._v(" "),t("li",[t("p",[a._v("通过不透明引用使用访问器函数的开销要高于直接访问C数据结构的开销")])]),a._v(" "),t("li",[t("p",[t("strong",[a._v("访问原始数组(primitive array)")])]),a._v(" "),t("ul",[t("li",[a._v("对于包含许多基本数据类型(如整数数组和字符串)的大型Java对象，这种开销是不可接受的")]),a._v(" "),t("li",[a._v("遍历Java数组并使用函数调用检索每个元素的效率非常低")]),a._v(" "),t("li",[a._v("一种解决方案引入了**固定(pinning)**的概念，以便本地方法可以要求VM 固定数组的内容，然后本地方法接收一个指向元素的直接指针。这种方式有两种隐含要求：\n"),t("ul",[t("li",[a._v("垃圾回收器必须要支持pinning")]),a._v(" "),t("li",[a._v("VM必须将原始数组在内存中连续存储。虽然这是这是多数数组的自然实现方式，但对于布尔数组，其可能被打包或者解包，因此依赖于布尔数组精确布局的本地代码是不可移植的")])])]),a._v(" "),t("li",[a._v("JNI采取了折衷的办法克服上述问题")]),a._v(" "),t("li",[a._v("首先，提供了一组函数，用于在Java数组段和本机内存缓冲区之间复制原始数组元素,如果本机方法只需要访问一个大数组中的少量元素，则使用这些函数")]),a._v(" "),t("li",[a._v("其次，开发者可以使用另一组函数来检索数组元素的pinning版本，需注意，这些功能可能需要Java VM执行存储分配和复制。这些函数是否复制数组取决于虚拟机的实现：\n"),t("ul",[t("li",[a._v("如果垃圾收集器支持pinning，并且数组的布局与本机方法所期望的相同，则不需要复制")]),a._v(" "),t("li",[a._v("否则，数组被复制到一个不可移动的内存块(例如，在C堆中)，然后执行必要的格式转换。返回复制后的指针")])])]),a._v(" "),t("li",[a._v("最后，接口提供了通知VM本地代码不再需要访问数组元素的函数。当调用这些函数时，系统要么解除数组的固定pinning，要么让原始数组与副本保持一致后释放副本")])])]),a._v(" "),t("li",[t("p",[t("strong",[a._v("访问字段和方法")])]),a._v(" "),t("ul",[t("li",[t("p",[a._v("JNI允许本地方法访问Java对象的字段和调用Java方法。JNI通过符号名和类型签名来表示一个方法或字段")])]),a._v(" "),t("li",[t("p",[a._v("一个两个步骤的过程表明了通过名字和签名定位字段或方法的开销。如，调用类"),t("code",[a._v("cls")]),a._v("中的方法"),t("code",[a._v("f")]),a._v("，本地代码首先获取方法ID：")]),a._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('jmethodID mid=env->GetMethodID(cls,"f","(ILjava/lang/String;)D");\n')])])])]),a._v(" "),t("li",[t("p",[a._v("接着本地代码可没有查找开销地使用方法ID：")]),a._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("jdouble result=env->CallDoubleMethod(obj,mid,10,str);\n")])])])]),a._v(" "),t("li",[t("p",[a._v("字段或方法ID不会阻止虚拟机卸载派生出ID的类，卸载类后，方法或字段ID将无效。因此若打算在一段时间内使用一个方法或字段ID，本地代码需要保证：")]),a._v(" "),t("ul",[t("li",[a._v("保持对底层类的动态引用")]),a._v(" "),t("li",[a._v("或重新计算方法或字段ID")])])])])])]),a._v(" "),t("h3",{attrs:{id:"报告程序错误"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#报告程序错误"}},[a._v("#")]),a._v(" 报告程序错误")]),a._v(" "),t("ul",[t("li",[a._v("JNI并不检查如传递空指针或非法参数之类的错误，")])]),a._v(" "),t("h3",{attrs:{id:"java异常"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java异常"}},[a._v("#")]),a._v(" Java异常")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("JNI允许本地代码抛出任意的Java异常，本地代码也可能处理一些突出的Java异常，未处理的Java异常会传播回JVM")])]),a._v(" "),t("li",[t("p",[t("strong",[a._v("异常和错误代码")])]),a._v(" "),t("ul",[t("li",[a._v("某些JNI函数使用Java异常机制报告错误情况，多数情况下，JNI函数通过返回一个错误代码或抛出Java异常来报告错误。错误代码通常是一个特殊的返回值（如NULL），因此，程序可：\n"),t("ul",[t("li",[a._v("快速地检查最近JNI函数调用的返回值来判断是否有错误发生")]),a._v(" "),t("li",[a._v("并且调用"),t("code",[a._v("ExceptionOccurred()")]),a._v("函数来获取包含该错误的详细描述的异常对象")])])]),a._v(" "),t("li",[a._v("在两种情况下，开发者需要检查异常而不能首先检查错误代码：\n"),t("ul",[t("li",[a._v("调用Java方法的JNI函数返回Java方法的结果，开发者必须调用"),t("code",[a._v("ExceptionOccurred()")]),a._v("来检查在Java方法执行期间可能发生的异常")]),a._v(" "),t("li",[a._v("一些JNI数组访问函数不返回错误代码，但可能抛出"),t("code",[a._v("ArrayIndexOutOfBoundsException")]),a._v("或"),t("code",[a._v("ArrayStoreException")])])])])])]),a._v(" "),t("li",[t("p",[t("strong",[a._v("异步异常")])]),a._v(" "),t("ul",[t("li",[a._v("在多个线程的情况下，当前线程以外的线程可能会产生异步异常。异步异常不会立即影响当前线程中本机代码的执行，直到：\n"),t("ul",[t("li",[a._v("本地代码调用一个可能引发异步异常的JNI函数")]),a._v(" "),t("li",[a._v("或本地代码使用"),t("code",[a._v("ExceptionOccurred()")]),a._v("显式检查同步和异步异常")])])]),a._v(" "),t("li",[a._v("本地方法应该在必要的地方插入"),t("code",[a._v("ExceptionOccurred()")]),a._v("检查(例如在没有其他异常检查的紧凑循环中)，以确保当前线程在合理的时间内响应异步异常")])])]),a._v(" "),t("li",[t("p",[t("strong",[a._v("异常处理")])]),a._v(" "),t("ul",[t("li",[t("p",[a._v("在本地代码中有两种处理异常的方式：")]),a._v(" "),t("ul",[t("li",[a._v("本地方法可以选择立即返回，使得在调用本地方法的Java代码中抛出异常")]),a._v(" "),t("li",[a._v("本地代码可以使用"),t("code",[a._v("ExceptionClear()")]),a._v("清除异常，并执行其自己的异常处理代码")])])]),a._v(" "),t("li",[t("p",[a._v("在引发异常之后，本地代码必须首先清除异常，然后才能进行其他JNI调用。当存在挂起的异常时，可以安全调用的JNI函数是：")]),a._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("ExceptionOccurred()\nExceptionDescribe()\nExceptionClear()\nExceptionCheck()\nReleaseStringChars()\nReleaseStringUTFChars()\nReleaseStringCritical()\nRelease<Type>ArrayElements()\nReleasePrimitiveArrayCritical()\nDeleteLocalRef()\nDeleteGlobalRef()\nDeleteWeakGlobalRef()\nMonitorExit()\nPushLocalFrame()\nPopLocalFrame()\n")])])])])])])]),a._v(" "),t("h2",{attrs:{id:"jni类型和数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jni类型和数据结构"}},[a._v("#")]),a._v(" JNI类型和数据结构")]),a._v(" "),t("h3",{attrs:{id:"原始类型-primitive-types"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原始类型-primitive-types"}},[a._v("#")]),a._v(" 原始类型(primitive types)")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("对应关系表")]),a._v(" "),t("table",[t("thead",[t("tr",[t("th",[a._v("Java类型")]),a._v(" "),t("th",[a._v("Native类型")]),a._v(" "),t("th",[a._v("描述")])])]),a._v(" "),t("tbody",[t("tr",[t("td",[a._v("boolean")]),a._v(" "),t("td",[a._v("jboolean")]),a._v(" "),t("td",[a._v("无符号8位")])]),a._v(" "),t("tr",[t("td",[a._v("byte")]),a._v(" "),t("td",[a._v("jbyte")]),a._v(" "),t("td",[a._v("有符号8位")])]),a._v(" "),t("tr",[t("td",[a._v("char")]),a._v(" "),t("td",[a._v("jchar")]),a._v(" "),t("td",[a._v("无符号16位")])]),a._v(" "),t("tr",[t("td",[a._v("short")]),a._v(" "),t("td",[a._v("jshort")]),a._v(" "),t("td",[a._v("有符号16位")])]),a._v(" "),t("tr",[t("td",[a._v("int")]),a._v(" "),t("td",[a._v("jint")]),a._v(" "),t("td",[a._v("有符号32位")])]),a._v(" "),t("tr",[t("td",[a._v("long")]),a._v(" "),t("td",[a._v("jlong")]),a._v(" "),t("td",[a._v("有符号64位")])]),a._v(" "),t("tr",[t("td",[a._v("float")]),a._v(" "),t("td",[a._v("jfloat")]),a._v(" "),t("td",[a._v("32位")])]),a._v(" "),t("tr",[t("td",[a._v("double")]),a._v(" "),t("td",[a._v("jdouble")]),a._v(" "),t("td",[a._v("64位")])]),a._v(" "),t("tr",[t("td",[a._v("void")]),a._v(" "),t("td",[a._v("void")]),a._v(" "),t("td",[a._v("void")])])])])]),a._v(" "),t("li",[t("p",[a._v("下述定义是出于方便")]),a._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("#define JNI_TRUE 1\n#define JNI_FALSE 0\n")])])])]),a._v(" "),t("li",[t("p",[t("code",[a._v("jsize")]),a._v("整数类型用于描述下标或大小")]),a._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("typedef jint jsize;\n")])])])])]),a._v(" "),t("h3",{attrs:{id:"引用类型-reference-types"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#引用类型-reference-types"}},[a._v("#")]),a._v(" 引用类型(reference types)")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("JNI包含许多对应于不同类型Java对象的引用类型。JNI引用类型按以下层次组织：")]),a._v(" "),t("ul",[t("li",[a._v("jobject\n"),t("ul",[t("li",[t("code",[a._v("jclass")]),a._v("(java.lang.Class)")]),a._v(" "),t("li",[t("code",[a._v("jstring")]),a._v("(java.lang.String)")]),a._v(" "),t("li",[a._v("jarray(数组)\n"),t("ul",[t("li",[t("code",[a._v("jobjectArray")]),a._v("对象数组")]),a._v(" "),t("li",[t("code",[a._v("jbooleanArray")]),a._v("布尔数组")]),a._v(" "),t("li",[t("code",[a._v("jbyteArray")]),a._v("byte数组")]),a._v(" "),t("li",[t("code",[a._v("jcharArray")]),a._v("char数组")]),a._v(" "),t("li",[t("code",[a._v("jshortArray")]),a._v(" short数组")]),a._v(" "),t("li",[t("code",[a._v("jintArray")]),a._v("int数组")]),a._v(" "),t("li",[t("code",[a._v("jlongArray")]),a._v(" long数组")]),a._v(" "),t("li",[t("code",[a._v("jfloatArray")]),a._v(" float数组")]),a._v(" "),t("li",[t("code",[a._v("jdoubleArray")]),a._v(" double数组")])])]),a._v(" "),t("li",[t("code",[a._v("jthrowable")]),a._v("(java.lang.Throwable)")])])])])]),a._v(" "),t("li",[t("p",[a._v("在 C 中，其他所有JNI引用类型都定义为与jobject相同，如")]),a._v(" "),t("div",{staticClass:"language-c extra-class"},[t("pre",{pre:!0,attrs:{class:"language-c"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("typedef")]),a._v(" jobject jclass"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])])]),a._v(" "),t("li",[t("p",[a._v("在 C++ 中，JNI引入了一组虚拟类来加强子类型关系。如")]),a._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("class _jobject {};\nclass _jclass : public _jobject {};\n// ...\ntypedef _jobject *jobject;\ntypedef _jclass *jclass;\n")])])])])]),a._v(" "),t("h3",{attrs:{id:"字段-field-和方法-method-id"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#字段-field-和方法-method-id"}},[a._v("#")]),a._v(" 字段(Field)和方法(Method)ID")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("字段和方法ID是常规的 C 指针类型：")]),a._v(" "),t("div",{staticClass:"language-c extra-class"},[t("pre",{pre:!0,attrs:{class:"language-c"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("struct")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("_jfieldID")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("              "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/* 不透明结构 */")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("typedef")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("struct")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("_jfieldID")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v("jfieldID"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("   "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/* 字段ID */")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("struct")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("_jmethodID")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("              "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/* 不透明结构 */")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("typedef")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("struct")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("_jmethodID")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v("jmethodID"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/* 方法ID */")]),a._v("\n")])])])])]),a._v(" "),t("h3",{attrs:{id:"值类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#值类型"}},[a._v("#")]),a._v(" 值类型")]),a._v(" "),t("ul",[t("li",[t("p",[t("code",[a._v("jvalue")]),a._v("联合类型被用作参数数组中的元素类型，定义为：")]),a._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("typedef union jvalue {\n    jboolean z;\n    jbyte    b;\n    jchar    c;\n    jshort   s;\n    jint     i;\n    jlong    j;\n    jfloat   f;\n    jdouble  d;\n    jobject  l;\n} jvalue;\n")])])])])]),a._v(" "),t("h3",{attrs:{id:"类型签名"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类型签名"}},[a._v("#")]),a._v(" 类型签名")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("JNI使用JVM的类型签名表示法，见下类型签名表")]),a._v(" "),t("table",[t("thead",[t("tr",[t("th",[a._v("类型签名")]),a._v(" "),t("th",[a._v("对应Java类型")])])]),a._v(" "),t("tbody",[t("tr",[t("td",[a._v("Z")]),a._v(" "),t("td",[a._v("boolean")])]),a._v(" "),t("tr",[t("td",[a._v("B")]),a._v(" "),t("td",[a._v("byte")])]),a._v(" "),t("tr",[t("td",[a._v("C")]),a._v(" "),t("td",[a._v("char")])]),a._v(" "),t("tr",[t("td",[a._v("S")]),a._v(" "),t("td",[a._v("short")])]),a._v(" "),t("tr",[t("td",[a._v("I")]),a._v(" "),t("td",[a._v("int")])]),a._v(" "),t("tr",[t("td",[a._v("J")]),a._v(" "),t("td",[a._v("long")])]),a._v(" "),t("tr",[t("td",[a._v("F")]),a._v(" "),t("td",[a._v("float")])]),a._v(" "),t("tr",[t("td",[a._v("D")]),a._v(" "),t("td",[a._v("double")])]),a._v(" "),t("tr",[t("td",[a._v("L fully-qualified-class ;")]),a._v(" "),t("td",[a._v("全限定名类")])]),a._v(" "),t("tr",[t("td",[a._v("[ type")]),a._v(" "),t("td",[a._v("type[]。数组")])]),a._v(" "),t("tr",[t("td",[a._v("( arg-types ) ret-type")]),a._v(" "),t("td",[a._v("方法类型")])])])])]),a._v(" "),t("li",[t("p",[a._v("如对于以下Java方法")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("long")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("f")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" s"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" arr"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])])]),a._v(" "),t("li",[t("p",[a._v("其对应的类型签名为")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ILjava")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("lang"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("I")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("J")]),a._v("\n")])])])])]),a._v(" "),t("h3",{attrs:{id:"修改的utf-8字符串"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#修改的utf-8字符串"}},[a._v("#")]),a._v(" 修改的UTF-8字符串")]),a._v(" "),t("ul",[t("li",[a._v("JNI使用修改后的UTF-8字符串来表示各种字符串类型。修改后的UTF-8字符串与Java VM使用的字符串相同。修改后的UTF-8字符串会被编码，以至于仅包含非空ASCII字符的字符序列能用每个字符一个字节的方式表示，但所有的Unicode字符也能表示（可理解为变长编码）")]),a._v(" "),t("li",[a._v("在"),t("code",[a._v("\\u0001")]),a._v("到"),t("code",[a._v("\\u007F")]),a._v("范围内的字符都使用单个字节表示，如"),t("code",[a._v("0xxxxxxx")]),a._v("。其中7位的值用于表示字符")]),a._v(" "),t("li",[a._v("null字符("),t("code",[a._v("\\u0000")]),a._v(")和在"),t("code",[a._v("\\u0080")]),a._v("到"),t("code",[a._v("\\u07ff")]),a._v("的字符被一对字节x和y表示。如"),t("code",[a._v("x:110xxxxx y:10yyyyyy")]),a._v("。通过表达式"),t("code",[a._v("((x & 0x1f)<<16)+(y & 0x3f)")]),a._v("计算得到的值表示字符")]),a._v(" "),t("li",[a._v("范围在"),t("code",[a._v("\\u0800")]),a._v("到"),t("code",[a._v("\\uFFFF")]),a._v("的字符使用3个单字节x、y、z表示。如"),t("code",[a._v("x:1110xxxx y:10yyyyyy z:10zzzzzz")]),a._v("。通过表达式"),t("code",[a._v("((x & 0xf) << 12) + ((y & 0x3f) << 6) + (z & 0x3f)")]),a._v("计算的结果表示字符")]),a._v(" "),t("li",[a._v("多字节字符的字节被存在"),t("code",[a._v("class")]),a._v("文件中，按大端方式存储")]),a._v(" "),t("li",[a._v("与标准UTF-8格式的两点不同：\n"),t("ul",[t("li",[a._v("空字符"),t("code",[a._v("(char)0")]),a._v("使用双字节格式而不是单字节格式进行编码,这意味着修改后的UTF-8字符串永远不会嵌入空值")]),a._v(" "),t("li",[a._v("只使用标准UTF-8的1字节、2字节和3字节格式;JVM不识别标准UTF-8的四字节格式;它使用自己的两倍三字节格式")])])])]),a._v(" "),t("h2",{attrs:{id:"jni函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jni函数"}},[a._v("#")]),a._v(" JNI函数")]),a._v(" "),t("ul",[t("li",[a._v("所有的JNI函数都必须接收非空对象，保证传递给JNI函数的对象非空是开发者的职责。在保证非空后，JNI函数中因此不需要再进行非空检查")])]),a._v(" "),t("h3",{attrs:{id:"接口函数表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接口函数表"}},[a._v("#")]),a._v(" 接口函数表")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("每个函数都可用相对于"),t("code",[a._v("JNIEnv")]),a._v("参数的一个固定偏移量来访问到。"),t("code",[a._v("JNIEnv")]),a._v("类型是一个指向存储所有JNI函数指针的结构体的指针，其定义为：")]),a._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("typedef const struct JNINativeInterface *JNIEnv;\n")])])])]),a._v(" "),t("li",[t("p",[a._v("VM按以下代码初始化接口函数表，其中有些值为NULL的入口是预留为后续兼容COM或进行Class操作的扩展")]),a._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("const struct JNINativeInterface ...={\n    NULL,\n    NULL,\n    NULL,\n    NULL,\n    GetVersion,\n    \n    DefineClass,\n    FindClass,\n    \n    .....\n}\n")])])])])]),a._v(" "),t("h3",{attrs:{id:"版本信息"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#版本信息"}},[a._v("#")]),a._v(" 版本信息")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("相关JNI函数")]),a._v(" "),t("table",[t("thead",[t("tr",[t("th",[a._v("函数")]),a._v(" "),t("th",[a._v("作用")]),a._v(" "),t("th",[a._v("在接口函数表中的下标")])])]),a._v(" "),t("tbody",[t("tr",[t("td",[a._v("jint GetVersion(JNIEnv* env)")]),a._v(" "),t("td",[a._v("返回本地方法接口的版本。返回int，高16位存储主版本号，低16位存次版本号。如JDK/JRE 1.1，则返回 0x00010001")]),a._v(" "),t("td",[a._v("4")])])])])])]),a._v(" "),t("h3",{attrs:{id:"类操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类操作"}},[a._v("#")]),a._v(" 类操作")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("相关JNI函数")]),a._v(" "),t("table",[t("thead",[t("tr",[t("th",[a._v("函数")]),a._v(" "),t("th",[a._v("作用")]),a._v(" "),t("th",[a._v("在接口函数表中的下标")])])]),a._v(" "),t("tbody",[t("tr",[t("td",[a._v("jclass DefineClass(JNIEnv* env,const char* name,jobject loader,const jbyte* buf,jsize bufLen);")]),a._v(" "),t("td",[a._v("从装有原始类数据(.class文件)的缓冲区buf中加载类。在此函数返回后，buf不再被VM引用")]),a._v(" "),t("td",[a._v("5")])]),a._v(" "),t("tr",[t("td",[a._v("jclass FindClass(JNIEnv* env,const char* name);")]),a._v(" "),t("td",[a._v("查找并加载类.name为全限定类名")]),a._v(" "),t("td",[a._v("6")])]),a._v(" "),t("tr",[t("td",[a._v("jclass GetSuperclass(JNIEnv* env,jclass clazz);")]),a._v(" "),t("td",[a._v("获取clazz的超类。若clazz是除了Object类以外的类，则返回其超类；若clazz为Object类或clazz为接口，则函数返回NULL")]),a._v(" "),t("td",[a._v("10")])]),a._v(" "),t("tr",[t("td",[a._v("jboolean IsAssignableFrom(JNIEnv* env,jclass clazz1,jclass clazz2);")]),a._v(" "),t("td",[a._v("判断clazz1的对象是否能安全转换为clazz2的对象")]),a._v(" "),t("td",[a._v("11")])])])])])]),a._v(" "),t("h2",{attrs:{id:"vs2019-idea下jni项目整合"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vs2019-idea下jni项目整合"}},[a._v("#")]),a._v(" VS2019+IDEA下JNI项目整合")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("在Java端编写代码")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("package")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token namespace"}},[a._v("com"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("xiao")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("JNITest")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("loadLibrary")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"jni_test"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("native")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("myKernel")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("main")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" args"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("JNITest")]),a._v(" test"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("JNITest")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        test"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("myKernel")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])])]),a._v(" "),t("li",[t("p",[a._v("使用Java的命令行工具"),t("code",[a._v("javac -h")]),a._v("编译该Java类，生成一个C/C++头文件")]),a._v(" "),t("div",{staticClass:"language-powershell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-powershell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# javac -h 后跟 编译后保存文件的目录名和要编译的类名")]),a._v("\njavac "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("h "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v(" JNITest"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("java\n")])])])]),a._v(" "),t("li",[t("p",[a._v("编译后得到一个用下划线分割的全类名"),t("code",[a._v(".h")]),a._v("头文件")]),a._v(" "),t("p",[t("img",{attrs:{src:"/jni-pic/2.png",alt:"2.png"}})])]),a._v(" "),t("li",[t("p",[a._v("文件内容大致为")]),a._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('/* DO NOT EDIT THIS FILE - it is machine generated */\n#include "jni.h"\n/* Header for class com_xiao_JNITest */\n\n#ifndef _Included_com_xiao_JNITest\n#define _Included_com_xiao_JNITest\n#ifdef __cplusplus\n\nextern "C" {                //遵循C的编译规约\n#endif\n/*\n * Class:     com_xiao_JNITest\n * Method:    myKernel\n * Signature: ()V\n */\n// 以下即为JNI函数的声明\nJNIEXPORT void JNICALL Java_com_xiao_JNITest_myKernel(JNIEnv *, jobject);\n\n#ifdef __cplusplus\n}\n#endif\n#endif\n')])])])]),a._v(" "),t("li",[t("p",[a._v("在VS中创建"),t("strong",[a._v("动态链接库(dll)项目")])]),a._v(" "),t("p",[t("img",{attrs:{src:"/jni-pic/3.png",alt:"3.png"}})])]),a._v(" "),t("li",[t("p",[a._v("新建好项目后，项目中自身带了几个文件。可直接忽略不管，但不能删除")])]),a._v(" "),t("li",[t("p",[a._v("之后向项目中添加以下几个文件：")]),a._v(" "),t("ul",[t("li",[a._v("之前用"),t("code",[a._v("javac -h")]),a._v("编译得到的头文件")]),a._v(" "),t("li",[a._v("Java安装路径下"),t("code",[a._v("include")]),a._v("目录中的"),t("code",[a._v("jni.h")]),a._v("和"),t("code",[a._v("include>win32")]),a._v("目录中的"),t("code",[a._v("jni_md.h")])]),a._v(" "),t("li",[a._v("自己新建的用于实现头文件中的函数的"),t("code",[a._v(".cpp")]),a._v("文件（绿色所示）")])]),a._v(" "),t("p",[t("img",{attrs:{src:"/jni-pic/4.png",alt:"4.png"}})])]),a._v(" "),t("li",[t("p",[a._v("编写"),t("code",[a._v("com_xiao_JNITest.h")]),a._v("中函数的实现代码"),t("code",[a._v("jni_impl.cpp")])]),a._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('#pragma once\n#include "pch.h"\n#include "com_xiao_JNITest.h"\n#include <iostream>\n\nJNIEXPORT void JNICALL Java_com_xiao_JNITest_myKernel(JNIEnv* env, jobject obj) {\n\tstd::cout << "I am from C ++" << std::endl;\n}\n')])])])]),a._v(" "),t("li",[t("p",[a._v("可更改项目属性，让项目构建为x64 Release")]),a._v(" "),t("p",[t("img",{attrs:{src:"/jni-pic/5.png",alt:"5.png"}})])]),a._v(" "),t("li",[t("p",[a._v("生成解决方案(Ctrl+Shift+B)，在项目的"),t("code",[a._v("Release")]),a._v("文件夹下得到生成的"),t("code",[a._v(".dll")]),a._v("文件")]),a._v(" "),t("p",[t("img",{attrs:{src:"/jni-pic/6.png",alt:"6.png"}})])]),a._v(" "),t("li",[t("p",[a._v("在IDEA中，选择"),t("code",[a._v("File>Project Structure")]),a._v("，在Libraries中添加该"),t("code",[a._v(".dll")]),a._v("文件即可")]),a._v(" "),t("p",[t("img",{attrs:{src:"/jni-pic/7.png",alt:"7.png"}})])]),a._v(" "),t("li",[t("p",[a._v("运行....")]),a._v(" "),t("p",[t("img",{attrs:{src:"/jni-pic/8.png",alt:"8.png"}})])])])])}),[],!1,null,null,null);t.default=n.exports}}]);