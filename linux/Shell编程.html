<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Linux命令行与Shell脚本编程笔记 | Longqinx&#39;s Notes</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/assets/css/0.styles.9f84806b.css" as="style"><link rel="preload" href="/assets/js/app.969a6014.js" as="script"><link rel="preload" href="/assets/js/2.0c4bddf9.js" as="script"><link rel="preload" href="/assets/js/1.50b457b8.js" as="script"><link rel="preload" href="/assets/js/37.62de5401.js" as="script"><link rel="prefetch" href="/assets/js/10.325b9f09.js"><link rel="prefetch" href="/assets/js/11.845e3692.js"><link rel="prefetch" href="/assets/js/12.ecdb524b.js"><link rel="prefetch" href="/assets/js/13.3f3f6a36.js"><link rel="prefetch" href="/assets/js/14.eb7a3d07.js"><link rel="prefetch" href="/assets/js/15.b60f3925.js"><link rel="prefetch" href="/assets/js/16.85253907.js"><link rel="prefetch" href="/assets/js/17.c2838453.js"><link rel="prefetch" href="/assets/js/18.3256f17f.js"><link rel="prefetch" href="/assets/js/19.d8afd0ae.js"><link rel="prefetch" href="/assets/js/20.10e47ab9.js"><link rel="prefetch" href="/assets/js/21.33b300c9.js"><link rel="prefetch" href="/assets/js/22.271589f5.js"><link rel="prefetch" href="/assets/js/23.f187cd00.js"><link rel="prefetch" href="/assets/js/24.25d46f1d.js"><link rel="prefetch" href="/assets/js/25.6dbe905b.js"><link rel="prefetch" href="/assets/js/26.be06b78c.js"><link rel="prefetch" href="/assets/js/27.c1cdaecc.js"><link rel="prefetch" href="/assets/js/28.c84982d2.js"><link rel="prefetch" href="/assets/js/29.75d6d01f.js"><link rel="prefetch" href="/assets/js/3.af33e5d6.js"><link rel="prefetch" href="/assets/js/30.dfc04b59.js"><link rel="prefetch" href="/assets/js/31.e768d834.js"><link rel="prefetch" href="/assets/js/32.bd424b57.js"><link rel="prefetch" href="/assets/js/33.e9f62ae9.js"><link rel="prefetch" href="/assets/js/34.6e660565.js"><link rel="prefetch" href="/assets/js/35.259ec1af.js"><link rel="prefetch" href="/assets/js/36.cabec235.js"><link rel="prefetch" href="/assets/js/38.65324daa.js"><link rel="prefetch" href="/assets/js/39.d859ec36.js"><link rel="prefetch" href="/assets/js/4.45665f8a.js"><link rel="prefetch" href="/assets/js/40.3d954b2a.js"><link rel="prefetch" href="/assets/js/5.7098d77a.js"><link rel="prefetch" href="/assets/js/6.0c0a0f39.js"><link rel="prefetch" href="/assets/js/7.6a854e57.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.77260563.js">
    <link rel="stylesheet" href="/assets/css/0.styles.9f84806b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.png" alt="Longqinx's Notes" class="logo"> <span class="site-name can-hide">Longqinx's Notes</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/java/" class="nav-link">
  Java
</a></div><div class="nav-item"><a href="/c++/" class="nav-link">
  C/C++
</a></div><div class="nav-item"><a href="/linux/" class="nav-link router-link-active">
  Linux
</a></div><div class="nav-item"><a href="/dsa/" class="nav-link">
  数据结构与算法
</a></div><div class="nav-item"><a href="/project/" class="nav-link">
  我的小项目
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="关于" class="dropdown-title"><span class="title">关于</span> <span class="arrow down"></span></button> <button type="button" aria-label="关于" class="mobile-dropdown-title"><span class="title">关于</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/about/contactMe.html" class="nav-link">
  联系我
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/java/" class="nav-link">
  Java
</a></div><div class="nav-item"><a href="/c++/" class="nav-link">
  C/C++
</a></div><div class="nav-item"><a href="/linux/" class="nav-link router-link-active">
  Linux
</a></div><div class="nav-item"><a href="/dsa/" class="nav-link">
  数据结构与算法
</a></div><div class="nav-item"><a href="/project/" class="nav-link">
  我的小项目
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="关于" class="dropdown-title"><span class="title">关于</span> <span class="arrow down"></span></button> <button type="button" aria-label="关于" class="mobile-dropdown-title"><span class="title">关于</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/about/contactMe.html" class="nav-link">
  联系我
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Linux命令行与Shell脚本编程笔记</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#简述" class="sidebar-link">简述</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#shell简述" class="sidebar-link">shell简述</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#基本sell命令" class="sidebar-link">基本Sell命令</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#启动shell" class="sidebar-link">启动shell</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#bash手册" class="sidebar-link">bash手册</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#浏览文件系统" class="sidebar-link">浏览文件系统</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#文件和目录列表" class="sidebar-link">文件和目录列表</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#处理文件" class="sidebar-link">处理文件</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#查看文件内容" class="sidebar-link">查看文件内容</a></li></ul></li><li><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#更多shell命令" class="sidebar-link">更多shell命令</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#监测程序" class="sidebar-link">监测程序</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#监测磁盘空间" class="sidebar-link">监测磁盘空间</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#处理数据文件" class="sidebar-link">处理数据文件</a></li></ul></li><li><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#理解shell" class="sidebar-link">理解shell</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#shell的父子关系" class="sidebar-link">Shell的父子关系</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#shell内建命令" class="sidebar-link">Shell内建命令</a></li></ul></li><li><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#使用环境变量" class="sidebar-link">使用环境变量</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#简述-2" class="sidebar-link">简述</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#设置用户定义变量" class="sidebar-link">设置用户定义变量</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#删除环境变量" class="sidebar-link">删除环境变量</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#设置path环境变量" class="sidebar-link">设置PATH环境变量</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#定位系统环境变量" class="sidebar-link">定位系统环境变量</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#数组变量" class="sidebar-link">数组变量</a></li></ul></li><li><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#linux文件权限" class="sidebar-link">Linux文件权限</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#linux的安全性" class="sidebar-link">Linux的安全性</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#使用linux组" class="sidebar-link">使用Linux组</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#文件权限" class="sidebar-link">文件权限</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#改变安全性设置" class="sidebar-link">改变安全性设置</a></li></ul></li><li><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#管理文件系统" class="sidebar-link">管理文件系统</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#linux文件系统" class="sidebar-link">Linux文件系统</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#操作文件系统" class="sidebar-link">操作文件系统</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#逻辑卷管理" class="sidebar-link">逻辑卷管理</a></li></ul></li><li><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#安装软件程序" class="sidebar-link">安装软件程序</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#包管理基础" class="sidebar-link">包管理基础</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#基于debian的系统" class="sidebar-link">基于Debian的系统</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#基于red-hat的系统" class="sidebar-link">基于Red Hat的系统</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#从源码安装" class="sidebar-link">从源码安装</a></li></ul></li><li><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#使用编辑器" class="sidebar-link">使用编辑器</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#shell脚本编程基础" class="sidebar-link">shell脚本编程基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#创建shell脚本" class="sidebar-link">创建shell脚本</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#显示消息" class="sidebar-link">显示消息</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#使用变量" class="sidebar-link">使用变量</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#重定向输入和输出" class="sidebar-link">重定向输入和输出</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#管道" class="sidebar-link">管道</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#数学运算" class="sidebar-link">数学运算</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#退出脚本" class="sidebar-link">退出脚本</a></li></ul></li><li><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#结构化命令" class="sidebar-link">结构化命令</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#if-then语句" class="sidebar-link">if-then语句</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#if-then-else语句" class="sidebar-link">if-then-else语句</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#test命令" class="sidebar-link">test命令</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#复合条件测试" class="sidebar-link">复合条件测试</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#if-then高级特性" class="sidebar-link">if-then高级特性</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#case语句" class="sidebar-link">case语句</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#for语句" class="sidebar-link">for语句</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#c语言风格的for语句" class="sidebar-link">C语言风格的for语句</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#while语句" class="sidebar-link">while语句</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#util命令" class="sidebar-link">util命令</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#循环处理文件数据" class="sidebar-link">循环处理文件数据</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#控制循环" class="sidebar-link">控制循环</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#处理循环的输出" class="sidebar-link">处理循环的输出</a></li></ul></li><li><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#处理用户输入" class="sidebar-link">处理用户输入</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#命令行参数" class="sidebar-link">命令行参数</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#特殊参数变量" class="sidebar-link">特殊参数变量</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#移动变量" class="sidebar-link">移动变量</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#处理选项" class="sidebar-link">处理选项</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#获取用户输入" class="sidebar-link">获取用户输入</a></li></ul></li><li><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#呈现数据" class="sidebar-link">呈现数据</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#理解输入和输出" class="sidebar-link">理解输入和输出</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#脚本中重定向输出" class="sidebar-link">脚本中重定向输出</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#脚本中重定向输入" class="sidebar-link">脚本中重定向输入</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#自定义重定向" class="sidebar-link">自定义重定向</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#列出打开的文件描述符" class="sidebar-link">列出打开的文件描述符</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#阻止命令输出" class="sidebar-link">阻止命令输出</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#创建临时文件" class="sidebar-link">创建临时文件</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#记录消息" class="sidebar-link">记录消息</a></li></ul></li><li><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#控制脚本" class="sidebar-link">控制脚本</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#处理信号" class="sidebar-link">处理信号</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#后台模式运行脚本" class="sidebar-link">后台模式运行脚本</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#在非控制台下运行脚本" class="sidebar-link">在非控制台下运行脚本</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#作业控制" class="sidebar-link">作业控制</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#调整谦让度" class="sidebar-link">调整谦让度</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#定时运行作业" class="sidebar-link">定时运行作业</a></li></ul></li><li><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#创建函数" class="sidebar-link">创建函数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#基本脚本函数" class="sidebar-link">基本脚本函数</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#返回值" class="sidebar-link">返回值</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#在函数中使用变量" class="sidebar-link">在函数中使用变量</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#数组变量和函数" class="sidebar-link">数组变量和函数</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#函数递归" class="sidebar-link">函数递归</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#创建库" class="sidebar-link">创建库</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#其他" class="sidebar-link">其他</a></li></ul></li><li><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#图形化桌面环境中的脚本编程" class="sidebar-link">图形化桌面环境中的脚本编程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#创建文本菜单" class="sidebar-link">创建文本菜单</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#制作窗口" class="sidebar-link">制作窗口</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#gnome环境使用图形" class="sidebar-link">GNOME环境使用图形</a></li></ul></li><li><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#初识sed和gawk" class="sidebar-link">初识sed和gawk</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#文本处理" class="sidebar-link">文本处理</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#sed编辑器基础" class="sidebar-link">sed编辑器基础</a></li></ul></li><li><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#正则表达式" class="sidebar-link">正则表达式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#正则表达式简述" class="sidebar-link">正则表达式简述</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#定义bre模式" class="sidebar-link">定义BRE模式</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#扩展正则表达式-ere" class="sidebar-link">扩展正则表达式（ERE）</a></li></ul></li><li><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#sed进阶" class="sidebar-link">sed进阶</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#多行命令" class="sidebar-link">多行命令</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#保持空间" class="sidebar-link">保持空间</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#排除命令" class="sidebar-link">排除命令</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#改变流" class="sidebar-link">改变流</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#模式替代" class="sidebar-link">模式替代</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#创建sed实用工具" class="sidebar-link">创建sed实用工具</a></li></ul></li><li><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#gawk进阶" class="sidebar-link">gawk进阶</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#使用变量-2" class="sidebar-link">使用变量</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#使用模式" class="sidebar-link">使用模式</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#结构化命令-2" class="sidebar-link">结构化命令</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#格式化打印" class="sidebar-link">格式化打印</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#内建函数" class="sidebar-link">内建函数</a></li><li class="sidebar-sub-header"><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#自定义函数" class="sidebar-link">自定义函数</a></li></ul></li><li><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#附-符号与常用环境变量含义速查" class="sidebar-link">附：符号与常用环境变量含义速查</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/linux/Shell%E7%BC%96%E7%A8%8B.html#" class="sidebar-link">/linux/Shell%E7%BC%96%E7%A8%8B.html#</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="linux命令行与shell脚本编程笔记"><a href="#linux命令行与shell脚本编程笔记" class="header-anchor">#</a> Linux命令行与Shell脚本编程笔记</h1> <blockquote><p>2021/10/16</p></blockquote> <h2 id="简述"><a href="#简述" class="header-anchor">#</a> 简述</h2> <ul><li>内核相关
<ul><li>内核创建第一个进程（init进程）来启动系统上所有其他进程，内核启动时会将init进程加载到虚拟内存中</li> <li>一些linux发行版使用一个表来管理在系统开机时要自动启动的进程，此表通常在<code>/etc/inittab</code>中。而在另一些系统则采用<code>/etc/init.d</code>目录，将开机时启动或停止的某个应用的脚本放在此目录下，这些脚本通过<code>/etc/rcX.d</code>目录下的入口启动，此处X代表运行级别(run level)</li> <li>Linux中有五种运行级别
<ul><li>运行级别为1时，只启动基本的系统进程以及一个控制台终端进程，即单用户模式。通常用于在系统有问题时进行紧急维护</li> <li>标准启动级别时3，此级别下大多数应用软件都会启动</li> <li>另一种级别是5，在此级别会启动图像化的X Window系统</li></ul></li> <li>可通过调整启动级别控制系统功能</li> <li>Linux加硬件设备当成特殊的文件，称为<strong>设备文件</strong>，分三类
<ul><li>字符型设备文件</li> <li>块设备文件</li> <li>网络设备文件</li></ul></li></ul></li> <li>GNU工具
<ul><li>GNU即GNU is Not Unix缩写</li> <li>GNU项目的主旨在于为Linux系统管理员设计一套类似Unix的环境</li> <li>GNU coreutils软件包三部分
<ul><li>处理文件的工具</li> <li>操作文本的工具</li> <li>管理进程的工具</li></ul></li> <li>shell</li></ul></li></ul> <h2 id="shell简述"><a href="#shell简述" class="header-anchor">#</a> shell简述</h2> <ul><li>通过Ctrl+Alt+F1~7可进入Linux虚拟控制台</li> <li>虚拟控制台下可更改背景、文本颜色。两种方式：setterm-&gt;set terminal
<ul><li>setterm -inversescreen on/off：反转屏幕颜色</li> <li>setterm -background/foreground white：设置背景、前景色</li></ul></li> <li>setterm的一些选项
<ul><li>-background</li> <li>-foreground</li> <li>-inversescreen</li> <li>-reset：重置颜色并清屏</li> <li>-store：存储当前颜色配置为默认方案（reset会使用默认方案）</li></ul></li></ul> <h2 id="基本sell命令"><a href="#基本sell命令" class="header-anchor">#</a> 基本Sell命令</h2> <h3 id="启动shell"><a href="#启动shell" class="header-anchor">#</a> 启动shell</h3> <ul><li><code>/etc/passwd</code>文件包含了所有系统用户账户列表及每个用户的基本配置信息</li> <li>每个字段使用冒号分隔，其中最后一个字段指定了用户使用的shell程序</li></ul> <h3 id="bash手册"><a href="#bash手册" class="header-anchor">#</a> bash手册</h3> <ul><li><p>使用<code>man</code>命令可以访问存储在Linux系统上的手册，格式为<code>man command</code></p></li> <li><p>若不记得命令，可使用关键词搜索手册页，语法为<code>man -K keyword</code></p></li> <li><p>man命令得到的结果有个内容区域，每个内容区域分配了一个1-9的数字，对应不同类型命令：</p> <table><thead><tr><th>区域号</th> <th>意义</th></tr></thead> <tbody><tr><td>1</td> <td>可执行程序或shell命令</td></tr> <tr><td>2</td> <td>系统调用</td></tr> <tr><td>3</td> <td>库调用</td></tr> <tr><td>4</td> <td>特殊文件</td></tr> <tr><td>5</td> <td>文件格式与约定</td></tr> <tr><td>6</td> <td>游戏</td></tr> <tr><td>7</td> <td>概览、约定和杂项</td></tr> <tr><td>8</td> <td>超级用户和系统管理员命令</td></tr> <tr><td>9</td> <td>内核例程</td></tr></tbody></table></li></ul> <h3 id="浏览文件系统"><a href="#浏览文件系统" class="header-anchor">#</a> 浏览文件系统</h3> <ul><li><code>cd</code>(change directory)，用于切换目录</li> <li>在linux中，波浪号 ~ 表示当前用户的主目录；单点 . 表示当前目录，双点 .. 表示父目录</li> <li><code>pwd</code>(print work directory)，打印当前工作目录</li></ul> <h3 id="文件和目录列表"><a href="#文件和目录列表" class="header-anchor">#</a> 文件和目录列表</h3> <ul><li>使用列表命令<code>ls</code>(list)可查看系统中有哪些文件</li> <li>ls在彩色终端中会用不同颜色显示不同类型的文件，颜色方案由<code>LS_COLORS</code>环境变量控制</li> <li>也可使用参数<code>-F</code>区分目录和文件，其会在目录后面加斜线 /；可执行文件后加 *</li> <li>使用参数<code>-a</code>可显示隐藏文件</li> <li>使用参数<code>-R</code>可递归列出所有子目录信息</li> <li>使用参数<code>-i</code>可显示inode号</li> <li>使用参数<code>-l</code>可以以长列表形式输出文件的附加信息，主要有：
<ul><li>文件类型：目录(d) 文件(-) 字符型文件(c) 块设备(b)</li> <li>文件权限</li> <li>文件的硬链接总数</li> <li>文件归属者</li> <li>文件归属组</li> <li>文件大小，字节为单位</li> <li>文件上次修改时间</li> <li>文件名</li></ul></li> <li>ls过滤器
<ul><li>紧接着ls命令后可使用一个类似正则表达式的串过滤出需要显示的文件</li> <li>？表示一个字符</li> <li>* 表示零或多个字符</li> <li>！表示取非</li> <li>[]中可指定元字符通配符</li></ul></li></ul> <h3 id="处理文件"><a href="#处理文件" class="header-anchor">#</a> 处理文件</h3> <ul><li>创建文件
<ul><li><code>touch</code>命令可创建空文件</li> <li>touch还可以更改文件的修改时间，命令格式和创建文件相同</li> <li>其他参数
<ul><li>使用<code>-a</code>可以仅仅修改访问时间</li></ul></li></ul></li> <li>复制文件
<ul><li><code>cp</code>(copy)命令可用于复制文件，基本语法为<code>cp source destination</code></li> <li>带上参数<code>-i</code>可强制shell询问遇到重复时是否覆盖文件</li> <li>参数<code>-R</code>可用于递归复制整个目录内容</li> <li>cp命令中也可以使用通配符完成同一类文件的复制</li></ul></li> <li>链接文件
<ul><li>链接是目录中指向文件真实位置的占位符，linux中有两种文件链接
<ul><li>符号链接：
<ul><li>一个实实在在的文件，指向存放在虚拟目录结构中的某个地方的另一个文件</li> <li>创建符号链接时，原文件必须实现存在，使用命令<code>ln -s</code>创建</li> <li>符号链接文件和原文件不一样，inode编号也不同</li> <li>对符号链接的处理可以看作是文件的绝对路径，在使用符号链接的时候进行替换</li></ul></li> <li>硬链接
<ul><li>硬链接会创建独立的虚拟文件，其中包含原始文件的信息及位置，根本上而言是同一个文件</li> <li>使用<code>ln</code>不带参数创建</li></ul></li></ul></li></ul></li> <li>重命名和移动
<ul><li><code>mv</code>(move)命令可完成文件移动或重命名工作</li></ul></li> <li>删除文件
<ul><li><code>rm</code>(remove)命令用于删除文件</li> <li>参数<code>-i</code>用于提示是否真删除</li> <li>参数<code>-f</code>用于强制删除，没有提醒</li></ul></li> <li>处理目录
<ul><li>创建目录：<code>mkdir</code>命令</li> <li>需要同时创建多个目录和子目录，需要使用<code>-p</code>参数</li> <li>删除目录：<code>rmdir</code>,默认该命令只能删除空目录</li> <li>可使用<code>rm -r</code>递归删除子目录内容</li> <li>PS：<strong>tree工具</strong>可用于树形结构的方式展示目录结构</li></ul></li></ul> <h3 id="查看文件内容"><a href="#查看文件内容" class="header-anchor">#</a> 查看文件内容</h3> <ul><li>查看文件类型
<ul><li><code>file</code>命令能够查看文件属于什么类型</li></ul></li> <li>查看整个文件
<ul><li><code>cat</code>命令：显示所有数据
<ul><li><code>-n</code>给所有行加上行号</li> <li><code>-b</code>仅给有文本的行加上行号</li> <li><code>-T</code>去掉制表符</li></ul></li> <li><code>more</code>命令：显示内容，但会在每页数据后停下来</li> <li><code>less</code>命令：less is more，more的升级版，支持更多选项，能够识别上下键以及上下翻页键</li></ul></li> <li>查看部分文件
<ul><li><code>tail</code>命令：显示文件最后几行的内容，默认10行
<ul><li>通过参数<code>-n</code>控制需要显示的行数</li> <li>此外，参数<code>-f</code>允许在其他进程使用该文件时查看文件内容，tail会保持活动状态，不断显示添加到文件中的内容。是实时检测系统日志的绝妙方式</li></ul></li> <li><code>head</code>命令：显示文件头几行，默认10行
<ul><li>通过参数<code>-n</code>可指定行数</li></ul></li></ul></li></ul> <h2 id="更多shell命令"><a href="#更多shell命令" class="header-anchor">#</a> 更多shell命令</h2> <h3 id="监测程序"><a href="#监测程序" class="header-anchor">#</a> 监测程序</h3> <ul><li><p>探查进程</p> <ul><li><p><code>ps</code>命令。默认情况下只会显示运行在当前控制台下的属于当前用户的进程，只有四个信息：进程PID、运行的终端tty、已用cpu时间和名字</p></li> <li><p>Linux系统中使用GNU ps命令支持3种不同类型的命令行参数</p> <ul><li>Unix风格参数，前面加单破折线</li> <li>BSD风格参数，前面不加破折线</li> <li>GNU风格常参数，双破折线</li></ul></li> <li><p>Unix风格</p> <table><thead><tr><th>参数</th> <th>描述</th></tr></thead> <tbody><tr><td>-A</td> <td>显示所有进程</td></tr> <tr><td>-N</td> <td>显示与指定参数不符的所有进程</td></tr> <tr><td>-a</td> <td>显示除控制进程和无终端进程外的所有进程</td></tr> <tr><td>-d</td> <td>显示除控制进程外的所有进程</td></tr> <tr><td>-e</td> <td>显示所有进程</td></tr> <tr><td>-C cmdlist</td> <td>显示包含在cmdlist列表中的进程</td></tr> <tr><td>-G grplist</td> <td>显示组ID包含在grplist中的进程</td></tr> <tr><td>-U userlist</td> <td>显示属主的用户ID在userid中的进程</td></tr> <tr><td>-g grplist</td> <td>显示会话或组ID在grplist中的进程</td></tr> <tr><td>-p pidlist</td> <td>......</td></tr> <tr><td>-s sesslist</td> <td></td></tr> <tr><td>-t ttylist</td> <td></td></tr> <tr><td>-u userlist</td> <td>有效用户ID在列表中的进程</td></tr> <tr><td>-F</td> <td>显示更多额外信息，相对于f</td></tr> <tr><td>-O format</td> <td>显示默认的输出列即format列表指定的列</td></tr> <tr><td>-M</td> <td>显示进程安全信息</td></tr> <tr><td>-c</td> <td>显示进程额外调度器信息</td></tr> <tr><td>-f</td> <td>显示完整格式输出</td></tr> <tr><td>-j</td> <td>显示任务信息</td></tr> <tr><td>-l</td> <td>显示长列表</td></tr> <tr><td>-o format</td> <td>显示仅由format指定的列</td></tr> <tr><td>-y</td> <td>不显示进程标记</td></tr> <tr><td>-Z</td> <td>显示安全标签信息</td></tr> <tr><td>-H</td> <td>用层级格式显示进程</td></tr> <tr><td>-n namelist</td> <td>定义WCHAN列显示值</td></tr> <tr><td>-w</td> <td>采用宽输出模式，不限宽显示</td></tr> <tr><td>-L</td> <td>显示进程中的线程</td></tr> <tr><td>-V</td> <td>希纳是ps命令版本号</td></tr></tbody></table> <ul><li>扩展信息含义</li></ul> <table><thead><tr><th>名称</th> <th>含义</th></tr></thead> <tbody><tr><td>UID</td> <td>启动进程的用户</td></tr> <tr><td>PID</td> <td>进程的ID</td></tr> <tr><td>PPID</td> <td>进程父进程ID</td></tr> <tr><td>C</td> <td>进程生命周期中的CPU利用率</td></tr> <tr><td>STIME</td> <td>进程启动时的系统时间</td></tr> <tr><td>TTY</td> <td>进程启动时的终端设备</td></tr> <tr><td>TIME</td> <td>运行进程需要的累计CPU时间</td></tr> <tr><td>CMD</td> <td>启动的程序名称</td></tr> <tr><td>F</td> <td>内核分配给进程的系统标记</td></tr> <tr><td>S</td> <td>进程的状态(O：运行，S：休眠，R：可运行在等待，Z：僵化，即已经结束但父进程不存在，T：停止)</td></tr> <tr><td>PRI</td> <td>进程优先级，越大越低</td></tr> <tr><td>NI</td> <td>谦让度值，用于参与优先级决定</td></tr> <tr><td>ADDR</td> <td>进程内存地址</td></tr> <tr><td>SZ</td> <td>假设进程被换出，所需交换空间大小</td></tr> <tr><td>WCHAN</td> <td>进程休眠的内核函数地址</td></tr></tbody></table></li> <li><p>BSD风格</p> <table><thead><tr><th>参数</th> <th>描述</th></tr></thead> <tbody><tr><td>T</td> <td>显示跟当前终端关联的所有进程</td></tr> <tr><td>a</td> <td>显示跟任意终端关联的所有进程</td></tr> <tr><td>g</td> <td>显示包括控制进程在内的所有进程</td></tr> <tr><td>r</td> <td>仅显示运行中进程</td></tr> <tr><td>x</td> <td>显示所有进程，包括未分配任何终端的进程</td></tr> <tr><td>U userlist</td> <td></td></tr> <tr><td>p pidlist</td> <td></td></tr> <tr><td>t ttylist</td> <td></td></tr> <tr><td>O format</td> <td></td></tr> <tr><td>X</td> <td>按过去的Linux i386寄存器格式显示</td></tr> <tr><td>Z</td> <td>将安全信息添加到输出</td></tr> <tr><td>j</td> <td>显示任务信息</td></tr> <tr><td>l</td> <td>长列表</td></tr> <tr><td>o format</td> <td></td></tr> <tr><td>s</td> <td>采用信号格式显示</td></tr> <tr><td>u</td> <td>采用基于用户的格式显示</td></tr> <tr><td>v</td> <td>采用虚拟内存格式显示</td></tr> <tr><td>N namelist</td> <td></td></tr> <tr><td>O order</td> <td>定义显示信息列的顺序</td></tr> <tr><td>S</td> <td>将数值信息从子进程加到父进程，如cpu和内存使用</td></tr> <tr><td>c</td> <td>显示真实的命令名称</td></tr> <tr><td>e</td> <td>显示命令使用的环境变量</td></tr> <tr><td>f</td> <td>用分层格式显示进程</td></tr> <tr><td>h</td> <td>不显示头信息</td></tr> <tr><td>k sort</td> <td>指定用以将输出排序的列</td></tr> <tr><td>n</td> <td>和WCHAN一起显示，用数值表示用户ID和组ID</td></tr> <tr><td>w</td> <td>为较宽屏幕显示宽输出</td></tr> <tr><td>H</td> <td>将线程按进程显示</td></tr> <tr><td>m</td> <td>在进程后显示线程</td></tr> <tr><td>L</td> <td>列出所有格式指定符</td></tr> <tr><td>V</td> <td>显示ps版本</td></tr></tbody></table> <ul><li>额外的扩展信息</li></ul> <table><thead><tr><th>名称</th> <th>描述</th></tr></thead> <tbody><tr><td>VSZ</td> <td>进程在内存中的大小，KB为单位</td></tr> <tr><td>RSS</td> <td>进程在未换出时占用的物理内存</td></tr> <tr><td>STAT</td> <td>当前进程状态。双字符状态码</td></tr></tbody></table> <ul><li>其中，STAT状态第一个字符与Unix的S相同，表示休眠、运行还是等待；第二个参数意义如下：</li></ul> <table><thead><tr><th>符号</th> <th>描述</th></tr></thead> <tbody><tr><td>&lt;</td> <td>该进程运行在高优先级上</td></tr> <tr><td>N</td> <td>该进程运行在低优先级上</td></tr> <tr><td>L</td> <td>该进程有页面锁定在内存</td></tr> <tr><td>s</td> <td>该进程是控制进程</td></tr> <tr><td>l</td> <td>该进程是多线程的</td></tr> <tr><td>+</td> <td>该进程运行在前台</td></tr></tbody></table></li> <li><p>GNU长参数</p> <table><thead><tr><th>参数</th> <th>描述</th></tr></thead> <tbody><tr><td>--deselect</td> <td>显示所有进程</td></tr> <tr><td>--Group grouplist</td> <td></td></tr> <tr><td>--User userlist</td> <td></td></tr> <tr><td>--group grouplist</td> <td></td></tr> <tr><td>--pid pidlist</td> <td></td></tr> <tr><td>--ppid ppidlist</td> <td></td></tr> <tr><td>--sid sidlist</td> <td></td></tr> <tr><td>--tty ttylist</td> <td></td></tr> <tr><td>--user userlist</td> <td></td></tr> <tr><td>--format format</td> <td></td></tr> <tr><td>--context</td> <td>显示额外安全信息</td></tr> <tr><td>--cols n</td> <td>将屏幕宽度设为 n 列</td></tr> <tr><td>--columns n</td> <td>将屏幕宽度设为 n 列</td></tr> <tr><td>--cumulative</td> <td>包含已停止的子进程信息</td></tr> <tr><td>--forest</td> <td>用层级结构显示进程关系</td></tr> <tr><td>--headers</td> <td>每页输出中都显示列头</td></tr> <tr><td>--no-headers</td> <td>不显示列头</td></tr> <tr><td>--lines n</td> <td>屏幕高度设为 n 行</td></tr> <tr><td>--rows n</td> <td>屏幕高度设置为 n 排</td></tr> <tr><td>--sort order</td> <td>指定将输出按照哪列排序</td></tr> <tr><td>--width n</td> <td>将屏幕宽度设为 n 列</td></tr> <tr><td>--help</td> <td>显示帮助</td></tr> <tr><td>--info</td> <td>显示调试信息</td></tr> <tr><td>--version</td> <td>显示版本</td></tr></tbody></table></li></ul></li> <li><p>实时监测</p> <ul><li><p>ps只能显示某个特定时间点的进程信息</p></li> <li><p><code>top</code>命令和ps类似，能显示进程信息，并且是实时的</p></li> <li><p>top输出第一部分显示系统概况</p> <ul><li>第一行：当前系统时间、已运行时间；登录用户数量；系统平均负载(最近 1 5 15 分钟)</li> <li>第二行：进程(task)概要信息。多少进程、多少在运行、休眠、停止、僵化</li> <li>第三行：CPU概要信息。根据属主和进程状态将cpu利用率分为几类输出</li> <li>第四行：物理内存信息。总内存；空闲；使用了多少等</li> <li>第五行：系统交换空间信息。类似上一行</li></ul></li> <li><p>后一部分显示进程详细列表，列含义如下：</p> <table><thead><tr><th>列名</th> <th>含义</th></tr></thead> <tbody><tr><td>PID</td> <td>进程ID</td></tr> <tr><td>USER</td> <td>进程属主名</td></tr> <tr><td>PR</td> <td>进程优先级</td></tr> <tr><td>NI</td> <td>进程谦让度值</td></tr> <tr><td>VIRT</td> <td>进程占用的虚拟内存总量</td></tr> <tr><td>RES</td> <td>进程占用的物理内存总量</td></tr> <tr><td>SHR</td> <td>进程和其他进程共享的内存总量</td></tr> <tr><td>S</td> <td>进程的状态。D:可中断的休眠；R:运行；S:休眠；T:跟踪或停止；Z:僵化</td></tr> <tr><td>%CPU</td> <td>进程使用CPU时间比例</td></tr> <tr><td>%MEM</td> <td>进程使用的内存占可用内存比例</td></tr> <tr><td>TIME+</td> <td>自进程启动到目前位置的CPU时间总量</td></tr> <tr><td>COMMAND</td> <td>进程对应的名称</td></tr></tbody></table></li> <li><p>top运行时可键入单个键改变top行为</p> <ul><li><code>f</code>：选择对输出进行排序的字段</li> <li><code>d</code>：允许修改轮询间隔</li> <li><code>q</code>：退出top</li></ul></li></ul></li> <li><p>结束进程</p> <ul><li><p>在Linux中沿用了Unix进程间通信的方法，即通过<strong>信号</strong>来通信。进程的信号是一个预定好的消息，进程能识别它并决定忽略还是作出反应</p></li> <li><p><span id="linux-signal">Linux进程信号</span></p> <table><thead><tr><th>信号</th> <th>名称</th> <th>描述</th></tr></thead> <tbody><tr><td>1</td> <td>SIGHUP(hung-up)</td> <td>挂起</td></tr> <tr><td>2</td> <td>SIGINT(Interrupt)</td> <td>终端</td></tr> <tr><td>3</td> <td>SIGQUIT</td> <td>结束运行</td></tr> <tr><td>9</td> <td>SIGKILL</td> <td>无条件终止</td></tr> <tr><td>11</td> <td>SIGSEGV</td> <td>段错误</td></tr> <tr><td>15</td> <td>SIGTERM</td> <td>尽可能终止</td></tr> <tr><td>17</td> <td>SIGSTOP</td> <td>无条件停止运行，但不终止</td></tr> <tr><td>18</td> <td>SIGTSTP</td> <td>停止或暂停，但继续在后台运行</td></tr> <tr><td>19</td> <td>SIGCONT</td> <td>在STOP或TSTP之后恢复执行</td></tr></tbody></table></li> <li><p>Linux中有两个命令可向运行中的进程发出进程信号</p> <ul><li><code>kill</code> <ul><li>kill可通过PID给进程发送信号。默认kill会给命令行列出的PID发送一个TERM信号</li> <li>若需要强制终止，使用<code>-s</code>参数可指定发送其他信号，如<code>kill -s HUP 3325</code></li></ul></li> <li><code>killall</code> <ul><li>支持通过进程名而不是PID来结束进程，killall也支持通配符。如<code>killall http*</code></li></ul></li></ul></li></ul></li></ul> <h3 id="监测磁盘空间"><a href="#监测磁盘空间" class="header-anchor">#</a> 监测磁盘空间</h3> <ul><li><p>挂载存储媒体</p> <ul><li><p>Linux系统将所有磁盘都并入一个虚拟目录下，在使用新的存储媒介之前，需要把它放到虚拟目录下，即<strong>挂载(mounting)</strong></p></li> <li><p><code>mount</code>命令用于挂在媒体。默认情况下mount会输出当前系统上挂在的设备列表。提供四部分信息</p> <ul><li>媒体设备文件名</li> <li>媒体挂载到虚拟目录的挂载点</li> <li>文件系统类型</li> <li>已挂载媒体的访问状态</li></ul></li> <li><p>手动挂载设备基本命令</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">mount</span> <span class="token parameter variable">-t</span> <span class="token builtin class-name">type</span> device directory
</code></pre></div><ul><li>其中，type制定了磁盘被格式化的文件系统类型，若与windows共用，常使用
<ul><li>vfat：windows长文件系统</li> <li>ntfs：WindowsNT、XP、Vista等广泛使用的高级文件系统</li> <li>iso9660：标准CD-ROM文件系统</li></ul></li></ul></li> <li><p>mount的其他参数</p> <table><thead><tr><th>参数</th> <th>描述</th></tr></thead> <tbody><tr><td>-a</td> <td>挂载/etc/fstab文件中指定的所有文件系统</td></tr> <tr><td>-f</td> <td>使mount命令模拟挂载设备，但并不真正挂载</td></tr> <tr><td>-F</td> <td>和-a一起使用，会同时挂载所有文件系统</td></tr> <tr><td>-v</td> <td>详细模式，会说明挂载设备的每一步</td></tr> <tr><td>-I</td> <td>不启用任何/sbin/mount.filesystem下的文件系统帮助文件</td></tr> <tr><td>-l</td> <td>给ext2、ext3或XFS文件系统自动添加文件系统标签</td></tr> <tr><td>-n</td> <td>挂载设备，但不注册到/etc/mtab已挂载设备文件中</td></tr> <tr><td>-p num</td> <td>进行加密挂载时，从文件描述符num中获得密码短语</td></tr> <tr><td>-s</td> <td>忽略该文件系统不支持的挂载选项</td></tr> <tr><td>-r</td> <td>将设备挂载为只读的</td></tr> <tr><td>-w</td> <td>将设备挂载为可读写的(默认)</td></tr> <tr><td>-L label</td> <td>将设备按照指定label挂载</td></tr> <tr><td>-U uuid</td> <td>将设备按照指定UUID挂载</td></tr> <tr><td>-O</td> <td>和-a一起使用，限制命令只作用于特定的一组文件系统</td></tr> <tr><td>-o</td> <td>给文件系统添加特定的选项</td></tr></tbody></table></li> <li><p>-o的一些选项（逗号分隔）</p> <ul><li>ro：只读形式挂载</li> <li>rw：读写形式挂载</li> <li>user：允许普通用户挂载文件系统</li> <li>check=none：挂载是不进行完整性校验</li> <li>loop：挂在一个文件</li></ul></li> <li><p><code>umount</code>命令用于卸载设备，可通过挂载目录或者设备进行卸载。格式</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">umount</span> <span class="token punctuation">[</span>directory<span class="token operator">|</span>device<span class="token punctuation">]</span>
</code></pre></div></li></ul></li> <li><p><strong>使用df命令</strong></p> <ul><li><code>df</code>命令可用于查看所有已挂载磁盘的使用情况</li> <li>参数<code>-h</code>可把输出中的磁盘空间按照用户易读的形式显示，如用M、G等单位</li></ul></li> <li><p><strong>使用du命令</strong></p> <ul><li><p><code>du</code>用于显示某个目录（默认当前）的磁盘使用情况</p></li> <li><p>可用于快速判断系统上某个目录是否有超大文件</p></li> <li><p>常用参数</p> <table><thead><tr><th>参数</th> <th>描述</th></tr></thead> <tbody><tr><td>-c</td> <td>显示所有已列出文件总的大小</td></tr> <tr><td>-h</td> <td>按用户易读形式显示，用K、M、G等单位</td></tr> <tr><td>-s</td> <td>显示每个输出参数的总计</td></tr></tbody></table></li></ul></li></ul> <h3 id="处理数据文件"><a href="#处理数据文件" class="header-anchor">#</a> 处理数据文件</h3> <ul><li><p>排序数据</p> <ul><li><p><code>sort</code>命令用于排序，默认按照会话指定的语言排序规则对<strong>文本文件</strong>中的<strong>数据行</strong>排序</p></li> <li><p>默认情况sort将数字当作字符，所以不能直接使用sort排序数字。而要使用<code>-n</code>参数</p></li> <li><p><code>-M</code>参数按月排序。sort能识别三字符的月份名。如Jan、Feb、Mar...</p></li> <li><p>参数一览</p> <table><thead><tr><th>参数</th> <th>全名</th> <th>描述</th></tr></thead> <tbody><tr><td>-b</td> <td>--ignore-leading-blanks</td> <td>忽略起始空白</td></tr> <tr><td>-C</td> <td>--check=quiet</td> <td>不排序，数据无序也不报告</td></tr> <tr><td>-c</td> <td>--check</td> <td>不排序，检查输入的数据是否已排序，未排序则报告</td></tr> <tr><td>-d</td> <td>--dictionary-order</td> <td>仅考虑空白和字母，不考虑特殊字符</td></tr> <tr><td>-f</td> <td>--ignore-case</td> <td>默认会将大写排在前，此参数忽略大小写</td></tr> <tr><td>-g</td> <td>--general-number-sort</td> <td>按通用数值排序。把值当做浮点数，支持科学计数法</td></tr> <tr><td>-i</td> <td>--ignore-nonprinting</td> <td>忽略不可打印字符</td></tr> <tr><td>-k</td> <td>--key=POS1[,POS2]</td> <td>排序从pos1到pos2</td></tr> <tr><td>-M</td> <td>--month-sort</td> <td>按三字符月份名排序</td></tr> <tr><td>-m</td> <td>--merge</td> <td>合并两个已排序文件</td></tr> <tr><td>-n</td> <td>--numeric-sort</td> <td>将字符串按数值排序，不会转换为浮点数</td></tr> <tr><td>-o</td> <td>--output=file</td> <td>将排序结果写出到指定文件</td></tr> <tr><td>-R</td> <td>--random-sort/--random-source=file</td> <td>按随机生成的散列表键值排序</td></tr> <tr><td>-r</td> <td>--reverse</td> <td>逆序（降序）</td></tr> <tr><td>-S</td> <td>--buffer-size=SIZE</td> <td>指定使用内存大小</td></tr> <tr><td>-s</td> <td>--stable</td> <td>禁用最后重排序比较</td></tr> <tr><td>-T</td> <td>--temporary-directory=DIR</td> <td>指定一个位置存储临时工作文件</td></tr> <tr><td>-t</td> <td>--field-separator</td> <td>指定一个用来区分键位置的字符</td></tr> <tr><td>-u</td> <td>--unique</td> <td>和-c一起使用，检查严格排序。不和c一起时，进输出第一例相似两行</td></tr> <tr><td>-z</td> <td>--zero-terminated</td> <td>以NULL字符为行尾，而非换行符</td></tr></tbody></table></li> <li><p>-k和-t参数载对按字段分隔的数据进行排序时十分有用。-t指定分隔符，-k指定排序的字段。如</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">sort</span> <span class="token parameter variable">-t</span> <span class="token string">':'</span> <span class="token parameter variable">-k</span> <span class="token number">3</span> <span class="token parameter variable">-n</span> /etc/passwd
</code></pre></div></li></ul></li> <li><p>搜索数据</p> <ul><li><code>grep</code>命令用于查找。格式为<code>grep [option] pattern [file]</code></li> <li>参数<code>-v</code>用于反向搜索，即输出不匹配模式的行</li> <li>参数<code>-n</code>用于显示匹配模式的行所在的行号</li> <li>参数<code>-c</code>用于显示匹配的行数</li> <li>参数<code>-e</code>用于指定多个匹配模式(pattern)</li> <li>grep使用Unix风格的正则表达式进行匹配</li> <li><code>egrep</code>命令是grep的衍生，支持POSIX扩展的正则表达式。含有更多用来指定匹配模式的字符</li> <li><code>fgrep</code>支持将匹配模式指定为用换行符分隔的一列固定长度的字符串，这样就可把这列字符放在文件中用fgrep搜索</li></ul></li> <li><p>压缩数据</p> <ul><li><p>Linux上的文件压缩工具</p> <table><thead><tr><th>工具</th> <th>扩展名</th> <th>描述</th></tr></thead> <tbody><tr><td>bzip2</td> <td>.bz2</td> <td>采用Burrows-Wheeler快排序压缩和霍夫曼编码</td></tr> <tr><td>compress</td> <td>.Z</td> <td>最初的Unix文件压缩工具</td></tr> <tr><td>gzip</td> <td>.gz</td> <td>GNU压缩工具，用Lempel-Ziv编码</td></tr> <tr><td>zip</td> <td>.zip</td> <td>Windows上PKZIP工具的Unix实现</td></tr></tbody></table></li> <li><p>gzip包含</p> <ul><li>gzip：用于压缩文件</li> <li>gzcat：用于查看压缩过的文本文件内容</li> <li>gunzip：用于解压文件</li></ul></li></ul></li> <li><p>归档数据</p> <ul><li><p>Unix和Linux上广泛使用的归档工具是<code>tar</code>命令</p></li> <li><p>命令格式</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">tar</span> <span class="token keyword">function</span> <span class="token punctuation">[</span>option<span class="token punctuation">]</span> object1 object2 <span class="token punctuation">..</span><span class="token punctuation">..</span>
</code></pre></div></li> <li><p>function定义tar应该做啥</p> <table><thead><tr><th>功能</th> <th>长名称</th> <th>描述</th></tr></thead> <tbody><tr><td>-A</td> <td>--concatenate</td> <td>将一个已有的tar归档追加到另一个已有的tar归档文件</td></tr> <tr><td>-c</td> <td>--create</td> <td>创建一个新的tar归档文件</td></tr> <tr><td>-d</td> <td>--diff/--delete</td> <td>检查归档文件和文件系统的不同/从已有tar中删除</td></tr> <tr><td>-r</td> <td>--append</td> <td>追加文件到已有tar归档文件尾</td></tr> <tr><td>-t</td> <td>--list</td> <td>列出已有tar归档文件内容</td></tr> <tr><td>-u</td> <td>--update</td> <td>将比tar归档文件中已有的同名文件新的文件追加到tar归档</td></tr> <tr><td>-x</td> <td>--extract</td> <td>从已有tar归档中提取</td></tr></tbody></table></li> <li><p>option，常见选项参数</p> <table><thead><tr><th>选项</th> <th>描述</th></tr></thead> <tbody><tr><td>-C dir</td> <td>切换到指定目录</td></tr> <tr><td>-f file</td> <td>输出结果到文件或设备file</td></tr> <tr><td>-j</td> <td>重定向输出给bzip2命令压缩</td></tr> <tr><td>-p</td> <td>保留所有文件权限</td></tr> <tr><td>-v</td> <td>处理文件时显示文件</td></tr> <tr><td>-z</td> <td>输出重定向给gzip压缩</td></tr></tbody></table></li> <li><p>常用组合</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token comment"># 创建归档文件. 包含两个目录</span>
<span class="token function">tar</span> <span class="token parameter variable">-cvf</span> test.tar test/ test2/

<span class="token comment"># 列出归档文件内容</span>
<span class="token function">tar</span> <span class="token parameter variable">-tf</span> test.tar

<span class="token comment"># 提取tar中的内容</span>
<span class="token function">tar</span> <span class="token parameter variable">-xvf</span> test.tar

<span class="token comment"># 提取用gzip压缩过的tar （.tgz结尾）</span>
<span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> test.tgz
</code></pre></div></li></ul></li></ul> <h2 id="理解shell"><a href="#理解shell" class="header-anchor">#</a> 理解shell</h2> <h3 id="shell的父子关系"><a href="#shell的父子关系" class="header-anchor">#</a> Shell的父子关系</h3> <ul><li><p>在CLI提示符中输入bash后，会创建一个新的shell程序，被称为子shell</p></li> <li><p>bash shell可通过参数修改shell启动方式</p> <table><thead><tr><th>参数</th> <th>描述</th></tr></thead> <tbody><tr><td>-c string</td> <td>从string读取命令并进行处理</td></tr> <tr><td>-i</td> <td>启动一个能够接受用户输入的交互shell</td></tr> <tr><td>-l</td> <td>以登录shell形式启动</td></tr> <tr><td>-r</td> <td>启动受限shell，用户会被限制在默认目录中</td></tr> <tr><td>-s</td> <td>从标准输入中读取命令</td></tr></tbody></table></li> <li><p><strong>进程列表</strong></p> <ul><li><p>命令列表：在一行中指定要依次运行的一系列命令，可通过命令列表实现，只需要在命令间加入分号(;)即可.</p></li> <li><p>进程列表：在命令列表的基础上添加小括号</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">pwd</span><span class="token punctuation">;</span><span class="token function">ls</span><span class="token punctuation">;</span><span class="token builtin class-name">cd</span> /etc<span class="token punctuation">;</span><span class="token builtin class-name">pwd</span><span class="token variable">)</span></span>
</code></pre></div></li> <li><p>括号的加入使得命令列表变成进程列表，进程列表会生成子shell来执行该命令</p></li> <li><p>通过环境变量<code>$BASH_SUBSHELL</code>可判断是否生成子shell</p></li></ul></li> <li><p><strong>其他子shell用法</strong></p> <ul><li><p>进程列表、协程、管道都利用了子shell</p> <ol><li><p>后台模式</p> <ul><li>后台模式中运行命令可以在处理命令同时让出CLI</li> <li><code>sleep</code>命令接收一个参数，即希望睡眠的秒数，睡眠完成后返回shell</li> <li><strong>要将命令置入后台，可在命令末尾加字符<code>&amp;</code></strong></li></ul> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">sleep</span> <span class="token number">10</span><span class="token operator">&amp;</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>处了ps，可使用<code>jobs</code>命令显示后台作业信息。参数<code>-l</code>可用于显示详细信息</li></ul></li> <li><p>将进程列表置入后台</p> <ul><li>在进程列表后加&amp;将其置入后台，通常对于使用tar等后台归档的程序十分有用</li></ul></li> <li><p>协程</p> <ul><li>协程可同时做两件事：后台生成子shell，在子shell中执行命令</li> <li>使用<code>coproc</code>命令使用协程</li></ul> <div class="language-bash extra-class"><pre class="language-bash"><code>coproc <span class="token function">sleep</span> <span class="token number">10</span>
</code></pre></div><ul><li>可以用花括号语法格式给协程命名</li></ul> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token comment"># 命名与第一个花括号需要一个空格，语句以分号结尾，分号与最后一个花括号也有间隔</span>
coproc my_job <span class="token punctuation">{</span> <span class="token function">sleep</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre></div></li></ol></li></ul></li></ul> <h3 id="shell内建命令"><a href="#shell内建命令" class="header-anchor">#</a> Shell内建命令</h3> <ul><li><p><strong>外部命令</strong></p> <ul><li><p>文件系统命令，存在于bash shell之外的程序，并不是shell的一部分，常位于<code>/bin、/usr/bin、/sbin、/usr/sbin</code>中</p></li> <li><p>ps也是一个外部命令，可使用<code>which</code>和<code>type</code>命令找到</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">which</span> <span class="token function">ps</span>
/bin/ps

$ <span class="token builtin class-name">type</span> <span class="token parameter variable">-a</span> <span class="token function">ps</span>
<span class="token function">ps</span> is /bin/ps
</code></pre></div></li> <li><p>外部命令执行时会创建出一个子进程，即<strong>衍生(forking)</strong></p></li></ul></li> <li><p><strong>内建命令</strong></p> <ul><li><p>内建命令不需要子进程来执行，已经和shell编译成一体</p></li> <li><p>可使用<code>type</code>命令查看一个命令是否是内建的，如<code>type cd</code></p></li> <li><p>某些命令可能有多种实现，可使用<code>type -a</code>查看命令的多种实现</p> <ol><li><p>使用history命令</p> <ul><li>查看最近使用的命令历史记录</li> <li>通过环境变量<code>HISTSIZE</code>可修改历史记录条数</li> <li>通过<code>!!</code>并回车就能重新执行刚才执行过的命令</li> <li>默认history记录存放在内存中，当shell退出时被写入文件。文件位于用户主目录中，名为<code>.bash_history</code></li> <li>需要在退出前强制将命令写入文件使用<code>-a</code>参数</li> <li>使用<code>!n</code>其中 n 为历史记录的序号即可快速执行历史中的第n个命</li></ul></li> <li><p>命令别名</p> <ul><li>使用<code>alias -p</code> 可查看当前可用别名</li> <li>使用alias创建别名语法</li></ul> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">alias</span> <span class="token assign-left variable">li</span><span class="token operator">=</span><span class="token string">'ls -li'</span>
</code></pre></div><ul><li>命令别名属于内建命令，一个别名<strong>仅在其所定义的shell进程中生效</strong>。但也可通过环境变量等方式扩展</li></ul></li></ol></li></ul></li></ul> <h2 id="使用环境变量"><a href="#使用环境变量" class="header-anchor">#</a> 使用环境变量</h2> <h3 id="简述-2"><a href="#简述-2" class="header-anchor">#</a> 简述</h3> <ul><li>环境变量用于存储有关shell会话和工作环境的信息</li> <li>分类：全局环境变量和局部环境变量</li> <li>全局环境变量
<ul><li>对shell和其子shell都可见</li> <li>Linux内置了一些系统环境变量，通常用大写与用户变量区分</li> <li>通过<code>env</code>或<code>printenv</code>查看全局变量</li> <li>需要显示特定名字的环境变量使用<code>printenv NAME</code>格式，如<code>printenv HOME</code>；此外，也可使用<code>echo $HOME</code>的形式</li></ul></li> <li>局部环境变量
<ul><li>只对创建它的shell可见</li> <li><code>set</code>命令可显示局部、全局、用户自定义的变量；并按照字母排序</li></ul></li></ul> <h3 id="设置用户定义变量"><a href="#设置用户定义变量" class="header-anchor">#</a> 设置用户定义变量</h3> <ul><li><p>局部用户定义变量</p> <ul><li><p>通过等号给环境变量赋值即可，值可以是数字或字符串（局部，因此子shell不可用该变量）</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token assign-left variable">my_variable</span><span class="token operator">=</span><span class="token string">&quot;hello world&quot;</span>
<span class="token builtin class-name">echo</span> <span class="token variable">$my_variable</span>
</code></pre></div></li> <li><p>注意：变量名、等号、值之间不能有空格</p></li></ul></li> <li><p>全局环境变量</p> <ul><li><p>先创建局部变量，然后通过<code>export</code>导出到全局环境中</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token assign-left variable">my_variable</span><span class="token operator">=</span><span class="token string">&quot;hello world&quot;</span>
<span class="token builtin class-name">export</span> my_variable
</code></pre></div></li> <li><p>==修改子shell中全局环境变量的值并不会影响到父shell中该变量的值，包括使用<code>export</code>导出也不行==</p></li></ul></li></ul> <h3 id="删除环境变量"><a href="#删除环境变量" class="header-anchor">#</a> 删除环境变量</h3> <ul><li><p>使用<code>unset</code>命令可删除一个环境变量</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">unset</span> my_variable
</code></pre></div></li> <li><p>==注意==：子shell中删除环境变量并不会影响父shell中该变量的值</p></li></ul> <h3 id="设置path环境变量"><a href="#设置path环境变量" class="header-anchor">#</a> 设置PATH环境变量</h3> <ul><li><p>PATH环境变量定义了用于进行命令和程序查找的目录</p></li> <li><p>使用冒号分隔目录</p></li> <li><p>常用设置方法</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token comment"># 查看PATH变量</span>
<span class="token builtin class-name">echo</span> <span class="token environment constant">$PATH</span>

<span class="token comment"># 添加新内容</span>
<span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span>:/home/xiao/bin
</code></pre></div></li> <li><p>上述对PATH的修改只能持续到退出或者重启系统</p></li></ul> <h3 id="定位系统环境变量"><a href="#定位系统环境变量" class="header-anchor">#</a> 定位系统环境变量</h3> <ul><li>登入Linux系统启动一个shell时，默认bash会在几个<strong>启动文件</strong>或<strong>环境文件</strong>中查找命令</li> <li>启动shell的三种方式
<ul><li>登录时作为默认登录shell</li> <li>作为非登录shell的交互式shell</li> <li>作为运行脚本的非交互式shell</li></ul></li> <li><strong>登录shell</strong> <ul><li>登录shell会从5个不同启动文件里读取命令
<ul><li>/etc/profile</li> <li>$HOME/.bash_profile</li> <li>$HOME/.bashrc</li> <li>$HOME/.bash_login</li> <li>$HOME/.profile</li></ul></li> <li><code>/etc/profile</code>是默认的bash shell主启动文件，每个用户登录时都会执行此启动文件；另外四个是针对用户的，可按需定制</li> <li>/etc/profile是shell默认的主启动文件，只要登录就会执行其中的命令。其中的for语句可用于迭代<code>/etc/profile.d</code>目录下的所有文件。shell登录时会执行这些文件中的命令</li> <li>剩下的$HOME目录下的启动文件有同样的作用，即提供一个用户专属的启动文件来定义该用户用到的环境变量</li></ul></li> <li><strong>交互式shell进程</strong> <ul><li>交互式的shell（在命令提示符环境下敲bash启动）不会访问<code>/etc/profile</code>文件，只会检查用户目录下的<code>.bashrc</code>文件</li></ul></li> <li><strong>非交互式shell</strong> <ul><li>最后一种是非交互式shell，系统执行shell脚本时用的即非交互式shell</li> <li>系统提供了一个BASH_ENV环境变量，当shell启动一个非交互式shell进程时，其会检查这个环境变量来查看要执行的启动文件</li></ul></li> <li><strong>环境变量持久化</strong> <ul><li>使用上述的启动文件就可实现变量的持久化</li> <li>通常最好在<code>/etc/profile.d</code>目录中创建一个以<code>.sh</code>结尾的文件。把所有新的或修改过的全局环境变量设置放在这个文件中</li> <li>多数发行版中存储个人用户永久性shell变量的地方是<code>$HOME/.bashrc</code>文件，适用于所有类型的shell进程</li></ul></li></ul> <h3 id="数组变量"><a href="#数组变量" class="header-anchor">#</a> 数组变量</h3> <ul><li><p>环境变量可作为数组使用</p></li> <li><p>给某个环境变量设置多个值，可把值放在括号中，值与值之间用空格分隔</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token assign-left variable">my_array</span><span class="token operator">=</span><span class="token punctuation">(</span>one two three four<span class="token punctuation">)</span>
</code></pre></div></li> <li><p>在使用单个元素的时候，按照以下格式索引(从零开始)</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">echo</span> <span class="token variable">${my_array<span class="token punctuation">[</span>2<span class="token punctuation">]</span>}</span>
</code></pre></div></li> <li><p>显示整个数组可使用通配符</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">echo</span> <span class="token variable">${my_array<span class="token punctuation">[</span>*<span class="token punctuation">]</span>}</span>
</code></pre></div></li> <li><p>元素或整个数组的删除</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token comment"># 删除整个数组</span>
<span class="token builtin class-name">unset</span> my_array
<span class="token comment"># 删除下标为 2 的元素，但该位置还存在</span>
<span class="token builtin class-name">unset</span> my_array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>
</code></pre></div></li></ul> <h2 id="linux文件权限"><a href="#linux文件权限" class="header-anchor">#</a> Linux文件权限</h2> <h3 id="linux的安全性"><a href="#linux的安全性" class="header-anchor">#</a> Linux的安全性</h3> <ul><li><p>Linux系统安全的核心是用户账户。用户权限是通过创建用户时分配的用户ID(UID)来跟踪的</p></li> <li><p><strong>/etc/passwd文件</strong></p> <ul><li>Linux系统用于将用户登录名匹配到对应UID的文件，包含了一些用户信息</li> <li>Linux系统会为不同的功能创建不同的用户账户，这些账户并非真用户，而是<strong>系统账户</strong>，是系统上运行各种服务进程访问资源用的特殊账户</li> <li>为某种功能新开一个账户的好处是，当该功能被攻破之后，攻击者并不能立马得到root账户权限，不能访问整个系统</li> <li>Linux为系统账户预留了500以下的UID值</li> <li>此文件中包含如下字段信息
<ul><li>登录用户名</li> <li>用户密码（通常用 x 表示）</li> <li>用户账户UID</li> <li>用户账户组GID</li> <li>用户账户备注</li> <li>用户HOME位置</li> <li>用户默认shell</li></ul></li></ul></li> <li><p><strong>/etc/shadow文件</strong></p> <ul><li>对Linux系统密码提供了更多的控制，只有root用户才能访问该文件</li> <li>此文件中的字段信息
<ul><li>与/etc/passwd登录名对应的登录名</li> <li>加密后的密码</li> <li>自上次修改密码后过去的天数(1970.1.1开始)</li> <li>多少天后才能更改密码</li> <li>多少天后必须更改密码</li> <li>密码过期前提前多少天通知用户更更改密码</li> <li>密码过期后多少天禁用账户</li> <li>用户账户被禁用的日期(1970.1.1开始的天数)</li> <li>预留字段</li></ul></li></ul></li> <li><p><strong>添加用户</strong></p> <ul><li><p><code>useradd</code>命令用于添加用户，可以一次性创建用户及设置其HOME目录结构</p></li> <li><p>使用系统默认值和命令行参数来设置用户账户，默认值保存至<code>/etc/default/useradd</code>中，可使用加入<code>-D</code>选项的useradd查看这些默认值</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">useradd</span> <span class="token parameter variable">-D</span>
<span class="token comment"># 输出-----------</span>
<span class="token assign-left variable">GROUP</span><span class="token operator">=</span><span class="token number">100</span>
<span class="token assign-left variable"><span class="token environment constant">HOME</span></span><span class="token operator">=</span>/home
<span class="token assign-left variable">INACTIVE</span><span class="token operator">=</span>-1
<span class="token assign-left variable">EXPIRE</span><span class="token operator">=</span>
<span class="token assign-left variable"><span class="token environment constant">SHELL</span></span><span class="token operator">=</span>/bin/bash
<span class="token assign-left variable">SKEL</span><span class="token operator">=</span>/etc/skel
<span class="token assign-left variable">CREATE_MAIL_SPOOL</span><span class="token operator">=</span>yes
</code></pre></div></li> <li><p>在创建用户时，默认使用上述参数创建，上述默认值包含：</p> <ul><li>新用户将被添加到组100</li> <li>HOME目录设为/home</li> <li>账户密码在过期后不被禁用</li> <li>账户未被设置过期时间</li> <li>账户将bash作为默认shell</li> <li>系统将<code>/etc/skel</code>目录下的内容复制到HOME下（可实现默认HOME目录配置）</li> <li>系统为该用户在mail目录下创建一个用于接收邮件的文件</li></ul></li> <li><p>useradd可用命令行参数</p> <table><thead><tr><th>参数</th> <th>描述</th></tr></thead> <tbody><tr><td>-c comment</td> <td>添加备注</td></tr> <tr><td>-d home_dir</td> <td>为主目录指定一个名字（默认用登录名）</td></tr> <tr><td>-e expire_date</td> <td>用YYYY-MM-DD格式指定一个账户过期时间</td></tr> <tr><td>-f inactive_days</td> <td>指定账户密码过期后多少天被禁用，0表示立即，-1表示禁用此功能</td></tr> <tr><td>-g initial_group</td> <td>指定登录组GID或组名</td></tr> <tr><td>-G group ...</td> <td>指定除了登录组以外所属的多个附加组</td></tr> <tr><td>-k</td> <td>和-m一起使用，将/etc/skel目录内容复制到用户HOME目录</td></tr> <tr><td>-m</td> <td>创建用户HOME目录</td></tr> <tr><td>-M</td> <td>不创建用户HOME目录</td></tr> <tr><td>-n</td> <td>创建一个与用户登录名同名的新组</td></tr> <tr><td>-r</td> <td>创建系统账户</td></tr> <tr><td>-p passwd</td> <td>为用户指定默认密码</td></tr> <tr><td>-s shell</td> <td>指定登录shell</td></tr> <tr><td>-u uid</td> <td>指定唯一UID</td></tr></tbody></table></li> <li><p>需要修改默认值文件中的值时，可通过<code>-D</code>加上以下参数实现</p> <table><thead><tr><th>参数</th> <th>描述</th></tr></thead> <tbody><tr><td>-b default_home</td> <td>修改默认HOME目录位置</td></tr> <tr><td>-e expiration_date</td> <td>修改默认过期时间</td></tr> <tr><td>-f inactive</td> <td>修改默认过期后多少天被禁用</td></tr> <tr><td>-g group</td> <td>修改默认组名或GID</td></tr> <tr><td>-s shell</td> <td>修改默认登录shell</td></tr></tbody></table></li></ul></li> <li><p><strong>删除用户</strong></p> <ul><li><code>userdel</code>实现删除用户的功能。默认仅会删除/etc/passwd下的对应信息，不会删除任何文件</li> <li>加上<code>-r</code>参数会删除用户HOME目录及邮件目录</li></ul></li> <li><p><strong>修改账户</strong></p> <ul><li><p>用户账户修改工具包含</p> <table><thead><tr><th>命令</th> <th>描述</th></tr></thead> <tbody><tr><td>usermod</td> <td>修改用户账户字段，指定主要组和附加组关系</td></tr> <tr><td>passwd</td> <td>修改已有用户密码</td></tr> <tr><td>chpasswd</td> <td>从文件中读取登录名密码对，并更新密码</td></tr> <tr><td>chage</td> <td>修改密码过期时间</td></tr> <tr><td>chfn</td> <td>修改用户账户备注信息</td></tr> <tr><td>chsh</td> <td>修改用户账户默认登录shell</td></tr></tbody></table> <ol><li>usermod</li></ol> <ul><li>参数大多与useradd一样（-c、-e、-g等），此外还有另外的参数</li></ul> <table><thead><tr><th>参数</th> <th>描述</th></tr></thead> <tbody><tr><td>-l</td> <td>修改用户账户登录名</td></tr> <tr><td>-L</td> <td>锁定账户</td></tr> <tr><td>-p</td> <td>修改账户密码</td></tr> <tr><td>-U</td> <td>解除锁定</td></tr></tbody></table> <ol start="2"><li>passwd和chpasswd</li></ol> <ul><li>改变用户密码只需要使用passwd即可，默认修改本账户密码。加上用户名可修改其他账户密码（root才可）</li> <li><code>-e</code>选项可强制用户下次登录时修改密码</li> <li>若需要为大量用户修改密码，可使用chpasswd，其能从标准输入自动读取登录名和密码对，给密码加密并为相应账户设置</li></ul> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token comment"># 其中，users.txt包含了形如 userid:passwd 这样的冒号分隔键值对</span>
chpasswd <span class="token operator">&lt;</span> users.txt
</code></pre></div><ol start="3"><li>chsh、chfn和chage</li></ol> <ul><li>chsh -s 修改shell</li> <li>chfn可用于添加备注，其会将用于Unix finger 命令的信息存进备注字段</li> <li><code>finger</code>可方便查看Linux系统上的用户信息</li> <li>chage用于管理用户有效期，包含以下参数</li></ul> <table><thead><tr><th>参数</th> <th>描述</th></tr></thead> <tbody><tr><td>-d</td> <td>设置上次修改密码到现在的天数</td></tr> <tr><td>-E</td> <td>设置密码过期的日期</td></tr> <tr><td>-I</td> <td>设置密码过期到锁定账户的天数</td></tr> <tr><td>-m</td> <td>设置修改密码之间最少需要多少天</td></tr> <tr><td>-W</td> <td>设置木马过期前多久开始出现提醒信息</td></tr></tbody></table> <ul><li>chage可使用两种日期值
<ul><li>YYYY-MM-DD</li> <li>从1970.1.1开始的天数</li></ul></li></ul></li></ul></li></ul> <h3 id="使用linux组"><a href="#使用linux组" class="header-anchor">#</a> 使用Linux组</h3> <ul><li><p>用于提供除了单个用户安全性方面的控制，方便多个用户共享资源的情况，设置统一权限方便管理</p></li> <li><p><strong>/etc/group文件</strong></p> <ul><li>包含Linux系统上的组信息</li> <li>通常有4个字段
<ul><li>组名</li> <li>组密码</li> <li>GID</li> <li>属于改组的用户列表</li></ul></li> <li>==注意==：当用户在/etc/passwd中指定某个组为默认组时，用户账户不会作为该组成员再次出现在/etc/group最后一个字段中，但实际上确实是该组成员</li></ul></li> <li><p><strong>创建组</strong></p> <ul><li><code>groupadd</code>命令用于创建组，但不能用该命令将用户加入组中</li> <li><code>usermod</code>命令的<code>-G</code>选项可将某个组添加到用户账户组列表中</li> <li>==注意==：usermod的参数-g会替换原来的默认组信息，而-G可看作追加组信息</li></ul></li> <li><p><strong>修改组</strong></p> <ul><li><code>groupmod</code>命令用于修改组的GID(-g参数)或组名(-n参数)</li> <li>所有安全权限都是针对GID的，该组名不会影响</li></ul></li></ul> <h3 id="文件权限"><a href="#文件权限" class="header-anchor">#</a> 文件权限</h3> <ul><li><p><strong>文件权限符</strong></p> <ul><li><p>使用ls -l可看到文件开始的描述信息大概有如<code>-rwxrw-r-x</code>形式，可拆分为4本部分：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>-  rwx  rw- r-x
<span class="token comment"># 文件类型  对象属主权限  对象属组权限  其他用户权限</span>
</code></pre></div></li> <li><p>其中权限部分依次为读(r)、写(w)、执行(x)，对应位置若没权限使用 - 代替</p></li></ul></li> <li><p><strong>默认文件权限</strong></p> <ul><li><p><code>umask</code>命令用于设置所创建文件和目录的默认权限</p></li> <li><p>touch创建文件时会使用分配给用户的默认权限创建，umask可显示和设置该默认权限</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">umask</span>
<span class="token comment"># 输出</span>
0022
</code></pre></div></li> <li><p>其中</p> <ul><li>第一位代表重要安全特性，称作<strong>粘着位(sticky bit)</strong></li> <li>后三位表示对应umask的八进制值</li></ul> <blockquote><p>八进制文件权限值表示的含义：</p> <p>每位对应上述 属主、组、其他用户 的权限</p> <p>如 664 依次对应属主、组、其他用户的权限</p> <p>而其中，每个类型有 rwx 三个权限</p> <p>当对应位置有权限时就置为 1，否则为 0，如具有读写权限(rw-)</p> <p>可表示为： 110</p> <p>转化成八进制就是 6 ，因此该位置就用6表示</p> <p>如 664 表示属主和组拥有读写权限，其他用户只有读权限</p></blockquote></li> <li><p>而umask是掩码的方式设置权限，即是采用<strong>排除</strong>不想授予的权限的方式，对于文件，默认全权限为666，对目录为777(多了执行)。所以对于linux的默认022表示666-022-&gt;644权限</p></li> <li><p>使用umask xxx可为其指定新值</p></li></ul></li> <li><p>TODO：Linux还提供了访问控制表(ACL)的功能</p></li></ul> <h3 id="改变安全性设置"><a href="#改变安全性设置" class="header-anchor">#</a> 改变安全性设置</h3> <ul><li><p><strong>改变权限</strong></p> <ul><li><p><code>chmod</code>用于改变文件和目录的权限，格式为</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">chmod</span> options mode <span class="token function">file</span>
</code></pre></div></li> <li><p>mode可用八进制模式或符号模式进行安全性设置</p></li> <li><p>符号模式格式</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token punctuation">[</span>ugoa<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">[</span>+-<span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">[</span>rwxXstugo<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre></div></li> <li><p>上述第一组字符定义权限<strong>作用对象</strong></p> <table><thead><tr><th>字符</th> <th>作用</th></tr></thead> <tbody><tr><td>u</td> <td>表用户</td></tr> <tr><td>g</td> <td>表组</td></tr> <tr><td>o</td> <td>表其他</td></tr> <tr><td>a</td> <td>表所有</td></tr></tbody></table></li> <li><p>接下来的符号表示需要增加(+)、移除(-)还是设置成(=)某个权限</p></li> <li><p>最后表示作用到设置上的权限(除 rwx)</p> <table><thead><tr><th>字符</th> <th>表示权限</th></tr></thead> <tbody><tr><td>X</td> <td>若对象是目录或已有执行权，赋予执行权</td></tr> <tr><td>s</td> <td>运行时重新设置UID或GID</td></tr> <tr><td>t</td> <td>保留文件或目录</td></tr> <tr><td>u</td> <td>将权限设为和属主一样</td></tr> <tr><td>g</td> <td>..</td></tr> <tr><td>o</td> <td>..</td></tr></tbody></table></li> <li><p>参数options取<code>-R</code>时，可递归作用于子文件</p></li></ul></li> <li><p><strong>改变所属关系</strong></p> <ul><li><p><code>chown</code>用于改变文件属主，<code>chgrp</code>用于改变文件默认属组</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">chown</span> options owner<span class="token punctuation">[</span>.group<span class="token punctuation">]</span> <span class="token function">file</span>

<span class="token comment"># 示例</span>
<span class="token function">chown</span> new_user old_user
<span class="token comment"># 连带改动属组 </span>
<span class="token function">chown</span> new_user.new_group
<span class="token comment"># 单改变属组</span>
<span class="token function">chown</span> .new_group
</code></pre></div></li></ul></li> <li><p><strong>共享文件</strong></p> <ul><li><p>Linux上共享文件的方法是创建组</p></li> <li><p>Linux为每个文件和目录存储了3个额外信息位：</p> <table><thead><tr><th>信息位</th> <th>描述</th></tr></thead> <tbody><tr><td>设置用户ID(SUID)</td> <td>文件被用户使用时，程序会以文件属主的权限运行</td></tr> <tr><td>设置组ID(SGID)</td> <td>对文件，会以属组权限运行；对目录，新建的文件会以目录默认属组位默认属组</td></tr> <tr><td>粘着位</td> <td>进程结束后文件还驻留在内存中</td></tr></tbody></table></li> <li><p>SGID对文件共享十分重要，其会强制内部创建的文件都归属于改组</p></li> <li><p>SGID可通过chmod设置，会加到3位标准八进制之前，或在符号模式下使用符号 s</p></li> <li><p>和rwx类似，此三位有则置1，否则为0，最后形成一个八进制数。如4=100表示SUID置为1</p></li> <li><p>要创建共享文件只需要将SGID设置即可，使用符号模式即</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">chmod</span> g+s shared_dir
</code></pre></div></li> <li><p>此外还需要使用umask将文件设成对属组成员可写，通常改为002</p></li></ul></li></ul> <h2 id="管理文件系统"><a href="#管理文件系统" class="header-anchor">#</a> 管理文件系统</h2> <h3 id="linux文件系统"><a href="#linux文件系统" class="header-anchor">#</a> Linux文件系统</h3> <ul><li><p><strong>基本的Linux文件系统</strong></p> <ol><li>ext文件系统
<ul><li>最早引入的一个基本的类Unix文件系统，称为扩展文件系统(extended filesystem)</li> <li>使用虚拟目录操作设备，在物理设备上按定长的块存储数据</li> <li>采用名为<strong>索引节点</strong>的系统来存放虚拟目录中所存储文件的信息，索引节点系统在每个物理设备中创建一个单独的表来存储这些文件信息</li> <li>ext中的extended部分来自其跟踪的每个文件的额外数据，包括
<ul><li>文件名</li> <li>文件大小</li> <li>文件属主</li> <li>文件属组</li> <li>文件访问权限</li> <li>指向存有文件数据的每个硬盘块的指针</li></ul></li> <li>Linux通过唯一的数值（索引节点号）来引用索引节点表中的每个索引节点</li></ul></li> <li>ext2文件系统
<ul><li>ext文件系统有很多限制，如最大文件不能超过2GB</li> <li>ext2扩展了索引节点表的格式用于保存更多文件信息</li> <li>允许的最大文件增加到2TB</li> <li>改变了数据在数据块中的存储方式，通过按组分配磁盘来减轻碎片化</li> <li>容易在系统崩溃或断电时损坏</li></ul></li></ol></li> <li><p><strong>日志文件系统</strong></p> <ul><li><p>日志文件系统为Linux增加了一层安全性。不再采用将数据直接写入存储设备再更新索引节点表的方法 ，而先将文件的更改写入到临时文件(日志)中，在数据成功写入存储设备和索引节点后再删除对应日志条目</p></li> <li><p>广泛使用的文件系统日志方法</p> <table><thead><tr><th>日志方法</th> <th>描述</th></tr></thead> <tbody><tr><td>数据模式</td> <td>索引节点和文件都会被写入日志，丢失数据风险低，单性能差</td></tr> <tr><td>有序模式</td> <td>只有索引节点会被写入日志，只有数据成功写入后才能删除，高性能和安全性折中</td></tr> <tr><td>回写模式</td> <td>只有索引节点数据被写入日志，但不可控制文件数据何事写入，丢失风险高</td></tr></tbody></table></li></ul> <ol><li>ext3文件系统
<ul><li>使用和ext2相同的索引节点表结构，为每个存储设备增加一个日志文件，将准备写入设备数据先计入日志</li> <li>无法恢复删除的文件，没有任何内建的数据压缩功能，也不支持加密</li></ul></li> <li>ext4文件系统
<ul><li>支持数据压缩和加密，还支持<strong>区段</strong>特定：在存储设备上分配空间，但在索引节点表中只保存起始块位置</li> <li>还引入<strong>块预分配技术</strong>，如可以给知道会表达的文件预留空间，ext4会使用0填充而不会分配给其他文件</li></ul></li> <li>Reiser文件系统
<ul><li>只支持回写日志模式，所以很快</li></ul></li> <li>JFS文件系统
<ul><li>采用有序日志方法</li></ul></li> <li>XFS文件系统
<ul><li>采用回写模式的日志，提供高性能的同时也引入一定风险</li></ul></li></ol></li> <li><p><strong>写时复制文件系统</strong></p> <ul><li>日志式的另一种选择是<strong>写时复制(Copy On Write,COW)</strong>，其利用快照兼顾安全性和性能</li></ul> <ol><li>ZFS文件系统
<ul><li>稳定。最大弱点是没有使用GPL许可证</li></ul></li> <li>Btrf文件系统
<ul><li>是COW新人，也叫B树文件系统</li></ul></li></ol></li></ul> <h3 id="操作文件系统"><a href="#操作文件系统" class="header-anchor">#</a> 操作文件系统</h3> <ul><li><p><strong>创建分区</strong></p> <ul><li><p><code>fdisk</code>工具用来帮助管理安装在系统上的任何存储设备分区，使用时需要有超级用户权限并指定设备名</p></li> <li><p>fdisk交互式提示符使用单字母下达命令，有以下命令</p> <table><thead><tr><th>命令</th> <th>描述</th></tr></thead> <tbody><tr><td>a</td> <td>设置活动分区标志</td></tr> <tr><td>b</td> <td>编辑BSD Unix系统用的磁盘标签</td></tr> <tr><td>c</td> <td>设置DOS兼容标志</td></tr> <tr><td>d</td> <td>删除分区</td></tr> <tr><td>l</td> <td>显示可用分区类型</td></tr> <tr><td>m</td> <td>显示命令选项</td></tr> <tr><td>n</td> <td>添加一个新分区</td></tr> <tr><td>o</td> <td>创建DOS分区表</td></tr> <tr><td>p</td> <td>显示当前分区表</td></tr> <tr><td>q</td> <td>退出不保存更改</td></tr> <tr><td>s</td> <td>为Sun Unix系统创建一个新磁盘标签</td></tr> <tr><td>t</td> <td>修改分区的系统ID</td></tr> <tr><td>u</td> <td>改变使用的存储单位</td></tr> <tr><td>v</td> <td>验证分区表</td></tr> <tr><td>w</td> <td>将分区表写入磁盘</td></tr> <tr><td>x</td> <td>高级功能</td></tr></tbody></table></li> <li><p>分区创建分为两种类型：主分区(primary partition)和扩展分区(extended partition)</p> <ul><li>主分区可直接被文件系统格式化，而扩展分区用于容纳其他逻辑分区</li> <li>一个设备上只能创建4个分区，因此需要扩展分区来实现创建多个分区(逻辑)</li></ul></li> <li><p>使用p查看分区信息，其中ID列指明了分区类型，此类型可通过l命令查看</p></li></ul></li> <li><p><strong>创建文件系统</strong></p> <ul><li><p>将数据存储到某种分区前必须使用某种文件系统将其格式化后才能使用</p></li> <li><p>创建文件系统的命令</p> <table><thead><tr><th>命令</th> <th>创建文件系统类型</th></tr></thead> <tbody><tr><td>mkefs</td> <td>ext</td></tr> <tr><td>mke2fs</td> <td>ext2</td></tr> <tr><td>mkfs.ext3</td> <td>ext3</td></tr> <tr><td>mkfs.ext4</td> <td>ext4</td></tr> <tr><td>mkreiserfs</td> <td>ReiserFS</td></tr> <tr><td>jfs_mkfs</td> <td>JFS</td></tr> <tr><td>mkfs.xfs</td> <td>XFS</td></tr> <tr><td>mkfs.zfs</td> <td>ZFS</td></tr> <tr><td>mkfs.btrfs</td> <td>Btrfs</td></tr></tbody></table></li> <li><p>文件系统创建后需要将其挂载到虚拟目录下的某个挂载点，使用 mount 命令。如需要Linux启动时自动挂载，需要将其写入<code>/etc/fstab</code>中</p></li></ul></li> <li><p><strong>文件系统检查和修复</strong></p> <ul><li><p><code>fsck</code>命令能够检查和修复大部分类型的Linux文件系统，命令格式为</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">fsck</span> options filesystem
</code></pre></div></li> <li><p>常用参数</p> <table><thead><tr><th>参数</th> <th>描述</th></tr></thead> <tbody><tr><td>-a</td> <td>若检测到错误自动修复文件系统</td></tr> <tr><td>-A</td> <td>检查/etc/fstab文件中列出的所有文件系统</td></tr> <tr><td>-C</td> <td>给支持进度条功能的文件系统显示进度条(ext2和ext3)</td></tr> <tr><td>-N</td> <td>不进行检查，只显示哪些检查会执行</td></tr> <tr><td>-r</td> <td>出现错误时提示</td></tr> <tr><td>-R</td> <td>使用-A时跳过根文件系统</td></tr> <tr><td>-s</td> <td>检查多个文件系统时依次进行</td></tr> <tr><td>-t</td> <td>指定要检查的文件系统类型</td></tr> <tr><td>-T</td> <td>启动时不显示头部信息</td></tr> <tr><td>-V</td> <td>检查时产生详细输出</td></tr> <tr><td>-y</td> <td>检测到错时自动修复</td></tr></tbody></table></li></ul></li></ul> <h3 id="逻辑卷管理"><a href="#逻辑卷管理" class="header-anchor">#</a> 逻辑卷管理</h3> <ul><li><p>逻辑卷管理器(logical volume manager,LVM)可在无须重建整个文件系统情况下轻松地管理磁盘。可将另一个磁盘上的分区加入已有文件系统</p></li> <li><p><strong>逻辑卷管理布局</strong></p> <ul><li>几个名词
<ul><li>物理卷(physical volume,PV)：即硬盘，每个物理卷映射到硬盘上的特定物理分区</li> <li>卷组(volume group,VG)：多个物理卷集中在一起形成。逻辑管理将卷组视为一个物理硬盘</li> <li>逻辑卷(logical volume,LV)：逻辑卷为创建文件系统提供分区环境，作用类似物理硬盘分区</li></ul></li></ul></li> <li><p><strong>Linux中的LVM</strong></p> <ul><li>除了标准逻辑卷管理，还提供了：
<ol><li>快照
<ul><li>允许在逻辑卷在线的状态下将其复制到另一个设备而不用锁定文件</li> <li>允许复制的同时保证关键人物继续工作</li> <li>对于可读写快照，可删除原先的逻辑卷并用快照替换，此功能对快速故障转移或涉及修改数据的程序实验很有用</li></ul></li> <li>条带化
<ul><li>条带化允许横跨多个物理硬盘创建逻辑卷</li> <li>有助于提高硬盘性能，即将一个文件同时写入多个硬盘</li></ul></li> <li>镜像
<ul><li>镜像即实时更新的逻辑卷完整副本</li> <li>可能会降低系统的写入性能，因为每次都需要写入到两个位置</li></ul></li></ol></li></ul></li> <li><p><strong>使用LVM</strong></p> <ol><li><p>定义物理卷</p> <ul><li>先要将物理分区转换为LVM的物理卷段区，使用<code>fdisk</code>命令的<code>t</code>命令修改分区类型为8e（Linux LVM）</li> <li>用分区创建实际物理卷，使用<code>pvcreate</code>命令：<code>pvcreate /dev/sdb1</code></li> <li>注意，上述命令不能正常工作可能是因为没有正确安装LVM2软件包</li> <li>可通过<code>pvdisplay</code>查看创建的物理卷列表</li></ul></li> <li><p>创建卷组</p> <ul><li><p>使用<code>vgcreate</code>创建卷组，使用<code>vgdisplay</code>可查看卷组细节</p> <div class="language-bash extra-class"><pre class="language-bash"><code>vgcreate Voll /dev/sdb1 <span class="token comment">#创建名为 Voll的卷组</span>
</code></pre></div></li></ul></li> <li><p>创建逻辑卷</p> <ul><li><p>逻辑卷用于模拟物理分区，并在其中保存文件系统</p></li> <li><p><code>lvcreate</code>用于创建逻辑卷，使用<code>lvdisplay</code>查看逻辑卷情况</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token comment"># 从卷组创建一个名为lvtest的逻辑卷，-l指定为逻辑卷指定多少可用空间（卷组的空间百分比）</span>
<span class="token comment"># 也可使用-L用大小单位指定大小，如KB、MB等</span>
lvcreate <span class="token parameter variable">-l</span> <span class="token number">100</span>%FREE <span class="token parameter variable">-n</span> lvtest Voll
</code></pre></div></li></ul></li> <li><p>创建文件系统</p> <ul><li>使用相应的如mkfs.ext4命令创建文件系统</li> <li>使用mount挂载到虚拟目录</li></ul></li> <li><p>修改LVM</p> <ul><li><p>LVM好处在于能够动态修改文件系统</p></li> <li><p>其他LVM常见命令</p> <table><thead><tr><th>命令</th> <th>作用</th></tr></thead> <tbody><tr><td>vgchange</td> <td>激活和禁用卷组</td></tr> <tr><td>vgremove</td> <td>删除卷组</td></tr> <tr><td>vgextend</td> <td>将物理卷加到卷组中</td></tr> <tr><td>vgreduce</td> <td>从卷组删除物理卷</td></tr> <tr><td>lvextend</td> <td>增加逻辑卷大小</td></tr> <tr><td>lvreduce</td> <td>减小逻辑卷大小</td></tr></tbody></table></li></ul></li></ol></li></ul> <h2 id="安装软件程序"><a href="#安装软件程序" class="header-anchor">#</a> 安装软件程序</h2> <h3 id="包管理基础"><a href="#包管理基础" class="header-anchor">#</a> 包管理基础</h3> <ul><li>包管理系统(package management system,PMS)利用一个数据库记录各种相关内容：
<ul><li>Linux系统已经安装什么软件</li> <li>每个包安装了什么文件</li> <li>每个已安装软件包得版本</li></ul></li> <li>两种主要的PMS基础工具：dpkg和rpm</li></ul> <h3 id="基于debian的系统"><a href="#基于debian的系统" class="header-anchor">#</a> 基于Debian的系统</h3> <ul><li><p>dpkg是基于Debian系PMS工具的核心，包含于其中的其他工具有</p> <ul><li>apt-get</li> <li>apt-cache</li> <li>aptitude</li></ul></li> <li><p><strong>aptitude管理软件包</strong></p> <ul><li><p>直接输入aptitude命令可进入aptitude的全屏模式，可通移动菜单选项完成相关操作</p></li> <li><p><code>aptitude show package_name</code>可快速显示某个特定包信息</p></li> <li><p>无法通过aptitude看到跟某个特定软件包相关的所有文件列表，但可使用<code>dpkg</code>命令实现</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token comment"># 列出package_name安装的所有文件</span>
dpkg <span class="token parameter variable">-L</span> package_name
</code></pre></div></li> <li><p>也可以反过来查找某个文件属于哪个软件包</p> <div class="language-bash extra-class"><pre class="language-bash"><code>dpkg <span class="token parameter variable">--search</span> absolute_file_name
</code></pre></div></li></ul></li> <li><p><strong>aptitude安装软件包</strong></p> <ul><li><p>通过<code>aptitude search package_name</code>可查找到特定的软件包。搜索列表最前有一个标识符，若是<code>p</code>或<code>v</code>表示包可用但未安装，若是<code>i</code>则表示已安装</p></li> <li><p>安装命令</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">aptitude</span> <span class="token function">install</span> package_name
</code></pre></div></li></ul></li> <li><p><strong>aptitude更新软件</strong></p> <ul><li><p>软件包依赖的更新可能比较繁琐，通常为保证更新后依赖和兼容问题，需要使用以下命令安全更新</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">aptitude</span> safe-upgrade
</code></pre></div></li> <li><p>此外，还有两个命令不会考虑依赖进行全部更新</p> <ul><li>aptitude full-upgrade</li> <li>aptitude dist-upgrade</li></ul></li></ul></li> <li><p><strong>aptitude卸载软件</strong></p> <ul><li>对于卸载软件，需要考虑保不保留数据和配置文件
<ul><li>保留：<code>aptitude remove xxx</code></li> <li>不保留：<code>aptitude purge xxx</code></li></ul></li> <li>删除后使用<code>aptitude search</code>查看该软件包，若标志为c表示已经移出但配置文件还在，为p表示已经移出且删除配置文件</li></ul></li> <li><p><strong>aptitude仓库</strong></p> <ul><li>存储在<code>/etc/apt/sources.list</code>中</li> <li>如在国内需要加速访问包可以修改为国内的阿里云源、中科大源等</li></ul></li></ul> <h3 id="基于red-hat的系统"><a href="#基于red-hat的系统" class="header-anchor">#</a> 基于Red Hat的系统</h3> <ul><li><p>几种常用前端工具（基于rpm）</p> <ul><li>yum：Red Hat和Fedora中使用</li> <li>urpm：Mandriva中使用</li> <li>zypper：openSUSE中使用</li></ul></li> <li><p><strong>列出已安装</strong></p> <ul><li><p>列出已安装的包可使用：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>yum list installed
</code></pre></div></li> <li><p>查看是否安装</p> <div class="language-bash extra-class"><pre class="language-bash"><code>yum list installed xxx
</code></pre></div></li> <li><p>找出系统上某个特定文件属于哪个软件包</p> <div class="language-bash extra-class"><pre class="language-bash"><code>yum privides file_name
</code></pre></div></li></ul></li> <li><p><strong>yum安装软件</strong></p> <ul><li><p>从软件仓库安装</p> <div class="language-bash extra-class"><pre class="language-bash"><code>yum <span class="token function">install</span> xxx
</code></pre></div></li> <li><p>手动下载的rpm包安装</p> <div class="language-bash extra-class"><pre class="language-bash"><code>yum localinstall xxx.rpm
</code></pre></div></li></ul></li> <li><p><strong>yum更新软件</strong></p> <ul><li><p>列出所有已安装的可用更新</p> <div class="language-bash extra-class"><pre class="language-bash"><code>yum list updates
</code></pre></div></li> <li><p>更新某个软件包</p> <div class="language-bash extra-class"><pre class="language-bash"><code>yum update xxxx
</code></pre></div></li> <li><p>更新所有包</p> <div class="language-bash extra-class"><pre class="language-bash"><code>yum update
</code></pre></div></li></ul></li> <li><p><strong>yum卸载软件</strong></p> <ul><li><p>同样考虑是否需要保存用户数据和配置文件</p> <ul><li><p>保留</p> <div class="language-bash extra-class"><pre class="language-bash"><code>yum remove xxx
</code></pre></div></li> <li><p>不保留</p> <div class="language-bash extra-class"><pre class="language-bash"><code>yum erase xxx
</code></pre></div></li></ul></li></ul></li> <li><p><strong>处理损坏的包依赖关系</strong></p> <ul><li><p>安装时某个包的依赖可能被另一个包覆盖，即损坏了依赖关系</p></li> <li><p>若系统出现问题，可先尝试清理放错位置的文件即可：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>yum clean all
yum update
</code></pre></div></li> <li><p>若无效，则尝试显示所有包的依赖关系以及什么软件可以提供这些库依赖关系</p> <div class="language-bash extra-class"><pre class="language-bash"><code>yum deplist package_name
</code></pre></div></li> <li><p>最后，可尝试忽略损坏的包更新其他软件包</p> <div class="language-bash extra-class"><pre class="language-bash"><code>yum update --skip-broken
</code></pre></div></li></ul></li> <li><p><strong>yum软件仓库</strong></p> <ul><li><p>列出正在从哪些软件仓库获取软件</p> <div class="language-bash extra-class"><pre class="language-bash"><code>yum repolist
</code></pre></div></li> <li><p>yum的仓库定义文件位于<code>/etc/yum.repos.d</code></p></li></ul></li></ul> <h3 id="从源码安装"><a href="#从源码安装" class="header-anchor">#</a> 从源码安装</h3> <ul><li>对于下载的<code>.tar.gz</code>等源码包，安装过程大致如下：
<ol><li>用tar解压缩</li> <li>转到解压缩后的文件夹</li> <li>按README文件安装</li> <li>make命令构建二进制文件</li> <li>make install 安装</li></ol></li></ul> <h2 id="使用编辑器"><a href="#使用编辑器" class="header-anchor">#</a> 使用编辑器</h2> <h4 id="vim编辑器"><a href="#vim编辑器" class="header-anchor">#</a> vim编辑器</h4> <ul><li><p>一些快捷键、命令（非插入模式下）</p> <table><thead><tr><th>指令</th> <th>作用</th></tr></thead> <tbody><tr><td>h</td> <td>左移一个字符</td></tr> <tr><td>j</td> <td>上移一行</td></tr> <tr><td>k</td> <td>下移一行</td></tr> <tr><td>l</td> <td>右移一个字符</td></tr> <tr><td>G</td> <td>跳到最后一行</td></tr> <tr><td>num G</td> <td>跳到第 num 行</td></tr> <tr><td>gg</td> <td>跳到第一行</td></tr> <tr><td>q</td> <td>未修改则退出</td></tr> <tr><td>q!</td> <td>取消修改并退出</td></tr> <tr><td>w filename</td> <td>另存为其他文件</td></tr> <tr><td>wq</td> <td>保存并退出</td></tr></tbody></table></li> <li><p>编辑相关命令</p> <table><thead><tr><th>命令</th> <th>作用</th></tr></thead> <tbody><tr><td>x</td> <td>删除当前光标所在字符</td></tr> <tr><td>dd</td> <td>删除当前光标所在行</td></tr> <tr><td>dw</td> <td>删除当前光标所在位置的单词</td></tr> <tr><td>d$</td> <td>删除当前光标所在位置至行尾内容</td></tr> <tr><td>J</td> <td>删除当前光标所在行行尾的换行符</td></tr> <tr><td>u</td> <td>撤销前一个编辑命令</td></tr> <tr><td>a</td> <td>在当前光标后追加数据</td></tr> <tr><td>A</td> <td>在当前光标所在行行尾追加</td></tr> <tr><td>r char</td> <td>用char替换当前光标所在位置的单个字符</td></tr> <tr><td>R text</td> <td>用text覆盖当前光标所在位置的数据，直到按下esc</td></tr></tbody></table> <ul><li>某些命令允许使用数字修饰符指定重复该命令多少次，如2x删除2个字符，5dd删除5行</li></ul></li> <li><p>复制和粘贴</p> <ul><li>剪切和粘贴
<ul><li>vim在使用删除数据时，实际上会将数据放在单独的地方存起来，可使用<code>p</code>命令取回</li> <li>如使用dd删除一行后，在需要的位置使用 p 命令可将改内容剪切过了来</li></ul></li> <li>复制
<ul><li>vim中复制是<code>y</code>命令(yank)，y和d命令后缀相似，如yw表示复制一个单词，y$表示复制到行尾</li> <li>复制之后同样使用 p 命令可粘贴</li> <li>使用可视命令<code>v</code>可帮助选取文本</li></ul></li></ul></li> <li><p>查找和替换</p> <ul><li><p>输入<code>/</code>可调出查询功能。需要查询下一个则使用参数 n</p></li> <li><p>替换</p> <ul><li><p>需要进入命令模式，即冒号：开头的命令模式</p></li> <li><p>命令格式</p> <div class="language-bash extra-class"><pre class="language-bash"><code>:s/old/new/
</code></pre></div></li> <li><p>其他常用替换</p> <table><thead><tr><th>命令</th> <th>作用</th></tr></thead> <tbody><tr><td>😒/old/new/g</td> <td>替换所有old</td></tr> <tr><td>:n,ms/old/new/g</td> <td>替换行号n和m之间的所有old</td></tr> <tr><td>:%s/old/new/g</td> <td>替换整个文件中的所有old</td></tr> <tr><td>:%s/old/new/gc</td> <td>替换整个文件中的所有old，但在每次出现时提示</td></tr></tbody></table></li></ul></li></ul></li></ul> <h2 id="shell脚本编程基础"><a href="#shell脚本编程基础" class="header-anchor">#</a> shell脚本编程基础</h2> <h3 id="创建shell脚本"><a href="#创建shell脚本" class="header-anchor">#</a> 创建shell脚本</h3> <ul><li><p>创建shell脚本时，须在文件第一行指定要使用的shell，格式为：</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token shebang important">#!/bin/bash</span>
</code></pre></div></li> <li><p>其中#为注释，但在第一行中比较特殊，!号后边跟脚本使用的shell程序</p></li> <li><p>执行脚本时若未在PATH中注册，则需要指定路径名才能执行，并且需要用chmod修改权限（默认umask为022，不可执行）</p></li></ul> <h3 id="显示消息"><a href="#显示消息" class="header-anchor">#</a> 显示消息</h3> <ul><li><code>echo</code>命令用于输，加选项<code>-n</code>可不换行</li></ul> <h3 id="使用变量"><a href="#使用变量" class="header-anchor">#</a> 使用变量</h3> <ul><li><p>使用<code>$变量名</code>方式使用变量</p></li> <li><p>通过<code>var=x</code>的形式直接声明变量</p></li> <li><p>要给某个变量赋值时等号左侧不使用<code>$</code></p></li> <li><p><strong>命令替换</strong></p> <ul><li><p>shell支持从命令输出中提取信息赋值给变量，有两种方式：</p> <ul><li><p>反引号字符(`)</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># 将date命令的输出赋值给test</span>
<span class="token assign-left variable">test</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">date</span><span class="token variable">`</span></span>
</code></pre></div></li> <li><p>$()格式</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token assign-left variable">test</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">date</span><span class="token variable">)</span></span>
</code></pre></div></li></ul></li> <li><p>注意：命令替换会创建一个子shell运行</p></li></ul></li></ul> <h3 id="重定向输入和输出"><a href="#重定向输入和输出" class="header-anchor">#</a> 重定向输入和输出</h3> <ul><li><p><strong>输出重定向</strong></p> <ul><li><p>将命令输出结果写入文件</p></li> <li><p>使用大于号(&gt;)完成输出重定向，其会覆盖已有文件</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token builtin class-name">command</span> <span class="token operator">&gt;</span> outputfile
</code></pre></div></li> <li><p>使用双大于号(&gt;&gt;)向文件中追加数据，不会覆盖原有文件</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token builtin class-name">command</span> <span class="token operator">&gt;&gt;</span> filetoappend
</code></pre></div></li></ul></li> <li><p><strong>输入重定向</strong></p> <ul><li><p>将文件内容重定向到命令</p></li> <li><p>使用小于号(&lt;)完成</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token builtin class-name">command</span> <span class="token operator">&lt;</span> inputfile
</code></pre></div></li> <li><p>如使用<code>wc</code>命令统计某个文件中的行数、词数、字节数：</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">wc</span> <span class="token operator">&lt;</span> myfile
</code></pre></div></li> <li><p>内联输入重定向，使用(&lt;&lt;)完成。其从命令行读取重定向的数据</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># 使用内联输入重定向时，需要在 &lt;&lt; 右边指定一个结束标志</span>
<span class="token comment"># 当再次输入该标志时表示输入结束</span>
<span class="token function">wc</span> <span class="token operator">&lt;&lt;</span> EOF
<span class="token operator">&gt;</span> test1
<span class="token operator">&gt;</span> test2
<span class="token operator">&gt;</span> EOF <span class="token comment">#输入到此结束</span>
</code></pre></div></li></ul></li></ul> <h3 id="管道"><a href="#管道" class="header-anchor">#</a> 管道</h3> <ul><li><p>管道是进程间通信的一种方式，可用于将一个命令的输出重定向为另一个命令的输入</p></li> <li><p>格式</p> <div class="language-sh extra-class"><pre class="language-sh"><code>command1 <span class="token operator">|</span> command2
</code></pre></div></li> <li><p>一条命令中可以使用多个管道连接多个命令</p></li> <li><p>ls -l 命令的输出可能特别长，因此可以将其输出重定向到 more 命令分页显示：</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">ls</span> <span class="token parameter variable">-l</span> <span class="token operator">|</span> <span class="token function">more</span>
</code></pre></div></li></ul> <h3 id="数学运算"><a href="#数学运算" class="header-anchor">#</a> 数学运算</h3> <ul><li><p><strong>expr命令</strong></p> <ul><li><p>此命令允许在命令行上处理数学表达式</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">expr</span> <span class="token number">1</span> + <span class="token number">5</span>
</code></pre></div></li> <li><p>支持多数常用运算，如+、-、*、/、&gt;=、&gt;.....</p></li> <li><p>还支持部分字符串操作</p> <table><thead><tr><th>操作</th> <th>作用</th></tr></thead> <tbody><tr><td>STRING : REGEXP</td> <td>若REGEXP匹配到STRING中的某个模式，返回该模式匹配</td></tr> <tr><td>match STRING REGEXP</td> <td>若REGEXP匹配到STRING中的某个模式，返回1否则0</td></tr> <tr><td>substr STRING POS LENGTH</td> <td>返回起始为POS（1开始），长度为LENGTH的子串</td></tr> <tr><td>index STRING CHARS</td> <td>返回CHARS在STRING中的位置，找不到为 0</td></tr> <tr><td>length STRING</td> <td>STRING长度</td></tr> <tr><td>+ TOKEN</td> <td>将TOKEN解释为字符串，即使是关键字</td></tr> <tr><td>(EXPRESSION)</td> <td>返回表达式值</td></tr></tbody></table></li> <li><p>==注意==：使用 * 等符号时含义可能有冲突，因此一般会加上转义符 <code>\*</code></p></li></ul></li> <li><p><strong>使用方括号</strong></p> <ul><li><p>bash中，将一个数学运算结果赋值给某个变量时可使用美元符号和方括号将表达式包裹</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token assign-left variable">var1</span><span class="token operator">=</span>$<span class="token punctuation">[</span><span class="token number">1</span> + <span class="token number">5</span><span class="token punctuation">]</span>
</code></pre></div></li> <li><p>方括号内不用担心乘号 * 会被解释成其他含义，因此不用转义</p></li> <li><p>==注意==：bash shell脚本中只支持整数运算</p></li></ul></li> <li><p><strong>浮点解决方案</strong></p> <ul><li><p>使用内建的bash计算器（bc）可克服数学运算的整数限制</p></li> <li><p>bc基本用法</p> <ul><li>bash计算器能识别类型
<ul><li>数字（整数和浮点数）</li> <li>变量（简单变量和数组）</li> <li>注释（# 或/**/格式）</li> <li>表达式</li> <li>编程语句</li> <li>函数</li></ul></li> <li>在shell命令行使用<code>bc</code>命令可使用计算器，使用<code>quit</code>退出</li></ul> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token variable">$bc</span>
<span class="token punctuation">..</span><span class="token punctuation">..</span>.
<span class="token number">12</span> * <span class="token number">5</span>
<span class="token number">60</span>
quit
$
</code></pre></div><ul><li>浮点运算由内建变量<code>scale</code>控制，必须设置该值为希望保留的小数位数才能得到预期结果</li></ul> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token variable">$bc</span> <span class="token parameter variable">-q</span>
<span class="token number">3.12</span> / <span class="token number">3</span>
<span class="token number">1</span>
<span class="token assign-left variable">scale</span><span class="token operator">=</span><span class="token number">4</span>
<span class="token number">3.12</span>/3
<span class="token number">1.0400</span>
quit
$
</code></pre></div><ul><li>bc还支持变量，定义方法和shell变量一样。可使用<code>print</code>命令进行打印输出</li></ul> <div class="language-sh extra-class"><pre class="language-sh"><code>$ <span class="token function">bc</span> <span class="token parameter variable">-q</span>
<span class="token assign-left variable">var</span><span class="token operator">=</span><span class="token number">5</span>
print var
<span class="token number">5</span>
var * <span class="token number">8</span>
<span class="token number">40</span>
quit
$
</code></pre></div></li> <li><p>在脚本中使用bc</p> <ul><li><p>使用命令替换运行bc命令，将其输出赋值给一个变量，基本格式为</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token assign-left variable">var</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">echo</span> <span class="token string">&quot;options;expression&quot;</span> <span class="token operator">|</span> <span class="token function">bc</span><span class="token variable">)</span></span>
</code></pre></div></li> <li><p>第一部分options用于设置变量，不止一个可用逗号分隔；expression定义bc执行的数学表达式</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token assign-left variable">var1</span><span class="token operator">=</span><span class="token number">100</span>
<span class="token assign-left variable">var2</span><span class="token operator">=</span><span class="token number">45</span>
<span class="token assign-left variable">var3</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">echo</span> <span class="token string">&quot;scale=4;<span class="token variable">$var1</span> / <span class="token variable">$var2</span>&quot;</span> <span class="token operator">|</span> <span class="token function">bc</span><span class="token variable">)</span></span>
</code></pre></div></li> <li><p>对于长表达式，还可以使用输入重定向方式进行</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token assign-left variable">var</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">bc</span> <span class="token operator">&lt;&lt;</span> <span class="token string">eof
options
statements
expressions
eof</span>
<span class="token variable">)</span></span>

<span class="token comment"># 示例</span>
var <span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">bc</span> <span class="token operator">&lt;&lt;</span> <span class="token string">eof
scale=4
a=(<span class="token variable">$v1</span> * <span class="token variable">$v2</span>)
b=(<span class="token variable">$v1</span> + <span class="token variable">$v2</span>)
a + b
eof</span>
<span class="token variable">)</span></span>
</code></pre></div></li></ul></li></ul></li></ul> <h3 id="退出脚本"><a href="#退出脚本" class="header-anchor">#</a> 退出脚本</h3> <ul><li><p>每个命令都使用一个退出状态码告诉shell已执行完毕.退出状态码为 0 - 255的值</p></li> <li><p><strong>查看退出状态码</strong></p> <ul><li><p>linux使用<code>$?</code>来显示<strong>上一个命令的退出状态码</strong></p></li> <li><p>成功结束的退出状态码为 0 ，否则是一个正整数</p></li> <li><p>一些状态码参考：</p> <table><thead><tr><th>状态码</th> <th>描述</th></tr></thead> <tbody><tr><td>0</td> <td>命令成功结束</td></tr> <tr><td>1</td> <td>一般性未知错误</td></tr> <tr><td>2</td> <td>不适合的shell命令</td></tr> <tr><td>126</td> <td>命令不可执行</td></tr> <tr><td>127</td> <td>未找到命令</td></tr> <tr><td>128</td> <td>无效的退出参数</td></tr> <tr><td>128+x</td> <td>与Linux信号x相关的严重错误</td></tr> <tr><td>130</td> <td>通过Ctrl+C终止的命令</td></tr> <tr><td>255</td> <td>正常范围之外的状态码</td></tr></tbody></table></li></ul></li> <li><p><strong>exit命令</strong></p> <ul><li><p>允许在脚本退出时指定状态码</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token builtin class-name">exit</span> <span class="token number">5</span>
</code></pre></div></li></ul></li></ul> <h2 id="结构化命令"><a href="#结构化命令" class="header-anchor">#</a> 结构化命令</h2> <h3 id="if-then语句"><a href="#if-then语句" class="header-anchor">#</a> if-then语句</h3> <ul><li><p>基本格式</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token keyword">if</span> <span class="token builtin class-name">command</span>
<span class="token keyword">then</span>
	commands
<span class="token keyword">fi</span>
</code></pre></div></li> <li><p>不同于其他编程语言，<strong>bash中if后会运行一个命令，若其成功执行(退出状态码为 0)则执行then部分的命令</strong>，否则then不被执行</p></li> <li><p>then部分可以放多条命令</p></li></ul> <h3 id="if-then-else语句"><a href="#if-then-else语句" class="header-anchor">#</a> if-then-else语句</h3> <ul><li><p>基本格式</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token keyword">if</span> <span class="token builtin class-name">command</span>
<span class="token keyword">then</span>
   commands
<span class="token keyword">else</span>
   commands
<span class="token keyword">fi</span>
</code></pre></div></li> <li><p>elif语句</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token keyword">if</span> command1
<span class="token keyword">then</span>
   commands
<span class="token keyword">elif</span> command2
<span class="token keyword">then</span> 
    commands
<span class="token keyword">fi</span>
</code></pre></div></li></ul> <h3 id="test命令"><a href="#test命令" class="header-anchor">#</a> test命令</h3> <ul><li><p>基本格式</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token builtin class-name">test</span> condition
</code></pre></div></li> <li><p>if语句不能测试命令退出状态码之外的条件，但可以使用其他命令辅助。test提供了在if中测试不同条件的途径</p></li> <li><p>condition是test要测试的一系列参数和值，结合if：</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token keyword">if</span> <span class="token builtin class-name">test</span> condition
<span class="token keyword">then</span>
   commands
<span class="token keyword">fi</span>
</code></pre></div></li> <li><p>如测试某个变量中是否有内容</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token keyword">if</span> <span class="token builtin class-name">test</span> <span class="token variable">$my_var</span>
then<span class="token punctuation">..</span><span class="token punctuation">..</span>
<span class="token keyword">fi</span>
</code></pre></div></li> <li><p>bash shell提供了另一种无须在if中声明test命令的方法：使用方括号</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># 方括号和命令之间需要空格</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> condition <span class="token punctuation">]</span>
<span class="token keyword">then</span> 
   commands
<span class="token keyword">fi</span>
</code></pre></div></li> <li><p>test可判断三类条件：数值比较、字符串比较、文件比较</p></li> <li><p><strong>数值比较</strong></p> <ul><li><p>常用比较</p> <table><thead><tr><th>比较</th> <th>作用</th></tr></thead> <tbody><tr><td>n1 -eq n2</td> <td>equal等于</td></tr> <tr><td>n1 -ge n2</td> <td>greater or equal 大于等于</td></tr> <tr><td>n1 -gt n2</td> <td>greater than 大于</td></tr> <tr><td>n1 -le n2</td> <td>less or equal 小于等于</td></tr> <tr><td>n1 -lt n2</td> <td>less than 小于</td></tr> <tr><td>n1 -ne n2</td> <td>not equal 不等于</td></tr></tbody></table></li> <li><p>不能在test中比较浮点数</p></li></ul></li> <li><p><strong>字符串比较</strong></p> <ul><li><p>常用比较</p> <table><thead><tr><th>比较</th> <th>作用</th></tr></thead> <tbody><tr><td>str1 = str2</td> <td>是否相同</td></tr> <tr><td>str1 != str2</td> <td>是否不同</td></tr> <tr><td>str1 &lt; str2</td> <td>字典序大小。ASCII码值</td></tr> <tr><td>str1 &gt; str2</td> <td>..</td></tr> <tr><td>-n str1</td> <td>长度是否非0</td></tr> <tr><td>-z str1</td> <td>长度是否为0</td></tr></tbody></table></li> <li><p>==注意：==使用大小比较时，需要使用转义符避免被识别为重定向</p></li></ul></li> <li><p><strong>文件比较</strong></p> <ul><li><p>用于测试Linux文件系统上文件和目录状态</p></li> <li><p>常用</p> <table><thead><tr><th>比较</th> <th>作用</th></tr></thead> <tbody><tr><td>-d file</td> <td>是否存在并是一个目录directory</td></tr> <tr><td>-e file</td> <td>是否存在exist</td></tr> <tr><td>-f file</td> <td>是否存在并是一个文件file</td></tr> <tr><td>-r file</td> <td>是否存在并可读 read</td></tr> <tr><td>-s file</td> <td>是否存在并非空</td></tr> <tr><td>-w file</td> <td>是否存在并可写 write</td></tr> <tr><td>-x file</td> <td>是否存在并可执行 eXecute</td></tr> <tr><td>-O file</td> <td>是否存在并为当前用户所有</td></tr> <tr><td>-G file</td> <td>是否存在并且默认组和当前用户相同</td></tr> <tr><td>file1 -nt file2</td> <td>file1是否比file2新 newer than</td></tr> <tr><td>file1 -ot file2</td> <td>file1是否比file2旧 older than</td></tr></tbody></table></li> <li><p>如测试是否是文件</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-f</span> myfile <span class="token punctuation">]</span>
<span class="token keyword">then</span>
   <span class="token builtin class-name">echo</span> <span class="token string">&quot;this is a file&quot;</span>
<span class="token keyword">else</span>
   <span class="token builtin class-name">echo</span> <span class="token string">&quot;not a file&quot;</span>
<span class="token keyword">fi</span>
</code></pre></div></li></ul></li></ul> <h3 id="复合条件测试"><a href="#复合条件测试" class="header-anchor">#</a> 复合条件测试</h3> <ul><li>两种布尔运算符可用：
<ul><li>[ condition1 ] &amp;&amp; [ condition2 ]</li> <li>[ condition1 ] || [ condition2 ]</li></ul></li></ul> <h3 id="if-then高级特性"><a href="#if-then高级特性" class="header-anchor">#</a> if-then高级特性</h3> <ul><li><p>两个使用高级特性：</p> <ul><li>用于数学表达式的双括号</li> <li>用于高级字符串处理功能的双方括号</li></ul></li> <li><p><strong>使用双括号</strong></p> <ul><li><p>双括号命令允许在比较过程中使用高级数学表达式，而test只能在比较中使用简单算术操作</p></li> <li><p>格式如下</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token variable"><span class="token punctuation">((</span> expression <span class="token punctuation">))</span></span>
</code></pre></div></li> <li><p>可用表达式符号</p> <table><thead><tr><th>符号</th> <th>作用</th></tr></thead> <tbody><tr><td>val++</td> <td>后增</td></tr> <tr><td>val--</td> <td>后减</td></tr> <tr><td>++val</td> <td>先增</td></tr> <tr><td>--val</td> <td>先减</td></tr> <tr><td>!</td> <td>逻辑取反</td></tr> <tr><td>~</td> <td>按位取反</td></tr> <tr><td>**</td> <td>幂运算</td></tr> <tr><td>&lt;&lt;</td> <td>左移</td></tr> <tr><td>&gt;&gt;</td> <td>右移</td></tr> <tr><td>&amp;</td> <td>按位与</td></tr> <tr><td>|</td> <td>按位或</td></tr> <tr><td>&amp;&amp;</td> <td>逻辑与</td></tr> <tr><td>||</td> <td>逻辑或</td></tr></tbody></table></li> <li><p>双括号可用用于if中，也可以直接当中命令语句放在then中</p></li></ul></li> <li><p><strong>使用双方括号</strong></p> <ul><li><p>格式：</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token punctuation">[</span><span class="token punctuation">[</span> expression <span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre></div></li> <li><p>提供了test未提供的<strong>模式匹配</strong>特性</p></li> <li><p>如使用正则表达式匹配：</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token environment constant">$USER</span> <span class="token operator">==</span> r* <span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token keyword">then</span>
<span class="token punctuation">..</span>.
<span class="token keyword">fi</span>
</code></pre></div></li></ul></li></ul> <h3 id="case语句"><a href="#case语句" class="header-anchor">#</a> case语句</h3> <ul><li><p>格式</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token keyword">case</span> variable <span class="token keyword">in</span>
partten1 <span class="token operator">|</span> partten2<span class="token punctuation">)</span> commands1<span class="token punctuation">;</span><span class="token punctuation">;</span>
partten3<span class="token punctuation">)</span> commands2<span class="token punctuation">;</span><span class="token punctuation">;</span>
*<span class="token punctuation">)</span> default commands<span class="token punctuation">;</span><span class="token punctuation">;</span>
<span class="token keyword">esac</span>
</code></pre></div></li> <li><p>* 号可以匹配任何值，用于处理默认行为</p></li></ul> <h3 id="for语句"><a href="#for语句" class="header-anchor">#</a> for语句</h3> <ul><li><p><strong>基本格式</strong></p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token keyword">for</span> <span class="token for-or-select variable">var</span> <span class="token keyword">in</span> list
<span class="token keyword">do</span>
    commands
<span class="token keyword">done</span>
</code></pre></div></li> <li><p><strong>指定列表(list)中的值有多种方式</strong></p> <ul><li><p>for自身定义的一系列值</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token keyword">for</span> <span class="token for-or-select variable">test</span> <span class="token keyword">in</span> A B C D E F
<span class="token keyword">do</span>
	<span class="token builtin class-name">echo</span> <span class="token variable">$test</span>
<span class="token keyword">done</span>
</code></pre></div></li> <li><p>for中读取复杂列表的值：for自动用空格分割各个值，若值中本身包含空格，则需要使用引号包裹；使用到单引号等也可以用引号包裹，或转义符处理</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token keyword">for</span> <span class="token for-or-select variable">test</span> <span class="token keyword">in</span> I don<span class="token punctuation">\</span>'t know <span class="token keyword">if</span> this<span class="token punctuation">\</span>'ll work
<span class="token keyword">do</span>
	<span class="token builtin class-name">echo</span> <span class="token variable">$test</span>
<span class="token keyword">done</span>

<span class="token comment"># 本身带空格情况</span>
<span class="token keyword">for</span> <span class="token for-or-select variable">city</span> <span class="token keyword">in</span> <span class="token string">&quot;New York&quot;</span> Chengdu Beijing
<span class="token keyword">do</span>
<span class="token punctuation">..</span>
<span class="token keyword">done</span>
</code></pre></div></li> <li><p>利用命令替换从命令读取值</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token keyword">for</span> <span class="token for-or-select variable">each</span> <span class="token keyword">in</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">cat</span> $file<span class="token variable">)</span></span>
<span class="token keyword">do</span>
<span class="token punctuation">..</span><span class="token punctuation">..</span>
<span class="token keyword">done</span>
</code></pre></div></li></ul></li> <li><p><strong>更改字段分隔符</strong></p> <ul><li><p>IFS(internal field separator)内部字段分隔符是一个特殊环境变量。定义shell用作字段分隔符的一系列字符。默认为：</p> <ul><li>空格</li> <li>制表符</li> <li>换行符</li></ul></li> <li><p>若在处理含有空格的数据，如文件名时可能会比较麻烦，通常可在shell脚本中临时更改IFS环境变量来限制被shell当作字段分隔符的字符。如只能识别换行符<code>IFS=$'\n'</code></p></li> <li><p>此外，若需要遍历一个其他符号分割的数据，可临时将其改为该符号，如遍历冒号分隔的数据：</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token assign-left variable"><span class="token environment constant">IFS</span>.OLD</span><span class="token operator">=</span><span class="token environment constant">IFS</span>
<span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span>:
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
<span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span><span class="token environment constant">IFS</span>.OLD
</code></pre></div></li> <li><p>需要多个时直接串连即可(==注意==：shell的字符串拼接没有 + 号)</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span><span class="token string">$'<span class="token entity" title="\n">\n</span>'</span><span class="token builtin class-name">:</span><span class="token punctuation">;</span>&quot;
</code></pre></div></li></ul></li> <li><p><strong>使用通配符读取目录</strong></p> <ul><li><p>在for的list中，对文件名或路径名使用通配符，其会启用文件扩展匹配</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token keyword">for</span> <span class="token for-or-select variable">file</span> <span class="token keyword">in</span> /home/xiao/*
<span class="token keyword">do</span>
<span class="token punctuation">..</span>.
<span class="token keyword">done</span>
</code></pre></div></li></ul></li></ul> <h3 id="c语言风格的for语句"><a href="#c语言风格的for语句" class="header-anchor">#</a> C语言风格的for语句</h3> <ul><li><p>格式</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span> variable assignment <span class="token punctuation">;</span> condition <span class="token punctuation">;</span> iteration process <span class="token punctuation">))</span></span>
</code></pre></div></li> <li><p>示例</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token number">10</span> <span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">))</span></span>
<span class="token keyword">do</span>
<span class="token punctuation">..</span><span class="token punctuation">..</span>
<span class="token keyword">done</span>
</code></pre></div></li></ul> <h3 id="while语句"><a href="#while语句" class="header-anchor">#</a> while语句</h3> <ul><li><p>基本格式</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token keyword">while</span> <span class="token builtin class-name">test</span> <span class="token builtin class-name">command</span>
<span class="token keyword">do</span>
	other commands
<span class="token keyword">done</span>
</code></pre></div></li> <li><p>while中test语句和if语法一样</p></li> <li><p>使用多个测试指令时，最后一个测试指令的退出状态码会被用来决定什么时候结束循环</p></li></ul> <h3 id="util命令"><a href="#util命令" class="header-anchor">#</a> util命令</h3> <ul><li><p>util和while刚好相反，仅当测试命令退出状态码不为 0 时才执行</p></li> <li><p>格式</p> <div class="language-sh extra-class"><pre class="language-sh"><code>util <span class="token builtin class-name">test</span> commands
<span class="token keyword">do</span>
	other commands
<span class="token keyword">done</span>
</code></pre></div></li></ul> <h3 id="循环处理文件数据"><a href="#循环处理文件数据" class="header-anchor">#</a> 循环处理文件数据</h3> <ul><li>需要使用两个关键技术
<ul><li>嵌套循环</li> <li>修改IFS环境变量</li></ul></li></ul> <h3 id="控制循环"><a href="#控制循环" class="header-anchor">#</a> 控制循环</h3> <ul><li><p>控制循环的两个语句</p> <ul><li>break</li> <li>continue</li></ul></li> <li><p>其中break默认跳出最内层循环，也可通过参数 n 指定跳出的循环层数，默认为 1</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span> i<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span> <span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">))</span></span>
<span class="token keyword">do</span>
	<span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span> j<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">;</span> j<span class="token operator">&lt;</span><span class="token number">20</span> <span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">))</span></span>
	<span class="token keyword">do</span>
	  <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$i</span> <span class="token parameter variable">-eq</span> <span class="token number">5</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">[</span> <span class="token variable">$j</span> <span class="token parameter variable">-eq</span> <span class="token number">3</span> <span class="token punctuation">]</span>
	  <span class="token keyword">then</span>
	  	 <span class="token builtin class-name">break</span> <span class="token number">2</span>
	  <span class="token keyword">else</span>
	     <span class="token builtin class-name">echo</span> <span class="token variable">$i</span>
	  <span class="token keyword">fi</span>
	<span class="token keyword">done</span>
<span class="token keyword">done</span>
</code></pre></div></li> <li><p>continue 用于结束此次循环进入下一循环。同样支持参数 n 用于控制继续执行哪一层循环</p></li></ul> <h3 id="处理循环的输出"><a href="#处理循环的输出" class="header-anchor">#</a> 处理循环的输出</h3> <ul><li><p>在shell脚本中可对循环的输出使用管道或进行重定向，具体是在<strong>done命令后使用一个处理命令</strong></p> <div class="language-sh extra-class"><pre class="language-sh"><code>for<span class="token punctuation">..</span>.
do<span class="token punctuation">..</span>.
<span class="token keyword">done</span> <span class="token operator">&gt;</span> output.txt
</code></pre></div></li></ul> <h2 id="处理用户输入"><a href="#处理用户输入" class="header-anchor">#</a> 处理用户输入</h2> <h3 id="命令行参数"><a href="#命令行参数" class="header-anchor">#</a> 命令行参数</h3> <ul><li><p><strong>读取参数</strong></p> <ul><li>位置参数：分配给命令行中参数的特殊变量。位置参数是标准的数字，含义如下
<ul><li>$0：程序名</li> <li>$1~$9：分别表示第一个参数到第九个参数</li> <li>${10}：当参数超过 9 个时，需要使用大括号</li></ul></li></ul></li> <li><p><strong>获取脚本名</strong></p> <ul><li><p>通过$0可获取脚本名，但可能会包含执行路径等其他信息</p></li> <li><p>通过<code>basename</code>命令可得到不包含路径的脚本名</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token assign-left variable">name</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">basename</span> $0<span class="token variable">)</span></span>
</code></pre></div></li> <li><p>一个执行不同功能脚本的示例</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token shebang important">#!/bin/bash</span>
<span class="token assign-left variable">name</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">basename</span> $0<span class="token variable">)</span></span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$name</span> <span class="token operator">=</span> <span class="token string">&quot;add&quot;</span> <span class="token punctuation">]</span>
<span class="token keyword">then</span>
	<span class="token assign-left variable">total</span><span class="token operator">=</span>$<span class="token punctuation">[</span> <span class="token variable">$1</span> + <span class="token variable">$2</span> <span class="token punctuation">]</span>
<span class="token keyword">elif</span> <span class="token punctuation">[</span> <span class="token variable">$name</span> <span class="token operator">=</span> <span class="token string">&quot;mult&quot;</span> <span class="token punctuation">]</span>
<span class="token keyword">then</span>
	<span class="token assign-left variable">total</span><span class="token operator">=</span>$<span class="token punctuation">[</span> <span class="token variable">$1</span> * <span class="token variable">$2</span> <span class="token punctuation">]</span>
<span class="token keyword">fi</span>
<span class="token builtin class-name">echo</span> The calculated value is <span class="token variable">$total</span>
</code></pre></div><ul><li>此时，若将脚本命名为<code>add.sh</code>，则可使用<code>./add 1 2</code>执行加法，若为<code>mult.sh</code>，则可执行乘法</li></ul></li></ul></li></ul> <h3 id="特殊参数变量"><a href="#特殊参数变量" class="header-anchor">#</a> 特殊参数变量</h3> <ul><li><p><strong>参数统计</strong></p> <ul><li><p>特殊变量<code>$#</code>含有脚本运行时携带的命令行参数个数</p></li> <li><p>此变量提供了一个获取命令行最后一个参数的快捷方式</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token variable">${<span class="token operator">!</span><span class="token operator">#</span>}</span>

<span class="token comment"># 注意，不能使用 ${$#}，要使用 $# 时需要先用变量保存</span>
</code></pre></div></li></ul></li> <li><p><strong>抓取所有的数据</strong></p> <ul><li><code>$*</code>将所有命令行参数当作一个整体（可视作参数拼接的字符串）保存</li> <li><code>$@</code>将所有命令参数当作类似数组一样的形式保存</li> <li>上述两种方式都能用于获取所有参数.后者甚至支持for循环遍历</li></ul></li></ul> <h3 id="移动变量"><a href="#移动变量" class="header-anchor">#</a> 移动变量</h3> <ul><li><p><code>shift</code>命令用于对命令参数的相对位置进行移动</p></li> <li><p>默认情况下会将每个参数向左移动一个位置，如变量$3移动到$2的位置，<strong>而$1则被删除</strong></p></li> <li><p>通常在不知道参数个数的情况下，这是一种很好的遍历方式</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token shebang important">#!/bin/bash</span>
<span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token parameter variable">-n</span> <span class="token string">&quot;<span class="token variable">$1</span>&quot;</span> <span class="token punctuation">]</span>
<span class="token keyword">do</span>
	<span class="token builtin class-name">echo</span> <span class="token variable">$1</span>
	<span class="token assign-left variable">count</span><span class="token operator">=</span>$<span class="token punctuation">[</span> <span class="token variable">$count</span> + <span class="token number">1</span> <span class="token punctuation">]</span>
	<span class="token builtin class-name">shift</span>
<span class="token keyword">done</span>
</code></pre></div></li> <li><p>此外，通过给shift传递一个数值可控制其移动距离，如此可用于跳过不必要的参数</p></li></ul> <h3 id="处理选项"><a href="#处理选项" class="header-anchor">#</a> 处理选项</h3> <ul><li><p>处理简单选项使用<code>case</code>语句</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token parameter variable">-n</span> <span class="token string">&quot;<span class="token variable">$1</span>&quot;</span> <span class="token punctuation">]</span>
<span class="token keyword">do</span>
	<span class="token keyword">case</span> <span class="token string">&quot;<span class="token variable">$1</span>&quot;</span> <span class="token keyword">in</span>
		-a<span class="token punctuation">)</span> xxxxx <span class="token punctuation">;</span><span class="token punctuation">;</span>
		-b<span class="token punctuation">)</span> xxxxx <span class="token punctuation">;</span><span class="token punctuation">;</span>
		-c<span class="token punctuation">)</span> xxxxx <span class="token punctuation">;</span><span class="token punctuation">;</span>
		*<span class="token punctuation">)</span> xxxxx<span class="token punctuation">;</span><span class="token punctuation">;</span>
	<span class="token keyword">esac</span>
	<span class="token builtin class-name">shift</span>
<span class="token keyword">done</span>
</code></pre></div></li> <li><p>使用<code>getopt</code>命令</p> <ul><li><p>用于处理命令行选项和参数时的有用工具</p></li> <li><p>getopt使用格式：可接收一系列任意形式的命令行选项和参数，并自动转换成适当格式</p> <div class="language-sh extra-class"><pre class="language-sh"><code>getopt optstring parameters
</code></pre></div></li> <li><p>optstring定义了命令行有效的选项字母，还定义了哪些选项字母需要参数值（后边加冒号）</p></li> <li><p>示例</p> <div class="language-sh extra-class"><pre class="language-sh"><code>getopt ab:cd <span class="token parameter variable">-a</span> <span class="token parameter variable">-b</span> test1 <span class="token parameter variable">-cd</span> test2 test3
</code></pre></div></li> <li><p>上述含义为：有abcd四个选项，其中 b 需要一个参数；同时能将-cd拆解成两个选项。之后的参数是非选项参数</p></li></ul></li> <li><p>脚本中使用getopt</p> <ul><li><p>用getopt命令生成的格式化后的命令选项和参数替换已有的选项和参数；使用set命令可做到</p></li> <li><p>set的选项<code>--</code>会<strong>将命令行参数替换成set命令的值</strong></p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># 替换命令行参数</span>
<span class="token builtin class-name">set</span> -- <span class="token variable"><span class="token variable">$(</span>getopt <span class="token parameter variable">-q</span> ab:cd <span class="token string">&quot;<span class="token variable">$@</span>&quot;</span><span class="token variable">)</span></span>

<span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token parameter variable">-n</span> <span class="token string">&quot;<span class="token variable">$1</span>&quot;</span> <span class="token punctuation">]</span>
<span class="token keyword">do</span>
	<span class="token keyword">case</span> <span class="token string">&quot;<span class="token variable">$1</span>&quot;</span> <span class="token keyword">in</span>
	-a<span class="token punctuation">)</span>xxx<span class="token punctuation">;</span><span class="token punctuation">;</span>
	-b<span class="token punctuation">)</span>xxx
	   <span class="token builtin class-name">shift</span> <span class="token punctuation">;</span><span class="token punctuation">;</span>
	-c<span class="token punctuation">)</span>xxx<span class="token punctuation">;</span><span class="token punctuation">;</span>
	--<span class="token punctuation">)</span>shift
	   <span class="token builtin class-name">break</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
	 *<span class="token punctuation">)</span>xxxx<span class="token punctuation">;</span><span class="token punctuation">;</span>
	 <span class="token keyword">esac</span>
	 <span class="token builtin class-name">shift</span>
<span class="token keyword">done</span>
</code></pre></div></li> <li><p>getopt并不适合用于处理带空格和引号的参数值，其会将空格作为分隔符</p></li></ul></li> <li><p>使用更高级的getopts</p> <ul><li><p>getopts能和已有的shell参数变量默契配合</p></li> <li><p>每次调用时，只处理命令行上检测到的一个参数，处理完所有参数后，会退出并返回一个大于 0 的状态码</p></li> <li><p>格式如下：</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token builtin class-name">getopts</span> optstring variable
</code></pre></div></li> <li><p>其中哦平台string类似于getopt命令；getopts将当前参数保存在命令行中定义的variable中</p></li> <li><p>会使用两个变量</p> <ul><li><code>OPTARG</code>：若选项需要跟参数值，此变量会保存这个值</li> <li><code>OPTIND</code>：保存参数列表中正在处理的参数位置</li></ul></li> <li><p>示例</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># 前导 ：表示忽略错误信息。后 ： 表示需要参数值；每次的参数存在 opt 变量中</span>
<span class="token keyword">while</span> <span class="token builtin class-name">getopts</span> :ab:c opt
<span class="token keyword">do</span>
	<span class="token keyword">case</span> <span class="token string">&quot;<span class="token variable">$opt</span>&quot;</span> <span class="token keyword">in</span>
	a<span class="token punctuation">)</span>xxx<span class="token punctuation">;</span><span class="token punctuation">;</span>
	b<span class="token punctuation">)</span>xxx<span class="token punctuation">;</span><span class="token punctuation">;</span>
	c<span class="token punctuation">)</span>xxx<span class="token punctuation">;</span><span class="token punctuation">;</span>
	*<span class="token punctuation">)</span>xxx<span class="token punctuation">;</span>
	<span class="token keyword">esac</span>
<span class="token keyword">done</span>
</code></pre></div></li> <li><p>注意，和getopt不同，getopts会自动去掉选项前边的短横线，因此在case中不需要</p></li> <li><p>支持包含空格的参数；支持选项和参数之间不留空格，如</p> <div class="language-sh extra-class"><pre class="language-sh"><code>mycommand <span class="token parameter variable">-a</span> <span class="token string">&quot;hello world&quot;</span> <span class="token parameter variable">-bcmyname</span>
</code></pre></div></li></ul></li></ul> <h3 id="获取用户输入"><a href="#获取用户输入" class="header-anchor">#</a> 获取用户输入</h3> <ul><li><p><strong>基本读取</strong></p> <ul><li><p><code>read</code>命令从标准输入(键盘)或另一个文件描述符中接收输入。收到输入后，会将数据放进一个变量</p></li> <li><p>使用<code>-p</code>选项允许指定输入提示信息</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token builtin class-name">read</span> <span class="token parameter variable">-p</span> <span class="token string">&quot;input your name&quot;</span> name
<span class="token builtin class-name">echo</span> <span class="token variable">$name</span>
</code></pre></div></li> <li><p>read按照一定分隔符将读取的内容分配给命令中指定的变量，变量数不够时剩余内容全部给最后一个变量</p></li> <li><p>在read不指定变量的时候，其会将读取到的数据放入环境变量<code>REPLY</code>中</p></li></ul></li> <li><p><strong>超时</strong></p> <ul><li><p><code>-t</code>选项可为read指定一个超时时间，超过时间没有输入则返回一个非零退出状态码。单位为秒</p></li> <li><p>也可通过<code>-n</code>指定read在接收指定个数的字符输入后退出</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token builtin class-name">read</span> <span class="token parameter variable">-n</span> <span class="token number">1</span> <span class="token parameter variable">-p</span> <span class="token string">&quot;do you want to continue? [Y/N]&quot;</span> answer
</code></pre></div></li></ul></li> <li><p><strong>隐藏输入</strong></p> <ul><li>对于密码等信息，有时候需要隐藏实际的输入</li> <li><code>-s</code>选项可避免read命令中输入的数据出现在显示器上（实际会被显示，只是文本颜色与背景色一样）</li></ul></li> <li><p><strong>从文件读取</strong></p> <ul><li><p>每次调用read，会从文件中读取一行</p></li> <li><p>文件读完时read退出并返回非零状态码</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">cat</span> <span class="token builtin class-name">test</span> <span class="token operator">|</span> <span class="token keyword">while</span> <span class="token builtin class-name">read</span> line
<span class="token keyword">do</span>
<span class="token punctuation">..</span><span class="token punctuation">..</span>
<span class="token keyword">done</span>
</code></pre></div></li></ul></li></ul> <h2 id="呈现数据"><a href="#呈现数据" class="header-anchor">#</a> 呈现数据</h2> <h3 id="理解输入和输出"><a href="#理解输入和输出" class="header-anchor">#</a> 理解输入和输出</h3> <ul><li><p><strong>标准文件描述符</strong></p> <ul><li><p>Linux使用<strong>文件描述符</strong>标识每个文件对象，其是一个非负整数，可唯一标识会话中打开的文件</p></li> <li><p>每个进程最多有 9 个文件描述符，bash shell保留了前三个文件描述符（0，1，2）</p> <table><thead><tr><th>文件描述符</th> <th>缩写</th> <th>描述</th></tr></thead> <tbody><tr><td>0</td> <td>STDIN</td> <td>标准输入</td></tr> <tr><td>1</td> <td>STDOUT</td> <td>标准输出</td></tr> <tr><td>2</td> <td>STDERR</td> <td>标准错误</td></tr></tbody></table></li> <li><p>STDIN</p> <ul><li>代表shell的标准输入，即键盘输入</li> <li>使用输入重定向时(&lt;)，标准输入会替换为指定的文件描述符，从指定文件读取数据</li></ul></li> <li><p>STDOUT</p> <ul><li>代表shell的标准输出，即终端显示器</li> <li>使用输出重定向时(&gt;)，标准输出会被替换为指定的文件描述符，输出到指定文件而不是屏幕</li></ul></li> <li><p>STDERR</p> <ul><li>shell通过此特殊的文件描述符来处理错误消息，shell或shell脚本运行时的错误信息都会发送到此位置</li> <li>默认标准错误也是输出到屏幕，而STDOUT的重定向也不会影响STDERR重定向</li></ul></li></ul></li> <li><p><strong>重定向错误</strong></p> <ul><li><p>在使用重定向符号时指定描述符可实现重定向特定类型标准描述符</p></li> <li><p>只重定向错误</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># 在重定向符号之前指定描述符2，可将标准错误重定向到文件test</span>
<span class="token function">ls</span> <span class="token parameter variable">-al</span> badfile <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span> <span class="token builtin class-name">test</span>
</code></pre></div></li> <li><p>重定向错误和数据</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># 使用两个重定向符号分别将 标准错误 、标准输出重定向到两个文件</span>
<span class="token function">ls</span> <span class="token parameter variable">-al</span> <span class="token builtin class-name">test</span> badtest <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span> errorfile <span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span> resultfile
</code></pre></div></li> <li><p>将STDERR和STDOUT重定向到同一个文件，使用<code>&amp;&gt;</code>符号</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">ls</span> <span class="token parameter variable">-al</span> <span class="token builtin class-name">test</span> badtest <span class="token operator">&amp;&gt;</span> outfile
</code></pre></div></li></ul></li></ul> <h3 id="脚本中重定向输出"><a href="#脚本中重定向输出" class="header-anchor">#</a> 脚本中重定向输出</h3> <ul><li><p><strong>临时重定向</strong></p> <ul><li><p>可将单独一行输出重定向到STDERR，使用<code>&gt;&amp;2</code></p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token builtin class-name">echo</span> <span class="token string">&quot;This is an error&quot;</span> <span class="token operator">&gt;</span><span class="token file-descriptor important">&amp;2</span>
</code></pre></div></li> <li><p>临时重定向只会影响到使用临时重定向的输出</p></li></ul></li> <li><p><strong>永久重定向</strong></p> <ul><li><p>可使用<code>exec</code>命令告诉shell在脚本执行期间重定向某个特定文件描述符</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token builtin class-name">exec</span> <span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>testout
<span class="token punctuation">..</span><span class="token punctuation">..</span>.
</code></pre></div></li> <li><p>支持在脚本执行的过程中进行重定向</p></li> <li><p>但很难再将它们重定向为原来的位置</p></li></ul></li></ul> <h3 id="脚本中重定向输入"><a href="#脚本中重定向输入" class="header-anchor">#</a> 脚本中重定向输入</h3> <ul><li><p>可使用与重定向STDOUT和STDERR的方式重定向输入</p></li> <li><p><code>exec</code>命令允许将STDIN重定向到文件中</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token builtin class-name">exec</span> <span class="token operator"><span class="token file-descriptor important">0</span>&lt;</span> <span class="token function">file</span>
</code></pre></div></li></ul> <h3 id="自定义重定向"><a href="#自定义重定向" class="header-anchor">#</a> 自定义重定向</h3> <ul><li><p>除了0-2，3-8这些文件描述符都可作为输入或输出重定向</p></li> <li><p><strong>创建输出文件描述符</strong></p> <ul><li><p>可使用<code>exec</code>命令给输出分配文件描述符</p></li> <li><p>同标准文件描述符，一旦将另一个文件描述符分配给一个文件，这个重定向就会一直生效直到更改</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># 将文件描述符 3 分配给文件</span>
<span class="token builtin class-name">exec</span> <span class="token operator"><span class="token file-descriptor important">3</span>&gt;</span> testfile

<span class="token builtin class-name">echo</span> <span class="token string">&quot;This should display on screen&quot;</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;This should be stored in the file&quot;</span> <span class="token operator">&gt;</span><span class="token file-descriptor important">&amp;3</span> <span class="token comment"># 被重定向到文件描述符3 指定的文件</span>
</code></pre></div></li> <li><p>可不创建新文件，使用exec命令将输出追加到某个文件</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token builtin class-name">exec</span> <span class="token operator"><span class="token file-descriptor important">3</span>&gt;&gt;</span>testfile
</code></pre></div></li></ul></li> <li><p><strong>重定向文件描述符</strong></p> <ul><li><p>恢复已经重定向的文件描述符：</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># 将描述符 3 重定向到标准输出 1 。 实现暂存效果</span>
<span class="token builtin class-name">exec</span> <span class="token operator"><span class="token file-descriptor important">3</span>&gt;</span><span class="token file-descriptor important">&amp;1</span>
<span class="token comment"># 将标准输出 1 重定向到文件</span>
<span class="token builtin class-name">exec</span> <span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>testfile
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>

<span class="token comment"># 将标准输出 1 重定向回原来的输出</span>
<span class="token builtin class-name">exec</span> <span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token file-descriptor important">&amp;3</span>
</code></pre></div></li></ul></li> <li><p><strong>创建读写文件描述符</strong></p> <ul><li><p>可以将输出和输出指向同一文件，但要注意读写位置指针，可能在写时覆盖文件</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token builtin class-name">exec</span> <span class="token operator"><span class="token file-descriptor important">3</span>&lt;&gt;</span>testfile
</code></pre></div></li></ul></li> <li><p><strong>关闭文件描述符</strong></p> <ul><li><p>通常创建了新的文件描述符脚本在退出后会自动关闭，但可能某些时候需要在脚本结束前手动关闭</p></li> <li><p>重定向到特殊符号<code>&amp;-</code>即可关闭</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token builtin class-name">exec</span> <span class="token operator"><span class="token file-descriptor important">3</span>&gt;&amp;</span>-
</code></pre></div></li></ul></li></ul> <h3 id="列出打开的文件描述符"><a href="#列出打开的文件描述符" class="header-anchor">#</a> 列出打开的文件描述符</h3> <ul><li><p><code>lsof</code>命令会列出整个Linux系统打开的所有文件描述符</p></li> <li><p>参数<code>-p</code>用于指定PID进行过滤</p></li> <li><p>参数<code>-d</code>用于指定文件描述符号进行过滤</p></li> <li><p>tips：可使用特殊环境变量<code>$$</code>标识当前进程的PID</p></li> <li><p>losf中的信息</p> <table><thead><tr><th>列</th> <th>含义</th></tr></thead> <tbody><tr><td>COMMAND</td> <td>命令名</td></tr> <tr><td>PID</td> <td>进程PID</td></tr> <tr><td>USER</td> <td>进程属主</td></tr> <tr><td>FD</td> <td>文件描述符及其类型：r代表读，w代表些，u代表读写</td></tr> <tr><td>TYPE</td> <td>文件类型：CHR表字符型，BLK表块型，DIR表目录，REG表常规文件</td></tr> <tr><td>DEVICE</td> <td>设备号</td></tr> <tr><td>SIZE</td> <td>表文件大小</td></tr> <tr><td>NODE</td> <td>本地文件节点号</td></tr> <tr><td>NAME</td> <td>文件名</td></tr></tbody></table></li></ul> <h3 id="阻止命令输出"><a href="#阻止命令输出" class="header-anchor">#</a> 阻止命令输出</h3> <ul><li><p>将输出重定向到<code>/dev/null</code>文件时，任何数据都不会保存，全部被丢弃</p></li> <li><p>忽略错误则可：</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">ls</span> <span class="token parameter variable">-al</span> <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>/dev/null
</code></pre></div></li> <li><p>也可利用此文件实现快速清除某个文件内容</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">cat</span> /dev/null <span class="token operator">&gt;</span> testfile
</code></pre></div></li></ul> <h3 id="创建临时文件"><a href="#创建临时文件" class="header-anchor">#</a> 创建临时文件</h3> <ul><li><p>Linux上的特殊目录<code>/tmp</code>专供存储临时文件使用，多数Linux发行版会在启动时自动删除/tmp中的文件</p></li> <li><p><code>mktemp</code>命令可在/tmp目录中创建一个唯一的临时文件。该文件不按照umask值创建，其会将文件的读写权限分配给属主，而创建者就是属主。一旦创建脚本就有完整的读写权限，但其他人无法访问</p></li> <li><p><strong>创建本地临时文件</strong></p> <ul><li><p>使用<code>mktemp</code>指定一个文件名模板即可创建临时文件，格式为<code>filename.XXXXXX</code>，即文件名加6个X。X会被自动替换，保证文件唯一性</p> <div class="language-sh extra-class"><pre class="language-sh"><code>mktemp myfile.XXXXXX
</code></pre></div></li> <li><p>在脚本中需要保存该文件名才能使用</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token assign-left variable">tempfile</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>mktemp myfile.XXXXXX<span class="token variable">)</span></span>
</code></pre></div></li></ul></li> <li><p><strong>在/tmp中创建临时文件</strong></p> <ul><li><code>-t</code>选项会强制mktemp命令在系统的临时目录创建该文件。使用此特性时，命令会返回该文件的全路径名</li></ul></li> <li><p><strong>创建临时目录</strong></p> <ul><li><code>-d</code>选项用于创建一个临时目录</li></ul></li></ul> <h3 id="记录消息"><a href="#记录消息" class="header-anchor">#</a> 记录消息</h3> <ul><li><code>tee</code>命令可将输出重定向到两处：STDOUT和tee指定的文件</li> <li>默认会覆盖文件内容，<code>-a</code>选项能够采用追加的方式</li></ul> <h2 id="控制脚本"><a href="#控制脚本" class="header-anchor">#</a> 控制脚本</h2> <h3 id="处理信号"><a href="#处理信号" class="header-anchor">#</a> 处理信号</h3> <ul><li><p>Linux的信号见<a href="#linux-signal">Linux信号</a></p></li> <li><p>脚本默认忽略信号</p></li> <li><p><strong>生成信号</strong></p> <ul><li>shell允许通过键盘上的组合键生成两种基本信号
<ol><li>中断进程：Ctrl+C，产生SIGINT信号，停止shell中当前运行进程</li> <li>暂停进程：Ctrl+Z，产生SIGTSTP信号，停止shell中运行的任何进程。停止并非终止，停止进程会保存在内存中，并能从上次停止的位置继续执行</li></ol></li></ul></li> <li><p><strong>捕获信号</strong></p> <ul><li><p><code>trap</code>命令允许指定shell脚本要监视并拦截的信号，若脚本收到trap命令列出的信号，则<strong>该信号不再由shell处理</strong></p></li> <li><p>命令格式</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token builtin class-name">trap</span> commands signals
</code></pre></div></li> <li><p>示例</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token builtin class-name">trap</span> <span class="token string">&quot;echo 'Trap Ctrl + C'&quot;</span> SIGINT
</code></pre></div></li></ul></li> <li><p><strong>捕获脚本退出</strong></p> <ul><li><p>除了在shell脚本中捕获信号，也可在shell脚本退出时进行捕获。这是在shell完成任务时执行命令的一种简便方法</p></li> <li><p>在 trap 命令后 加 <code>EXIT</code>信号即可</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token builtin class-name">trap</span> <span class="token string">&quot;echo Bye....&quot;</span> EXIT
</code></pre></div></li></ul></li> <li><p><strong>修改或移除捕获</strong></p> <ul><li><p>再次使用<code>trap</code>命令捕获同一个信号时，会按照新的处理方式进行处理</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token builtin class-name">trap</span> <span class="token string">&quot;echo trap1&quot;</span> SIGINT
<span class="token punctuation">..</span><span class="token punctuation">..</span>.
<span class="token punctuation">..</span><span class="token punctuation">..</span>.
<span class="token comment"># 执行到此语句之前对 SIGINT 按照之前的方式处理</span>
<span class="token comment"># 执行到此语句之后按照新的方式处理 SIGINT</span>
<span class="token builtin class-name">trap</span> <span class="token string">&quot;echo trap2&quot;</span> SIGINT
</code></pre></div></li> <li><p>删除已经定义的捕获行为：格式 <code>trap -- 信号名</code></p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># 此后脚本不再处理SIGINT信号，按照默认行为处理</span>
<span class="token builtin class-name">trap</span> -- SIGINT
</code></pre></div></li></ul></li></ul> <h3 id="后台模式运行脚本"><a href="#后台模式运行脚本" class="header-anchor">#</a> 后台模式运行脚本</h3> <ul><li><p><strong>后台运行脚本</strong></p> <ul><li><p>后台运行脚本只需在命令后加一个<code>&amp;</code>符号即可</p> <div class="language-sh extra-class"><pre class="language-sh"><code>./test.sh <span class="token operator">&amp;</span>
</code></pre></div></li> <li><p>当后台进程运行时，仍然会使用终端显示器来显示STDOUT和STDERR消息</p></li> <li><p>最好将后台运行的的脚本STDOUT和STDERR重定向</p></li></ul></li></ul> <h3 id="在非控制台下运行脚本"><a href="#在非控制台下运行脚本" class="header-anchor">#</a> 在非控制台下运行脚本</h3> <ul><li><p>有时需要在终端中启动脚本，然后让脚本一直以后台模式运行到结束，即使退出终端</p></li> <li><p>使用<code>nohup</code>命令实现。其运行了另一个命令来阻断所有发送给该进程的SIGHUP信号，这会在退出终端会话时阻止进程退出</p></li> <li><p>命令格式</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">nohup</span> ./test.sh <span class="token operator">&amp;</span>
</code></pre></div></li> <li><p>nohup命令使用后，进程与终端解除关联，STDOUT和STDERR会重定向到一个名为<code>nohuo.out</code>的文件中</p></li></ul> <h3 id="作业控制"><a href="#作业控制" class="header-anchor">#</a> 作业控制</h3> <ul><li><p><strong>查看作业</strong></p> <ul><li><p>作业控制中的关键命令是<code>jobs</code>命令，允许查看shell当前正在处理的作业</p></li> <li><p>常用选项</p> <table><thead><tr><th>选项参数</th> <th>描述</th></tr></thead> <tbody><tr><td>-l</td> <td>列出进程的PID及作业号</td></tr> <tr><td>-n</td> <td>只列出上次shell发出的通知后改变状态的作业</td></tr> <tr><td>-p</td> <td>只列出作业的PID</td></tr> <tr><td>-r</td> <td>只列出运行中的作业</td></tr> <tr><td>-s</td> <td>只列出已停止的作业</td></tr></tbody></table></li> <li><p>jobs命令输出的作业列表中，带<code>+</code>号表示默认作业，即在使用作业控制而没有指定作业号时默认处理的作业；而带<code>-</code>号表示下一个默认作业。任意时刻只有一个+和一个-</p></li></ul></li> <li><p><strong>重启停止的作业</strong></p> <ul><li>bash作业中，可将已停止的作业作为后台进程或前台进程重启</li> <li><code>bg</code>命令后加作业号可以后台模式重启一个作业</li> <li><code>fg</code>命令+作业号可在前台重启一个作业</li></ul></li></ul> <h3 id="调整谦让度"><a href="#调整谦让度" class="header-anchor">#</a> 调整谦让度</h3> <ul><li><p>Linux调度优先级(Scheduling priority)是一个-20（最高优先级）到19（最低优先级）的整数，默认shell以 0 优先级启动进程</p></li> <li><p><strong>nice命令</strong></p> <ul><li><p><code>nice</code>命令用于设置命令启动时的优先级，使用<code>-n</code>参数指定优先级</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">nice</span> <span class="token parameter variable">-n</span> <span class="token number">10</span> ./test.sh <span class="token operator">&gt;</span> test4.out <span class="token operator">&amp;</span>
</code></pre></div></li> <li><p>nice会让脚本以更低的优先级运行，若指定高优先级，普通用户的操作会被提示权限不够</p></li></ul></li> <li><p><strong>renice命令</strong></p> <ul><li><p>改变已运行命令的优先级，需要指定PID</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">renice</span> <span class="token parameter variable">-n</span> <span class="token number">10</span> <span class="token parameter variable">-p</span> <span class="token number">1002</span>
</code></pre></div></li> <li><p>renice的限制</p> <ul><li>只能对属于自己的进程执行renice</li> <li>只能通过renice降低优先级</li> <li>root可通过renice任意调整优先级</li></ul></li></ul></li></ul> <h3 id="定时运行作业"><a href="#定时运行作业" class="header-anchor">#</a> 定时运行作业</h3> <ul><li><p>linux提供了<code>at</code>命令和<code>cron</code>指定在预选时间运行脚本</p></li> <li><p><strong>使用at命令来计划执行作业</strong></p> <ul><li><p>允许指定Linux系统何时运行脚本。其将作业提交到队列中，指定shell何时运行该作业，at的守护进程atd会以后台模式运行，检查作业队列来运行作业</p></li> <li><p>atd守护进程会检查特殊目录(通常为<code>/var/spool/at</code>)来获取at命令提交的作业</p></li> <li><p>命令格式</p> <div class="language-sh extra-class"><pre class="language-sh"><code>at <span class="token punctuation">[</span>-f filename<span class="token punctuation">]</span> <span class="token function">time</span>
</code></pre></div></li> <li><p>默认at命令会将STDIN输入放到队列中，可使用参数<code>-f</code>指定用于读取命令的文件名</p></li> <li><p>at命令能识别多种时间格式</p> <ul><li>标准的小时和分钟格式，如10:15</li> <li>AM/PM指示符，如10:15PM</li> <li>特定可命名时间，如now、noon、midnight、teatime(4PM)</li> <li>标准日期格式，如MMDDYY、MM/DD/YY或DD.MM.YY</li> <li>文本日期，如Jul 4或Dec 25</li> <li>可指定时间增量
<ul><li>当前时间+25min</li> <li>明天 10:15PM</li> <li>10:15+7天</li></ul></li></ul></li> <li><p>获取作业输出</p> <ul><li><p>默认at会将提交该作业的用户的电子邮件地址作为STDOUT和STDERR</p></li> <li><p>at命令使用sendmail应用发送邮件，没有该应用时不会有任何输出；因此最好进行输出重定向</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># -M 选项屏蔽作业产生的输出信息</span>
at <span class="token parameter variable">-M</span> <span class="token parameter variable">-f</span> test.sh now
</code></pre></div></li></ul></li> <li><p>列出等待的作业</p> <ul><li><code>atq</code>命令可以查看系统中有哪些作业在等待</li></ul></li> <li><p>删除作业</p> <ul><li><code>atrm</code>命令+作业号可删除作业，只能删除自己提交的作业</li></ul></li></ul></li> <li><p><strong>安排需要定期执行的脚本</strong></p> <ul><li><p>at用于在预设时间执行脚本，而<code>cron</code>程序可实现周期性执行脚本。通过检查cron时间表实现</p></li> <li><p>cron时间表</p> <ul><li><p>cron时间表采用一种特别的格式来指定作业何时运行，格式为</p> <div class="language-sh extra-class"><pre class="language-sh"><code>min hour dayofmonth month dayofweek <span class="token builtin class-name">command</span>
</code></pre></div></li> <li><p>cron时间表允许使用**特定值、取值范围(如1~5)、通配符(*)**来指定条目</p></li> <li><p>如每天10:15运行一个命令</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token number">15</span> <span class="token number">10</span> * * * <span class="token builtin class-name">command</span>
</code></pre></div></li> <li><p>指定每周一的4:15PM执行一条命令</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token number">15</span> <span class="token number">16</span> * * <span class="token number">1</span> <span class="token builtin class-name">command</span>
</code></pre></div></li> <li><p>可使用三字符文本值(mon、tue、wed、thu、fri、sat、sun)或数值(0为周日，6为周六)指定dayofweek选项</p></li> <li><p>命令列表必须指定运行命令或脚本路径全路径名，可添加重定向、参数等</p></li> <li><p>cron会以提交用户的权限执行该命令/脚本</p></li></ul></li> <li><p>构建cron时间表</p> <ul><li><code>crontab</code>命令用于处理cron时间表，列出已有时间表使用<code>-l</code>选项</li> <li><code>-e</code>选项用于添加时间表条目</li></ul></li> <li><p>浏览cron目录</p> <ul><li>若创建的脚本对精确的执行时间要求不高，用预配置地cron脚本目录更方便</li> <li>4个基本目录：<code>hourly、daily、monthly、weekly</code></li> <li>若需要每天运行一次，则将脚本放到/etc/cron.daily目录下即可</li></ul></li> <li><p>anacron程序</p> <ul><li><p>cron程序的问题在于它假定Linux系统是7×24小时运行的</p></li> <li><p>若cron作业安排的时间已到但是系统处于关机状态，那错过的作业就不会再运行；为解决此问题引入<code>anacron</code>程序</p></li> <li><p>anacron只会处理位于cron目录的程序，如/etc/cron.monthly，用时间戳来决定作业是否再正确计划间隔内运行了</p></li> <li><p>每个cron目录都有一个时间戳文件，位于<code>/var/spool/anacron</code>下</p></li> <li><p>anacron时间表基本格式</p> <div class="language-sh extra-class"><pre class="language-sh"><code>period delay identifier <span class="token builtin class-name">command</span>
</code></pre></div></li> <li><p>period定义作业多久运行一次，以天为单位；delay指定系统重启后多少时间再执行错过的脚本</p></li> <li><p>anacron不会处理/etc/cron.hourly下的脚本，因为其不会处理执行需求小于一天的脚本</p></li></ul></li></ul></li> <li><p>使用新shell启动脚本</p> <ul><li><p>主目录下的<code>.bashrc</code>文件会在启动bash shell或登录bash shell时运行</p></li> <li><p>若需要一个脚本在两个时刻都运行，则可吧脚本放进该文件</p></li> <li><p>以每次启动一个新shell执行脚本为例</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token shebang important">#!/bin/bash</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-f</span> /etc/bashrc <span class="token punctuation">]</span>
<span class="token keyword">then</span>
	<span class="token builtin class-name">.</span> /etc/bashrc
<span class="token keyword">fi</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;I am in a new shell&quot;</span>
<span class="token function">bash</span>
<span class="token punctuation">..</span>
<span class="token builtin class-name">exit</span>
</code></pre></div></li></ul></li></ul> <h2 id="创建函数"><a href="#创建函数" class="header-anchor">#</a> 创建函数</h2> <h3 id="基本脚本函数"><a href="#基本脚本函数" class="header-anchor">#</a> 基本脚本函数</h3> <ul><li><p><strong>创建函数</strong></p> <ul><li><p>用关键字<code>function</code></p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token keyword">function</span> <span class="token function-name function">name</span><span class="token punctuation">{</span>
	commands
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>用更接近其他编程语言的形式</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function-name function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	commands
<span class="token punctuation">}</span>
</code></pre></div></li></ul></li> <li><p><strong>使用函数</strong></p> <ul><li><p>直接通过函数名调用即可</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token shebang important">#!/bin/bash</span>

<span class="token comment"># 函数定义   （注意，函数名前后均有空格）</span>
<span class="token keyword">function</span> <span class="token function-name function">func</span> <span class="token punctuation">{</span>
	<span class="token builtin class-name">echo</span> <span class="token string">&quot;Hello &quot;</span><span class="token environment constant">$USER</span>
<span class="token punctuation">}</span>

<span class="token comment"># 调用函数</span>
func
</code></pre></div></li></ul></li></ul> <h3 id="返回值"><a href="#返回值" class="header-anchor">#</a> 返回值</h3> <ul><li><p>shell把函数当作一个脚本，运行结束时返回一个退出状态码</p></li> <li><p><strong>默认退出状态码</strong></p> <ul><li>默认情况下，函数的退出状态码是其最后一条语句返回的退出状态码。函数执行后，可通过<code>$?</code>来获取该状态码</li></ul></li> <li><p><strong>使用return命令</strong></p> <ul><li><p>return命令用于退出函数并返回指定状态码</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token keyword">function</span> <span class="token function-name function">inc</span> <span class="token punctuation">{</span>
	<span class="token builtin class-name">read</span> <span class="token parameter variable">-p</span> <span class="token string">&quot;input a value: &quot;</span> value
	<span class="token builtin class-name">echo</span> <span class="token string">&quot;value++&quot;</span>
	<span class="token comment"># 加一后返回</span>
	<span class="token builtin class-name">return</span> $<span class="token punctuation">[</span> <span class="token variable">$value</span> + <span class="token number">1</span> <span class="token punctuation">]</span>
<span class="token punctuation">}</span>

inc
<span class="token builtin class-name">echo</span> <span class="token string">&quot;The value is <span class="token variable">$?</span>&quot;</span>
</code></pre></div></li> <li><p>此方法要求：</p> <ul><li>函数一结束就要取返回值</li> <li>退出状态码必须是0~255</li></ul></li></ul></li> <li><p><strong>使用函数输出</strong></p> <ul><li><p>类似于将命令的输出保存到shell变量，函数的输出也可采用同样的处理方式</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token assign-left variable">result</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>func<span class="token variable">)</span></span>
</code></pre></div></li> <li><p>示例</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token keyword">function</span> <span class="token function-name function">inc</span> <span class="token punctuation">{</span>
	<span class="token builtin class-name">read</span> <span class="token parameter variable">-p</span> <span class="token string">&quot;Input a value: &quot;</span> value
	<span class="token comment"># 此条echo并不会输出到STDOUT</span>
	<span class="token comment"># 即可将echo看作类似其他语言中的 return 语句，支持返回多种类型</span>
	<span class="token builtin class-name">echo</span> $<span class="token punctuation">[</span> <span class="token variable">$value</span> + <span class="token number">1</span> <span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token comment"># 将函数输出赋值给变量，即上述 echo的输出</span>
<span class="token assign-left variable">result</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>inc<span class="token variable">)</span></span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;result is <span class="token variable">$result</span>&quot;</span>
</code></pre></div></li> <li><p>用此方法可返回浮点值和字符串值</p></li></ul></li></ul> <h3 id="在函数中使用变量"><a href="#在函数中使用变量" class="header-anchor">#</a> 在函数中使用变量</h3> <ul><li><p><strong>向函数传递参数</strong></p> <ul><li>可以像给脚本传递参数那样给函数传递参数</li> <li>使用标准参数变量表示传递给函数的参数，如$0表示函数名，$1表示第一个参数等</li> <li>注意，因为使用同一套符号表示参数变量，因此函数并不能直接使用传递给脚本的参数。必须要在函数调用时显式传递要用的参数</li></ul></li> <li><p><strong>在函数中处理变量</strong></p> <ul><li><p>shell也分全局变量和局部变量</p></li> <li><p>使用<code>local</code>可定义局部变量，将其范围限制在函数中，避免影响外部变量</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token shebang important">#!/bin/bash</span>

<span class="token comment"># 全局变量，支持在函数内访问</span>
<span class="token assign-left variable">my_var</span><span class="token operator">=</span><span class="token number">11</span>

<span class="token keyword">function</span> <span class="token function-name function">func</span> <span class="token punctuation">{</span>
    <span class="token comment"># 定义了和外部全局变量相同的局部变量，在函数中使用该变量并不会影响到全局变量</span>
	<span class="token builtin class-name">local</span> <span class="token assign-left variable">my_var</span><span class="token operator">=</span><span class="token number">12</span>
<span class="token punctuation">}</span>
<span class="token comment"># 调用函数后，使用访问my_var变量依旧是 11 </span>
</code></pre></div></li></ul></li></ul> <h3 id="数组变量和函数"><a href="#数组变量和函数" class="header-anchor">#</a> 数组变量和函数</h3> <ul><li><p><strong>向函数传数组参数</strong></p> <ul><li><p>错误用法</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token keyword">function</span> <span class="token function-name function">test</span> <span class="token punctuation">{</span>
	<span class="token builtin class-name">echo</span> <span class="token string">&quot;The parameters are: <span class="token variable">$@</span>&quot;</span> <span class="token comment"># 输出 1</span>
	<span class="token assign-left variable">thisarray</span><span class="token operator">=</span><span class="token variable">$1</span>
	<span class="token builtin class-name">echo</span> <span class="token string">&quot;The receive array is <span class="token variable">${thisarray<span class="token punctuation">[</span>*<span class="token punctuation">]</span>}</span>&quot;</span> <span class="token comment"># 输出 1</span>
<span class="token punctuation">}</span>

<span class="token assign-left variable">myarray</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span><span class="token punctuation">)</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;origin array is <span class="token variable">${myarray<span class="token punctuation">[</span>*<span class="token punctuation">]</span>}</span>&quot;</span> <span class="token comment"># 输出 1 2 3 4 5</span>
<span class="token builtin class-name">test</span> <span class="token variable">$myarray</span>  <span class="token comment"># 将数组变量作为函数参数传递，函数只会取第一个值</span>
</code></pre></div></li> <li><p>==注意==：将数组变量作为函数参数传递，函数只会取第一个值</p></li> <li><p>正确传递方式：将数组分为单个值传递，并在函数内部重建数组</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token keyword">function</span> <span class="token function-name function">sumofarray</span> <span class="token punctuation">{</span>
	<span class="token builtin class-name">local</span> <span class="token assign-left variable">sum</span><span class="token operator">=</span><span class="token number">0</span>
	<span class="token builtin class-name">local</span> newarray
	<span class="token comment"># 从参数重建数组</span>
	<span class="token assign-left variable">newarray</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">echo</span> $@<span class="token variable">)</span></span><span class="token punctuation">)</span>
	<span class="token comment"># 遍历数组求和</span>
	<span class="token keyword">for</span> <span class="token for-or-select variable">value</span> <span class="token keyword">in</span> <span class="token variable">${newarray<span class="token punctuation">[</span>*<span class="token punctuation">]</span>}</span>
	<span class="token keyword">do</span>
		<span class="token assign-left variable">sum</span><span class="token operator">=</span>$<span class="token punctuation">[</span> <span class="token variable">$sum</span> + value <span class="token punctuation">]</span>
	<span class="token keyword">done</span>
	<span class="token comment"># 返回结果</span>
	<span class="token builtin class-name">echo</span> <span class="token variable">$sum</span>
<span class="token punctuation">}</span>

<span class="token assign-left variable">myarray</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span><span class="token punctuation">)</span>
<span class="token comment"># 注意传递数组的方式</span>
<span class="token assign-left variable">arg</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">echo</span> $<span class="token punctuation">{</span>myarray<span class="token punctuation">[</span>*<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token variable">)</span></span>
<span class="token assign-left variable">result</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>sumofarray $arg<span class="token variable">)</span></span>
</code></pre></div></li></ul></li> <li><p><strong>从函数返回数组</strong></p> <ul><li><p>与传递数组类似</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token keyword">function</span> <span class="token function-name function">test</span> <span class="token punctuation">{</span>
	<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
	<span class="token comment"># 函数返回</span>
	<span class="token builtin class-name">echo</span> <span class="token variable">${newarray<span class="token punctuation">[</span>*<span class="token punctuation">]</span>}</span>
<span class="token punctuation">}</span>

<span class="token comment"># 接收结果，重建数组</span>
<span class="token assign-left variable">result</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">test</span><span class="token variable">)</span></span><span class="token punctuation">)</span>

</code></pre></div></li></ul></li></ul> <h3 id="函数递归"><a href="#函数递归" class="header-anchor">#</a> 函数递归</h3> <ul><li><p>shell脚本函数支持递归，计算斐波那契数为例</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token keyword">function</span> <span class="token function-name function">factorial</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$1</span> <span class="token parameter variable">-eq</span> <span class="token number">1</span><span class="token punctuation">]</span>
	<span class="token keyword">then</span>
		<span class="token builtin class-name">echo</span> <span class="token number">1</span>
	<span class="token keyword">else</span>
		<span class="token builtin class-name">local</span> <span class="token assign-left variable">temp</span><span class="token operator">=</span>$<span class="token punctuation">[</span> <span class="token variable">$1</span> - <span class="token number">1</span> <span class="token punctuation">]</span>
		<span class="token builtin class-name">local</span> <span class="token assign-left variable">result</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>factorial $temp<span class="token variable">)</span></span>
		<span class="token builtin class-name">echo</span> $<span class="token punctuation">[</span> <span class="token variable">$result</span> * <span class="token variable">$1</span> <span class="token punctuation">]</span>
	<span class="token keyword">fi</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h3 id="创建库"><a href="#创建库" class="header-anchor">#</a> 创建库</h3> <ul><li><p>shell允许创建<strong>函数库文件</strong>，然后在多个脚本中引用该库文件</p></li> <li><p>首先创建一个包含脚本中所需函数的公共库文件，假设叫<code>myfuncs</code></p></li> <li><p>然后再用到这些函数的脚本文件中包含myfuncs库文件</p></li> <li><p>此处，因为函数仅在定义它的shell中有效，所以涉及到跨shell时无法调用</p></li> <li><p>使用库函数的关键在于<code>source</code>命令，其会在当前shell上下文中执行命令而不是创建一个新shell</p></li> <li><p>使用<code>source</code>命令运行库文件，如此脚本就可以使用库文件</p></li> <li><p><code>source</code>可使用点操作快速执行(<code>. 库文件</code>)，若shell脚本和库文件在同一个目录，则只需</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token builtin class-name">.</span> ./myfuncs
</code></pre></div></li> <li><p>使用库的示例</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token shebang important">#!/bin/bash</span>
<span class="token comment"># 执行库文件 等价于 source ./myfuncs</span>
<span class="token builtin class-name">.</span> ./myfuncs

<span class="token comment"># 此后就可以使用库文件中的函数</span>
</code></pre></div></li></ul> <h3 id="其他"><a href="#其他" class="header-anchor">#</a> 其他</h3> <ul><li>可在<code>.bashrc</code>中定义函数，这些函数会在启动时定义，可被其他脚本使用</li></ul> <h2 id="图形化桌面环境中的脚本编程"><a href="#图形化桌面环境中的脚本编程" class="header-anchor">#</a> 图形化桌面环境中的脚本编程</h2> <h3 id="创建文本菜单"><a href="#创建文本菜单" class="header-anchor">#</a> 创建文本菜单</h3> <ul><li><p>可以使用echo+case命令创建本文菜单</p></li> <li><p>更简单的方式是使用<code>select</code>命令</p></li> <li><p>格式</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token keyword">select</span> <span class="token for-or-select variable">variable</span> <span class="token keyword">in</span> list
<span class="token keyword">do</span>
	commands
<span class="token keyword">done</span>
</code></pre></div></li> <li><p>示例</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token shebang important">#!/bin/bash</span>

<span class="token comment"># 创建选项处理函数</span>
<span class="token keyword">function</span> <span class="token function-name function">diskspace</span> <span class="token punctuation">{</span>
	<span class="token function">clear</span>
	<span class="token function">df</span> <span class="token parameter variable">-k</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function-name function">whoseon</span> <span class="token punctuation">{</span>
	<span class="token function">clear</span>
	<span class="token function">who</span>
<span class="token punctuation">}</span>

<span class="token comment"># 改变命令提示符</span>
<span class="token assign-left variable"><span class="token environment constant">PS3</span></span><span class="token operator">=</span><span class="token string">&quot;Input Selection : &quot;</span>
<span class="token comment"># 使用select自动生成菜单</span>
<span class="token keyword">select</span> <span class="token for-or-select variable">option</span> <span class="token keyword">in</span> <span class="token string">&quot;Display disk space&quot;</span> <span class="token string">&quot;Display logged on users&quot;</span> <span class="token string">&quot;Exit&quot;</span>
<span class="token keyword">do</span>
	<span class="token keyword">case</span> <span class="token variable">$option</span> <span class="token keyword">in</span>
	<span class="token string">&quot;Exit&quot;</span><span class="token punctuation">)</span>
		<span class="token builtin class-name">break</span> <span class="token punctuation">;</span><span class="token punctuation">;</span>
	<span class="token string">&quot;Display logged on users&quot;</span><span class="token punctuation">)</span>
		whoseon <span class="token punctuation">;</span><span class="token punctuation">;</span>
	<span class="token string">&quot;Display disk space&quot;</span><span class="token punctuation">)</span>
		diskspace <span class="token punctuation">;</span><span class="token punctuation">;</span>
	*<span class="token punctuation">)</span>
		<span class="token function">clear</span>
		<span class="token builtin class-name">echo</span> <span class="token string">&quot;invalid selection&quot;</span> <span class="token punctuation">;</span><span class="token punctuation">;</span>
	<span class="token keyword">esac</span>
<span class="token keyword">done</span>
<span class="token function">clear</span>
</code></pre></div></li></ul> <h3 id="制作窗口"><a href="#制作窗口" class="header-anchor">#</a> 制作窗口</h3> <ul><li><p><strong>dialog包</strong></p> <ul><li><p>dialog包能够用ANSI转义控制字符在文本环境中创建标准的窗口对话框</p></li> <li><p>dialog命令使用命令行参数决定生成何种窗口部件</p> <table><thead><tr><th>部件</th> <th>描述</th></tr></thead> <tbody><tr><td>calendar</td> <td>提供选择日期的日历</td></tr> <tr><td>checklist</td> <td>显示多个选项（每个选项都能开和关）</td></tr> <tr><td>form</td> <td>构建带有标签即文本（可填写）的表单</td></tr> <tr><td>fselect</td> <td>提供一个文件选择窗口来浏览选择文件</td></tr> <tr><td>gauge</td> <td>显示完成的百分比进度条</td></tr> <tr><td>infobox</td> <td>显示一个消息但不用等待回应</td></tr> <tr><td>inputbox</td> <td>提供一个输入文本用的文本表单</td></tr> <tr><td>inputmenu</td> <td>提供一个可编辑的菜单</td></tr> <tr><td>menu</td> <td>显示可选的一系列选项</td></tr> <tr><td>msgbox</td> <td>显示一条消息，要求用户选择OK按钮</td></tr> <tr><td>pause</td> <td>显示一个进度条来显示暂停期间的状态</td></tr> <tr><td>passwordbox</td> <td>显示一个文本框，但会隐藏输入文本</td></tr> <tr><td>passwordform</td> <td>显示一个带标签和隐藏文本的字段的表单</td></tr> <tr><td>radiolist</td> <td>提供单选按钮</td></tr> <tr><td>tailbox</td> <td>用tail命令在滚动窗口中显示文件内容</td></tr> <tr><td>tailboxbg</td> <td>同上，但在后台模式运行</td></tr> <tr><td>textbox</td> <td>在滚动窗口中显示文件内容</td></tr> <tr><td>timebox</td> <td>提供可选择小时、分钟和秒数的窗口</td></tr> <tr><td>yesno</td> <td>提供一条带有Yes和No的简短消息</td></tr></tbody></table></li> <li><p>使用部件的命令格式</p> <div class="language-sh extra-class"><pre class="language-sh"><code>dialog <span class="token parameter variable">--widget</span> parameters
</code></pre></div></li> <li><p>每个dialog提供了两种输出</p> <ul><li>STDERR</li> <li>退出状态码</li></ul></li> <li><p>可根据退出状态码确定用户选择的按钮。如YES和OK的为1，NO和CANCEL为1</p></li> <li><p>若返回数据，则会将数据发送到STDERR，可重定向得到</p> <div class="language-sh extra-class"><pre class="language-sh"><code>dialog <span class="token parameter variable">--inputbox</span> <span class="token string">&quot;enter your age: &quot;</span> <span class="token number">10</span> <span class="token number">20</span> <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>age.txt
</code></pre></div></li></ul></li> <li><p><strong>常用部件</strong></p> <ul><li><p>msgbox</p> <ul><li><p>格式</p> <div class="language-sh extra-class"><pre class="language-sh"><code>dialog <span class="token parameter variable">--msgbox</span> text height width
</code></pre></div></li> <li><p>可使用<code>--title</code>放置标题
<img src="/shell-pic/image-20211102111930921.png" alt="image-20211102111930921"></p></li></ul></li> <li><p>yesno</p> <ul><li><p>类似msgbox，底部提供YES、NO两个选项。通过<code>$?</code>可判断用户选择Yes(0)还是NO(1)</p> <div class="language-sh extra-class"><pre class="language-sh"><code> dialog <span class="token parameter variable">--title</span> WARNING <span class="token parameter variable">--yesno</span> <span class="token string">&quot;Are you sure ?&quot;</span> <span class="token number">60</span> <span class="token number">50</span><span class="token punctuation">;</span><span class="token builtin class-name">echo</span> <span class="token variable">$?</span>
</code></pre></div><p><img src="/shell-pic/image-20211102112533961.png" alt="20211102112533961"></p></li></ul></li> <li><p>inputbox</p> <ul><li><p>会将输入的文本发送给STDERR</p> <div class="language-sh extra-class"><pre class="language-sh"><code>dialog <span class="token parameter variable">--inputbox</span> <span class="token string">&quot;Input your age :&quot;</span> <span class="token number">10</span> <span class="token number">20</span> <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>age.txt
</code></pre></div><p><img src="/shell-pic/image-20211102112915894.png" alt="20211102112915894"></p></li></ul></li> <li><p>textbox</p> <ul><li><p>用于在窗口中显示大量信息，会生成滚动窗口</p> <div class="language-sh extra-class"><pre class="language-sh"><code>dialog <span class="token parameter variable">--textbox</span> /etc/passwd <span class="token number">15</span> <span class="token number">30</span>
</code></pre></div><p><img src="/shell-pic/image-20211102113125561.png" alt="20211102113125561"></p></li></ul></li> <li><p>menu</p> <ul><li><p>可用于创建文本菜单窗口版</p></li> <li><p>需要为每个选项提供一个标号</p> <div class="language-sh extra-class"><pre class="language-sh"><code>dialog <span class="token parameter variable">--menu</span> <span class="token string">&quot;My Menu&quot;</span> <span class="token number">40</span> <span class="token number">50</span> <span class="token number">10</span> <span class="token number">1</span> <span class="token string">&quot;display name&quot;</span> <span class="token number">2</span> <span class="token string">&quot;diaplay user&quot;</span> <span class="token number">3</span> <span class="token string">&quot;exit&quot;</span> <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>test.txt
</code></pre></div></li> <li><p>参数说明</p> <ul><li>菜单名 高 宽 一次显示菜单数量 菜单标号 菜单项名称....</li></ul> <p><img src="/shell-pic/image-20211102113731008.png" alt="20211102113731008"></p></li></ul></li> <li><p>fselect</p> <ul><li><p>不用强制用户键入文件名就可用fselect浏览文件的位置并选择文件</p> <div class="language-sh extra-class"><pre class="language-sh"><code>dialog <span class="token parameter variable">--title</span> <span class="token string">&quot;select a file&quot;</span> <span class="token parameter variable">--fselect</span> <span class="token environment constant">$HOME</span>/ <span class="token number">10</span> <span class="token number">50</span> <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>file.txt
</code></pre></div><p><img src="/shell-pic/image-20211102114125574.png" alt="20211102114125574"></p></li> <li><p>用空格选择文件</p></li></ul></li></ul></li> <li><p><strong>dialog选项</strong></p> <ul><li><p>可用选项表</p> <table><thead><tr><th>选项</th> <th>描述</th></tr></thead> <tbody><tr><td>--add-widget</td> <td>继续下个对话框，直到按下Esc或Cancel</td></tr> <tr><td>--aspect ratio</td> <td>指定窗口宽高比</td></tr> <tr><td>--backtitle title</td> <td>指定显示在屏幕顶部背景上的标题</td></tr> <tr><td>--begin x y</td> <td>指定窗口左上角起始位置</td></tr> <tr><td>--cancel-label label</td> <td>指定cancel按钮标签</td></tr> <tr><td>--clear</td> <td>用默认对话背景色来清空屏幕</td></tr> <tr><td>--colors</td> <td>在对话文本中嵌入ANSI色彩编码</td></tr> <tr><td>--cr-wrap</td> <td>在对话文本中允许使用换行符并强制换行</td></tr> <tr><td>--create-rc file</td> <td>将示例配置文件的内容复制到指定的file文件中</td></tr> <tr><td>--defaultno</td> <td>将yesno对话框的默认选项置为 no</td></tr> <tr><td>--default-item string</td> <td>设定复选列表、表单或菜单对话框中的默认选项</td></tr> <tr><td>--exit-label label</td> <td>指定exit按钮标签</td></tr> <tr><td>--extra-button</td> <td>在ok和cancel之间显示一个额外按钮</td></tr> <tr><td>--extra-label label</td> <td>指定额外按钮的标签</td></tr> <tr><td>--help</td> <td>显示dialog命令帮助</td></tr> <tr><td>--help-label label</td> <td>指定help按钮标签</td></tr> <tr><td>--help-status</td> <td>当选定help按钮后，在帮助信息后写入多选列表、单选列表或表单信息</td></tr> <tr><td>--ignore</td> <td>忽略dialog不能识别的选项</td></tr> <tr><td>--input-fd fd</td> <td>指定STDIN外的另一个文件描述符</td></tr> <tr><td>--insecure</td> <td>在password组件输入时显示星号</td></tr> <tr><td>--item-help</td> <td>为多选列表、单列表、菜单中的每个标号在屏幕底部添加一个帮助栏</td></tr> <tr><td>--keep-window</td> <td>不清楚屏幕上显示过的部件</td></tr> <tr><td>--max-input size</td> <td>指定输出的最大长度，默认2048</td></tr> <tr><td>--nocancel</td> <td>隐藏cancel按钮</td></tr> <tr><td>--no-collapse</td> <td>不将对话文本中的制表符换成空格</td></tr> <tr><td>--no-kill</td> <td>将tailboxbg对话放入后台，并禁止进程的SIGHUP信号</td></tr> <tr><td>--no-label label</td> <td>为no按钮指定标签</td></tr> <tr><td>--no-shadow</td> <td>不显示对话框阴影效果</td></tr> <tr><td>--ok-label label</td> <td>指定ok按钮标签</td></tr> <tr><td>--output-fd fd</td> <td>制定除了STDERR外的另一个输出文件描述符</td></tr> <tr><td>--print-maxsize</td> <td>将对话窗口的最大尺寸打印到输出中</td></tr> <tr><td>--print-size</td> <td>将每个对话窗口的大小打印到输出中</td></tr> <tr><td>--print-version</td> <td>将dialog版本打印到输出中</td></tr> <tr><td>--separate-output</td> <td>一次一行地输出checklist部件的结果，不使用引号</td></tr> <tr><td>--separator string</td> <td>指定分隔部件输出字符</td></tr> <tr><td>--separate-widget string</td> <td>同上</td></tr> <tr><td>--shadow</td> <td>启用窗口阴影</td></tr> <tr><td>--single-quoted</td> <td>需要时对多选列表输出采用单引号</td></tr> <tr><td>--sleep sec</td> <td>处理完对话窗口后的延迟秒数</td></tr> <tr><td>--stderr</td> <td>将输出发送到STDERR（默认）</td></tr> <tr><td>--stdout</td> <td>将输出发送到STDOUT</td></tr> <tr><td>--tab-correct</td> <td>将制表符换成空格</td></tr> <tr><td>--tab-len</td> <td>指定一个制表符占用空格数（默认8）</td></tr> <tr><td>--timeout sec</td> <td>用户无输入超时退出时间</td></tr> <tr><td>--title title</td> <td>指定窗口标题</td></tr> <tr><td>--trim</td> <td>从对话文本中深处前导空格和换行符</td></tr> <tr><td>--visit-items</td> <td>修改对话窗口中制表符停留位置，使其包括选项列表</td></tr> <tr><td>--yes-label label</td> <td>指定yes按钮标签</td></tr></tbody></table></li></ul></li></ul> <h3 id="gnome环境使用图形"><a href="#gnome环境使用图形" class="header-anchor">#</a> GNOME环境使用图形</h3> <ul><li><p>GNOME图形化环境支持两种主流可生成标准窗口的包</p> <ul><li>gdialog</li> <li>zenity</li></ul></li> <li><p>zenity部件</p> <table><thead><tr><th>部件</th> <th>作用</th></tr></thead> <tbody><tr><td>--calendar</td> <td>显示一整月日历</td></tr> <tr><td>--entry</td> <td>显示文本输入对话窗口</td></tr> <tr><td>--error</td> <td>显示错误消息对话窗</td></tr> <tr><td>--file-selection</td> <td>显示完整的路径名和文件名对话窗口</td></tr> <tr><td>--info</td> <td>显示信息对话窗口</td></tr> <tr><td>--list</td> <td>显示多选列表或单选列表对话框</td></tr> <tr><td>--notification</td> <td>显示通知图标</td></tr> <tr><td>--progress</td> <td>显示进度条对话窗口</td></tr> <tr><td>--question</td> <td>显示yes no对话窗口</td></tr> <tr><td>--scale</td> <td>显示可调整大小的窗口</td></tr> <tr><td>--text-info</td> <td>显示含有文本的文本框</td></tr> <tr><td>--warning</td> <td>显示警告对话窗口</td></tr></tbody></table></li> <li><p>命令格式</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">zenity</span> <span class="token parameter variable">--option</span>
</code></pre></div></li> <li><p>zenity的输出在STDOUT中</p></li></ul> <h2 id="初识sed和gawk"><a href="#初识sed和gawk" class="header-anchor">#</a> 初识sed和gawk</h2> <h3 id="文本处理"><a href="#文本处理" class="header-anchor">#</a> 文本处理</h3> <ul><li><p>sed和gawk能够轻松实现自动格式化、插入、修改或删除文本元素</p></li> <li><p><strong>sed编辑器</strong></p> <ul><li><p>sed编辑器被称作流编辑器（stream editor），和交互式文本编辑器恰好相反，在交互式文本编辑器中，可以用键盘命令来交互式插入、删除或替换文本。流编辑器则会在编辑器<strong>处理数据之前基于预先提供的一组规则来编辑数据流</strong></p></li> <li><p>sed编辑器可根据命令来处理数据流中的数据，这些命令可从命令行输入，也可存储在文件中</p></li> <li><p>sed会执行以下操作</p> <ul><li>一次从输入中读取一行数据</li> <li>根据所提供命令匹配数据</li> <li>按照命令修改流中的数据</li> <li>将新的数据输出到STDOUT</li></ul></li> <li><p>sed命令格式</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">sed</span> options script <span class="token function">file</span>
</code></pre></div></li> <li><p>可用选项</p> <table><thead><tr><th>选项</th> <th>作用</th></tr></thead> <tbody><tr><td>-e script</td> <td>处理输入时，将script中指定的命令添加到已有命令中</td></tr> <tr><td>-f file</td> <td>处理输入时，将file中指定的命令添加到已有命令中</td></tr> <tr><td>-n</td> <td>不产生命令输出，使用print命令完成输出</td></tr></tbody></table></li> <li><p>script参数指定应用于数据流上的单个命令，可用-e在命令行中附加或-f从文件中读取命令</p></li></ul> <ol><li><p>在命令行定义编辑命令</p> <ul><li><p>默认sed将指定命令应用到STDIN输入流，可通过管道输入sed编辑器处理</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token builtin class-name">echo</span> <span class="token string">&quot;This is a test&quot;</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/test/big test/'</span>
</code></pre></div></li> <li><p>上例sed使用<code>s</code>命令，s命令会用斜线间指定的第二个文本字符串来替换第一个文本字符串模式（类似vim）</p></li> <li><p>编辑整个文件的速度也十分快</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">sed</span> <span class="token string">'s/dog/cat'</span> data.txt
</code></pre></div></li> <li><p>==注意==：sed并不会修改源文件，只是将修改后的结果通过STDOUT输出</p></li></ul></li> <li><p>在命令行使用多个编辑命令</p> <ul><li><p>使用<code>-e</code>选项</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># 命令间用分号隔开，分号和命令末尾不能有空格</span>
<span class="token function">sed</span> <span class="token parameter variable">-e</span> <span class="token string">'s/brown/green/; s/dog/cat/'</span> data.txt
</code></pre></div></li> <li><p>也可使用bash次提示符</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">sed</span> <span class="token parameter variable">-e</span> <span class="token string">'
&gt;s/brown/green/
&gt;s/dog/cat/'</span> data.txt
</code></pre></div></li></ul></li> <li><p>从文件中读取编辑器命令</p> <ul><li><p>可在文件中指定命令，用<code>-f</code>选项应用</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># script.sed内容</span>
s/brown/green/
s/dog/cat/

<span class="token comment"># 使用script.sed</span>
<span class="token function">sed</span> <span class="token parameter variable">-f</span> script.sed data.txt
</code></pre></div></li></ul></li></ol></li> <li><p><strong>gawk程序</strong></p> <ul><li>gawk提供了一个类编程环境来修改和重新组织文件中的数据</li> <li>在gawk中，提供了一种编程语言而不是编辑器命令。可
<ul><li>定义变量保存数据</li> <li>使用算术和字符串操作符来处理数据</li> <li>使用结构化编程概念(如if-then)来为处理数据增加逻辑</li> <li>通过提取数据文件中的数据元素将其重新排列或格式化，生成格式化报告</li></ul></li></ul> <ol><li><p>gawk命令格式</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">gawk</span> options program <span class="token function">file</span>
</code></pre></div><ul><li>可用选项</li></ul> <table><thead><tr><th>选项</th> <th>作用</th></tr></thead> <tbody><tr><td>-F fs</td> <td>指定行中划分数据字段的字符</td></tr> <tr><td>-f file</td> <td>从文件中读取程序</td></tr> <tr><td>-v var=value</td> <td>定义gawk程序中的一个变量</td></tr> <tr><td>-mf N</td> <td>指定要处理的数据文件中的最大字段数</td></tr> <tr><td>-mr N</td> <td>指定数据文件中的最大数据行数</td></tr> <tr><td>-W keyword</td> <td>指定gawk的兼容模式或警告等级</td></tr></tbody></table></li> <li><p>从命令行读取程序脚本</p> <ul><li><p>用一对花括号定义程序脚本。脚本需要放在单引号中</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">gawk</span> <span class="token string">'{print &quot;hello world&quot;}'</span>
</code></pre></div></li></ul></li> <li><p>使用数据字段变量</p> <ul><li><p>默认gawk将如下变量分配给它在文本行中发现的数据字段</p> <table><thead><tr><th>变量</th> <th>含义</th></tr></thead> <tbody><tr><td>$0</td> <td>代表整个文本行</td></tr> <tr><td>$1</td> <td>代表文本行中的第一个数据字段</td></tr> <tr><td>$2</td> <td>代表文本行中的第二个数据字段</td></tr> <tr><td>$n</td> <td>代表文本行中的第n个数据字段</td></tr></tbody></table></li> <li><p>字段是通过<strong>字段分隔符</strong>划分的，默认为任意的空白字符，如空格、制表符等</p></li> <li><p>读取并显示第一个数据字段示例</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">cat</span> data.txt
first line of <span class="token builtin class-name">test</span>
second line of <span class="token builtin class-name">test</span>
third line of <span class="token builtin class-name">test</span>

<span class="token function">gawk</span> <span class="token string">'{print $1}'</span> data.txt
</code></pre></div></li> <li><p><code>-F</code>选项允许指定分隔符</p></li></ul></li> <li><p>程序脚本中使用多个命令</p> <ul><li>在命令之间用分号隔开即可指定多条命令</li></ul></li> <li><p>从文件中读取程序</p> <ul><li><p><code>-f</code>选项可指定程序文件</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">cat</span> script.gawk
<span class="token punctuation">{</span>print <span class="token variable">$1</span> <span class="token string">&quot;'s home directory is &quot;</span> <span class="token variable">$6</span><span class="token punctuation">}</span>

<span class="token function">gawk</span> -F: <span class="token parameter variable">-f</span> script.gawk /etc/passwd
</code></pre></div></li> <li><p>命令中可使用<code>var=value</code>形式定义变量，使用时无须像shell脚本一样使用$符号</p></li></ul></li> <li><p>在数据处理前运行脚本</p> <ul><li><p>有时需要gawk在读取数据处理前运行某个命令，比如为报告创建标题，此时<code>BEGIN</code>关键字可实现该功能</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># 正式处理数据的代码定义在第二块中</span>
<span class="token function">gawk</span> <span class="token string">'BEGIN {print &quot;The data.txt contains：&quot;} {print $0}'</span> data.txt
</code></pre></div></li></ul></li> <li><p>处理数据后运行脚本</p> <ul><li>类似处理前运行脚本，可在最后使用<code>END</code>关键字定义处理数据后运行的脚本</li> <li>PS：gwak在脚本文件中定义<code>FS</code>变量可指定字段分隔符</li></ul></li></ol></li></ul> <h3 id="sed编辑器基础"><a href="#sed编辑器基础" class="header-anchor">#</a> sed编辑器基础</h3> <ul><li><p><strong>更多替换选项</strong></p> <ul><li><p><code>s</code>命令(substitude)用于在行中替换文本，此命令还有一些额外的选项</p></li> <li><p>替换标记</p> <ul><li>s替换命令<strong>默认只替换每行出现的第一处</strong>，可使用替换标记指定替换的位置。替换标记放在命令字符串斜线后</li> <li>四种标记</li></ul> <table><thead><tr><th>标记</th> <th>作用</th></tr></thead> <tbody><tr><td>数字</td> <td>新文本将替换第几处模式匹配的地方</td></tr> <tr><td>g</td> <td>新文本将会替换所有匹配文本</td></tr> <tr><td>p</td> <td>原先行的内容要打印出来。通常和-n选项连用，只输出替换后的行</td></tr> <tr><td>w file</td> <td>将替换结果写到文件中</td></tr></tbody></table></li> <li><p>替换字符</p> <ul><li><p>当涉及到<code>/</code>等字符的替换时比较麻烦，sed允许使用其他字符用作字符串分隔符</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># 改用!作为分隔符，可以不对 / 使用转义符</span>
<span class="token function">sed</span> <span class="token string">'s!/bin/bash!/bin/csh'</span> /etc/passwd
</code></pre></div></li></ul></li></ul></li> <li><p><strong>使用地址</strong></p> <ul><li><p>默认sed命令会作用于所有的行，可使用<strong>行寻址</strong>作用于特定行或某些行</p></li> <li><p>sed编辑器中的两种形式寻址</p> <ul><li>数字形式表示行区间</li> <li>文本模式过滤行</li></ul></li> <li><p>两种形式格式相同</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token punctuation">[</span>address<span class="token punctuation">]</span>command
</code></pre></div></li> <li><p>可将特定地址的多个命令分组</p> <div class="language-sh extra-class"><pre class="language-sh"><code>address <span class="token punctuation">{</span>
	command1
	command2
	command3
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <ol><li><p>数字方式寻址</p> <ul><li><p>指定单个行号</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">sed</span> <span class="token string">'2s/dog/cat/'</span> data.txt
</code></pre></div></li> <li><p>指定区间</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">sed</span> <span class="token string">'2,3s/dog/cat/'</span> data.txt
</code></pre></div></li> <li><p>指定某行开始的所有行</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">sed</span> <span class="token string">'2,$s/dog/cat/'</span> data.txt
</code></pre></div></li></ul></li> <li><p>文本模式过滤器</p> <ul><li><p>格式</p> <div class="language-sh extra-class"><pre class="language-sh"><code>/pattern/command
</code></pre></div></li> <li><p>示例，只修改TestUser的默认shell</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># 在最前指定匹配过滤模式串。可使用正则表达式。该替换只会作用于匹配的行上</span>
<span class="token function">sed</span> <span class="token string">'/TestUser/s/bash/csh'</span> /etc/passwd
</code></pre></div></li></ul></li> <li><p>命令组合</p> <ul><li><p>单行上应用多条命令，在地址后用花括号指定</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">sed</span> <span class="token string">'2{
&gt;s/fox/cat/
&gt;s/mouse/dog/
&gt;}'</span> data.txt
</code></pre></div></li> <li><p>也可指定区间，见 1 数字寻址</p></li></ul></li></ol></li> <li><p><strong>删除行</strong></p> <ul><li><p>除了替换命令<code>s</code>，可使用<code>d</code>命令删除行</p></li> <li><p>删除所有行</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">sed</span> <span class="token string">'d'</span> data.txt
</code></pre></div></li> <li><p>使用地址删除指定行</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># 删除2-4行</span>
<span class="token function">sed</span> <span class="token string">'2,4d'</span> data.txt
</code></pre></div></li> <li><p>也可使用<strong>两个文本模式</strong>来删除某个区间内的行。第一个模式会打开删除功能，第二个会关闭删除功能，该操作删除两个模式匹配的行之间的内容。若重新又匹配到第一个模式而没有第二个模式结尾，则会删除之后的所有内容</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># 删除匹配了1 和匹配了3 行之间的行</span>
<span class="token function">sed</span> <span class="token string">'/1/,/3/d'</span> data.txt
</code></pre></div></li></ul></li> <li><p><strong>插入和附加文本</strong></p> <ul><li><p>两个操作</p> <ul><li>插入(insert)命令<code>i</code>会在指定行前增加一个新行</li> <li>附加(append)命令<code>a</code>会在指定行后增加一个新行</li></ul></li> <li><p>格式</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">sed</span> <span class="token string">'[address]command\newline'</span>
</code></pre></div></li> <li><p>在在数据流前增加一行</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token builtin class-name">echo</span> <span class="token string">&quot;test line 1&quot;</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'i\new line'</span>
</code></pre></div></li> <li><p>不能指定区间</p></li></ul></li> <li><p><strong>修改行</strong></p> <ul><li><p>修改(change)命令<code>c</code>允许修改数据流中整行文本内容，和插入和附加机制类似</p></li> <li><p>修改指定行</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">sed</span> <span class="token string">'3c\this is a new line'</span> data.txt
</code></pre></div></li> <li><p>可以指定区间，但只会讲该区间所有内容用指定内容替换</p></li></ul></li> <li><p><strong>转换命令</strong></p> <ul><li><p>转换(transform)命令<code>y</code>是唯一可以处理单个字符的sed编辑器命令</p></li> <li><p>格式</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token punctuation">[</span>address<span class="token punctuation">]</span>y/inchars/outchars
</code></pre></div></li> <li><p>转换命令会对inchars和outchars进行一对一映射，inchars中的第一个字符会被转换为outchars中的第一个字符，按照此规则映射完所有</p></li> <li><p>示例</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">sed</span> <span class="token string">'y/123/789'</span> data.txt
</code></pre></div></li> <li><p>转换命令是一个全局命令，只要找到就会替换而不管位置，也无法限定只替换某处</p></li></ul></li> <li><p><strong>回顾打印</strong></p> <ul><li><p>三个用于打印数据流信息的命令</p> <ul><li>p命令用来打印文本行</li> <li>等号(=)用于打印行号</li> <li>l用于列出行</li></ul></li> <li><p>打印行</p> <ul><li><p>和替换命令中的p类似，p命令可打印sed输出的一行</p></li> <li><p>快速打印某些行</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># 指定区域</span>
<span class="token function">sed</span> <span class="token parameter variable">-n</span> <span class="token string">'2,3p'</span> data.txt
<span class="token comment"># 指定匹配模式</span>
<span class="token function">sed</span> <span class="token parameter variable">-n</span> <span class="token string">'/partten/p'</span> data.txt
</code></pre></div></li></ul></li> <li><p>打印行号</p> <ul><li><p>查找指定匹配模式的行</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">sed</span> <span class="token parameter variable">-n</span> <span class="token string">'/number 4/{
&gt;=
&gt;p
&gt;}'</span> data.txt
</code></pre></div></li></ul></li> <li><p>列出行</p> <ul><li><p><code>l</code>命令可以打印数据流中的文本和不可打印字符，不可打印字符要么使用8禁止值加斜线，要么采用标准c风格命名法，如\t表示制表符。行尾美元符号表示换行</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">sed</span> <span class="token parameter variable">-n</span> <span class="token string">'l'</span> data.txt
</code></pre></div></li></ul></li></ul></li> <li><p><strong>用sed处理文件</strong></p> <ol><li><p>写入文件</p> <ul><li><p><code>w</code>命令可用于像文件写入行，格式为</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token punctuation">[</span>address<span class="token punctuation">]</span>w filename
</code></pre></div></li> <li><p>将某个文件某个行区间内的数据写到另一个文件</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">sed</span> <span class="token string">'1,2w test.txt'</span> data.txt
</code></pre></div></li></ul></li> <li><p>从文件读取数据</p> <ul><li><p>读取(read)命令<code>r</code>允许将一个独立文件中的数据插入到数据流中</p></li> <li><p>格式</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token punctuation">[</span>address<span class="token punctuation">]</span> r filename
</code></pre></div></li> <li><p>address只能指定单独行号和文本匹配模式</p></li> <li><p>将某个文件所有内容插入到指定位置</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">sed</span> <span class="token string">'3r from.txt'</span> to.txt
</code></pre></div></li></ul></li></ol></li></ul> <h2 id="正则表达式"><a href="#正则表达式" class="header-anchor">#</a> 正则表达式</h2> <h3 id="正则表达式简述"><a href="#正则表达式简述" class="header-anchor">#</a> 正则表达式简述</h3> <ul><li>Linux中两种主流正则表达式引擎
<ul><li>POSIX基础正则表达式(basic regular expression,BRE)引擎</li> <li>POSIX扩展正则表达式(extended regular expression,ERE)引擎</li></ul></li></ul> <h3 id="定义bre模式"><a href="#定义bre模式" class="header-anchor">#</a> 定义BRE模式</h3> <ul><li><p><strong>特殊字符</strong></p> <ul><li>特殊字符包括：<code>.*[]^${}\+?|()</code></li></ul></li> <li><p><strong>锚字符</strong></p> <ul><li>行首：脱字符(<code>^</code>)匹配行首，当且仅当放在行首是才匹配行首，放在其他位置当作一般字符处理</li> <li>行尾：美元符(<code>$</code>)匹配行尾，</li> <li>组合锚字符：将两个锚字符组合在一起(<code>^$</code>)中间不加内容可过滤空行</li></ul></li> <li><p><strong>点号字符</strong></p> <ul><li><code>.</code>用于匹配除换行符之外的任意单个字符</li></ul></li> <li><p><strong>字符组</strong></p> <ul><li><code>[]</code>定义一个字符组，只要括号中有一个字符匹配则成立。如<code>[abc]</code>匹配字符a、b或c</li></ul></li> <li><p><strong>排除型字符组</strong></p> <ul><li>在中括号中加上脱字符<code>^</code>，可实现匹配除了中括号中字符的模式。如<code>[^abc]</code>表示除了a、b、c外的字符</li></ul></li> <li><p><strong>区间</strong></p> <ul><li>使用单破折线符号在字符组中表示字符区间，如<code>[a-z]</code>表示小写字母a到z</li> <li>可在括号内指定多个区间，如<code>[a-fr-x]</code></li></ul></li> <li><p><strong>特殊的字符组</strong></p> <ul><li>特殊字符组表</li></ul> <table><thead><tr><th>组</th> <th>描述</th></tr></thead> <tbody><tr><td>[[:alpha:]]</td> <td>匹配任意字母字符，不关大小写</td></tr> <tr><td>[[:alnum:]]</td> <td>匹配任意字母和数字字符0~9，A~Z或a~z</td></tr> <tr><td>[[:blank:]]</td> <td>匹配空格或制表符</td></tr> <tr><td>[[:digit:]]</td> <td>匹配0~9的数字</td></tr> <tr><td>[[:lower:]]</td> <td>匹配小写字母a~z</td></tr> <tr><td>[[:print:]]</td> <td>匹配任意可打印字符</td></tr> <tr><td>[[:punct:]]</td> <td>匹配标点符号</td></tr> <tr><td>[[:space:]]</td> <td>匹配空白字符：空格、制表符、NL、FF、VT和CR</td></tr> <tr><td>[[:upper:]]</td> <td>匹配任意大写字母A~Z</td></tr></tbody></table></li> <li><p><strong>星号(*)</strong></p> <ul><li>放在某个字符之后表示该字符出现 0 次或多次</li> <li><code>.*</code>组合可以匹配任意数量的任意字符</li></ul></li></ul> <h3 id="扩展正则表达式-ere"><a href="#扩展正则表达式-ere" class="header-anchor">#</a> 扩展正则表达式（ERE）</h3> <ul><li>gawk支持ERE，而sed不支持ERE</li> <li><strong>问号(?)</strong> <ul><li>放在某个字符后表示该字符可能出现0次或1次</li></ul></li> <li><strong>加号(+)</strong> <ul><li>放在某个字符后表示该字符可能出现1次或多次</li></ul></li> <li><strong>使用花括号</strong> <ul><li>使用花括号允许为可重复的正则表达式指定重复次数区间</li> <li><code>{m}</code>表示该表达式准确出现m次</li> <li><code>{m,n}</code>表示该表达式至少出现m次，至多出现n次</li> <li>默认gawk不支持这种语法，需要添加<code>--re-interval</code>选项才能正确识别</li></ul></li> <li><strong>管道符号(|)</strong> <ul><li>管道符号起到逻辑“或”的功能，指定表达式只要匹配一个即可通过</li> <li>格式为：<code>exp1|exp2|...</code></li></ul></li> <li><strong>表达式分组</strong> <ul><li>使用小括号可对表达式进行分组，分组后可以应用如问号、星号等扩展语法</li></ul></li></ul> <h2 id="sed进阶"><a href="#sed进阶" class="header-anchor">#</a> sed进阶</h2> <h3 id="多行命令"><a href="#多行命令" class="header-anchor">#</a> 多行命令</h3> <ul><li><p>此前所有的sed编辑器命令都是<strong>针对单行数据执行操作</strong>，sed读取数据流时会基于换行符将数据分割为行</p></li> <li><p>sed包含三个命令用于处理多行文本</p> <ul><li><code>N</code>：将数据流中的下一行加进来创建一个多行组进行处理</li> <li><code>D</code>：删除多行组中的一行</li> <li><code>P</code>：打印多行组中的一行</li></ul></li> <li><p><code>next</code>命令</p> <ol><li><p>单行的next命令</p> <ul><li><p><code>n</code>命令告诉sed移动到数据流中的下一行，而不用处理当前行</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">cat</span> data.txt
this is first line

this is data

this is last line

<span class="token comment"># 需要对上述文件进行删除首行后的空行，并保留末行前的空行操作</span>
<span class="token function">sed</span> <span class="token string">'/first/{n ; d} data.txt'</span>

<span class="token comment"># 上述命令先匹配first的第一行，然后 n 移动到下一行，执行删除命令 d</span>
</code></pre></div></li> <li><p>==注意==：同一个位置使用多个命令时，用大括号括起来，并用分号分隔命令</p></li></ul></li> <li><p>合并文本</p> <ul><li><p>多行版next命令(<code>N</code>)会将下一行的文本和当前行的文本放在一起进行操作，两行文本之间仍有换行符</p></li> <li><p>示例：合并下一行到当前行</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">cat</span> data.txt
first line.
second line.
third line.
fourth line.

<span class="token comment"># 匹配到 second行，然后将third加入，然后去掉换行符</span>
<span class="token function">sed</span> <span class="token string">'/second/{N ; s/\n/ /} data.txt'</span>
<span class="token comment"># 结果是 second 和 third 在同一行</span>
</code></pre></div></li> <li><p>对于需要跨行查找短语十分有用</p></li></ul></li></ol></li> <li><p><strong>多行删除命令</strong></p> <ul><li>若将多行命令(<code>N</code>)与单行删除命令(<code>d</code>)连用，可能导致两行都被删除</li> <li>多行删除命令(<code>D</code>)只删除多行模式空间中的第一行，删除到换行符为止</li></ul></li> <li><p><strong>多行打印命令</strong></p> <ul><li>多行打印命令<code>P</code>只会打印模式空间中的第一行</li></ul></li></ul> <h3 id="保持空间"><a href="#保持空间" class="header-anchor">#</a> 保持空间</h3> <ul><li><p><strong>模式空间</strong>是一块活跃的缓冲区，存放sed待处理的一行或多行文本</p></li> <li><p>sed有另外一块称作<strong>保持空间</strong>的缓冲区，在处理模式空间中的某些行时，可用保持空间临时保存一些行</p></li> <li><p>保存空间操作的命令表</p> <table><thead><tr><th>命令</th> <th>描述</th></tr></thead> <tbody><tr><td>h</td> <td>将模式空间复制到保持空间</td></tr> <tr><td>H</td> <td>将模式空间附加到保持空间</td></tr> <tr><td>g</td> <td>将保持空间复制到模式空间</td></tr> <tr><td>G</td> <td>将保持空间附加到模式空间</td></tr> <tr><td>x</td> <td>交换模式空间和保持空间的内容</td></tr></tbody></table></li> <li><p>通常h和g选项都是连用的，使用示例</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">cat</span> data.txt
the header line
the first line
the second line
the last line

<span class="token function">sed</span> <span class="token parameter variable">-n</span> <span class="token string">'/first/{h;p;n;p;g;p}'</span> data.txt
the first line
the second line
the first line
</code></pre></div></li> <li><p>上述命令执行过程</p> <ul><li>匹配到first行</li> <li>h命令将first行复制到保持空间</li> <li>打印first行</li> <li>n命令移动到下一行（second行）</li> <li>打印second行</li> <li>g命令将保持空间内容复制到模式空间</li> <li>打印刚复制过来的行（之前h命令赋值的first行）</li></ul></li></ul> <h3 id="排除命令"><a href="#排除命令" class="header-anchor">#</a> 排除命令</h3> <ul><li><p>排除命令(<code>!</code>)用来让原本会起作用的命令不起作用，即指定命令不作用的特定地址或地址区间</p></li> <li><p>如指定匹配某条件的行不打印</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># 处理匹配 header 的行都打印</span>
<span class="token function">sed</span> <span class="token parameter variable">-n</span> <span class="token string">'/header/!p'</span> data.txt
</code></pre></div></li> <li><p>反转文本行</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">sed</span> <span class="token parameter variable">-n</span> <span class="token string">'{1!G;h;$p}'</span> data.txt
</code></pre></div></li> <li><p>上述命令解析</p> <ul><li>对每一行（除了首行），都将保持空间的内容附加（不覆盖）到该行后</li> <li>附加后，再将模式空间拷贝到保持空间（覆盖）</li> <li>最后<code>$p</code>表示要到data.txt的最后一行时才执行输出操作</li> <li>重复上述1、2步后，最后得到的就是行反转后的结果，因此只在最后一行输出得到最终结果</li></ul></li> <li><p>==补充==：<code>tac</code>（cat翻转）命令会倒序显示一个文本文件</p></li></ul> <h3 id="改变流"><a href="#改变流" class="header-anchor">#</a> 改变流</h3> <ul><li><p>sed提供了一些方法改变命令执行流程，类似结构化编程</p></li> <li><p><strong>分支</strong></p> <ul><li><p>分支(branch)命令<code>b</code>可基于地址、地址模式或地址区间排除一整块命令</p></li> <li><p>格式</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token punctuation">[</span>address<span class="token punctuation">]</span>b <span class="token punctuation">[</span>label<span class="token punctuation">]</span>
</code></pre></div></li> <li><p>address指定哪些行的数据会触发分支命令，label参数指定要跳转到的位置，若没有label，跳转到脚本结尾</p></li> <li><p>示例</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">sed</span> <span class="token string">'{2,3b ; s/This is/Is this/ ; s/line./test?/}'</span> data.txt
</code></pre></div><ul><li>上述命令在第2、3行时触发分支，因为没有label，直接跳到脚本结尾，即跳过后边的两个替换命令</li></ul></li> <li><p>指定标签的分支</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">sed</span> <span class="token string">'{/first/b jump1 ; s/This is/No jump/ ; :jump1 ; s/This is/Jump here/}'</span> data.txt
</code></pre></div><ul><li>上述命令在 b 后边指定要跳转的位置，并在后边使用<code>:label</code>的格式定义跳转的标签，执行该命令会在匹配到first行时跳到标签位置处继续执行，即跳过脚本的第一个替换命令</li></ul></li> <li><p>分支可以跳转到前边，即可实现循环的效果</p></li></ul></li> <li><p><strong>测试</strong></p> <ul><li><p>类似分支，测试(test)命令<code>t</code>也可用于改变执行流程。测试命令会<strong>根据替换命令的结果跳转到某个标签</strong>，而不是根据地址跳转</p></li> <li><p>若替换命令成功匹配并替换一个模式，测试命令就会跳转到指定标签，否则不跳转</p></li> <li><p>格式与分支相同</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token punctuation">[</span>address<span class="token punctuation">]</span>t <span class="token punctuation">[</span>label<span class="token punctuation">]</span>
</code></pre></div></li> <li><p>执行了一个替换就不再执行另一个替换：</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">sed</span> <span class="token string">'{s/first/matched/t ; s/first/notMatch/'</span> data.txt
</code></pre></div></li></ul></li></ul> <h3 id="模式替代"><a href="#模式替代" class="header-anchor">#</a> 模式替代</h3> <ul><li><p>若想在行中为模式匹配的单词加上引号</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token builtin class-name">echo</span> <span class="token string">&quot;The cat sleeps in his hat&quot;</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/.at/&quot;.at&quot;/g'</span>
</code></pre></div><ul><li>上述命令会将cat和hat换为&quot;.at&quot;，并不能实现预期目标</li></ul></li> <li><p><strong>&amp;符号</strong></p> <ul><li><p>sed中<code>&amp;</code>符号可用来代表替换命令中的匹配模式，不管匹配模式时怎样的文本，都可以在替代模式中使用&amp;符号表示</p></li> <li><p>可将上述加引号的命令修正为</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token builtin class-name">echo</span> <span class="token string">&quot;The cat sleeps in his hat&quot;</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/.at/&quot;&amp;&quot;/g'</span>
</code></pre></div></li></ul></li> <li><p><strong>替代单独的单词</strong></p> <ul><li><p><code>&amp;</code>符号会提取匹配的整个字符串，有时只需要其中的一部分</p></li> <li><p>sed使用<strong>圆括号</strong>来定义替换模式中的子模式，可使用<code>\1</code>引用第一个子模式、<code>\2</code>表示第二个，以此类推</p></li> <li><p>==注意==：圆括号需要使用转义符转义</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token builtin class-name">echo</span> <span class="token string">&quot;That furry cat is pretty&quot;</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'/furry \(.at\)/\1/'</span>
<span class="token comment"># 输出 That cat is pretty</span>
</code></pre></div></li> <li><p>需要在子模式中插入文本时此特性尤为有用</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># 为大数字加逗号分隔符</span>
<span class="token comment"># 涉及：正则表达式、测试命令 t</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;1234567&quot;</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'{:start ; s/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/ ; t start}'</span>
</code></pre></div></li></ul></li></ul> <h3 id="创建sed实用工具"><a href="#创建sed实用工具" class="header-anchor">#</a> 创建sed实用工具</h3> <ul><li><p><strong>加倍行间距</strong>（每行后加一个空行，除最后一行）</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">sed</span> <span class="token string">'$!G'</span> data.txt
</code></pre></div></li> <li><p><strong>对可能含有空白行的文件加倍行间距</strong></p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># 先匹配删除所有空行，再加入空行</span>
<span class="token function">sed</span> <span class="token string">'/^$/d ; $!G'</span> data.txt
</code></pre></div></li> <li><p><strong>给文件中的行编号</strong></p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">sed</span> <span class="token string">'='</span> data.txt <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'N; s/\n/ /'</span>
</code></pre></div><ul><li>除了上述方法，还有一些命令可以加行号
<ul><li><code>nl data.txt</code></li> <li><code>cat -n data.txt</code></li></ul></li></ul></li> <li><p><strong>删除行</strong></p> <ul><li><p>删除连续空白行</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># 指定一个任意文本到空行的区间，不进行删除，否则进行删除即可实现删除连续空行，只留一个</span>
/./,/^$/<span class="token operator">!</span>d
</code></pre></div></li> <li><p>删除开头的空白行</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># 从有数据到最末尾的区间都不会被删除</span>
/./,<span class="token variable">$!</span>d
</code></pre></div></li> <li><p>删除结尾的空白行</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">sed</span> <span class="token string">'{:start ; /^\n*$/{$d ; N ; b start} }'</span> data.txt
</code></pre></div></li></ul></li> <li><p><strong>删除HTML标签</strong></p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">sed</span> <span class="token string">'s/&lt;[^&gt;]*&gt;/ /g'</span>
</code></pre></div></li></ul> <h2 id="gawk进阶"><a href="#gawk进阶" class="header-anchor">#</a> gawk进阶</h2> <h3 id="使用变量-2"><a href="#使用变量-2" class="header-anchor">#</a> 使用变量</h3> <ul><li><p>支持两种类型变量</p> <ul><li>内建变量</li> <li>自定义变量</li></ul></li> <li><p><strong>内建变量</strong></p> <ol><li><p>字段和记录分隔符变量</p> <table><thead><tr><th>变量</th> <th>描述</th></tr></thead> <tbody><tr><td>$n</td> <td>表示第 n 个字段</td></tr> <tr><td>FIELDEIDTHS</td> <td>由空格分隔的一列数字，定义了每个数据字段确切宽度。读取时按照该宽度解析字段</td></tr> <tr><td>FS</td> <td>输入字段分隔符(Field Separator)</td></tr> <tr><td>RS</td> <td>输入记录分隔符(Record Separator)</td></tr> <tr><td>OFS</td> <td>输出字段分隔符</td></tr> <tr><td>ORS</td> <td>输出记录分隔符</td></tr></tbody></table> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">gawk</span> <span class="token string">'BEGIN{FS=&quot;,&quot;; OFS=&quot;-&quot;} {print $1,$2,$3}'</span> data.txt
</code></pre></div><ul><li><p>RS和ORS决定了如何定义一条记录。默认二者取值为换行符<code>\n</code>，即一行当作一条记录</p></li> <li><p>对于多行是一条完整记录来说，一般在记录之间使用空行分隔，然后将<code>FS</code>设为<code>\n</code>，将<code>RS</code>设为空字符<code>''</code>即可分割</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">cat</span> data.txt
Jack
Chengdu
<span class="token number">1991</span>-12-12

Jason
Shanghai
<span class="token number">1998</span>-09-13

<span class="token function">gawk</span> <span class="token string">'BEGIN{FS=&quot;\n&quot;; RS=&quot;&quot;} {print $1,$2}'</span> data.txt
</code></pre></div></li></ul></li> <li><p>数据变量</p> <table><thead><tr><th>变量</th> <th>描述</th></tr></thead> <tbody><tr><td>ARGC</td> <td>命令行参数个数</td></tr> <tr><td>ARGIND</td> <td>当前文件在ARGV中的位置</td></tr> <tr><td>ARGV</td> <td>包含命令参数的数组</td></tr> <tr><td>CONVFMT</td> <td>数字的转换格式，默认为%.6 g</td></tr> <tr><td>ENVIRON</td> <td>当前shell环境变量及其值组成的关联数组</td></tr> <tr><td>ERRNO</td> <td>读取或关闭输入文件发生错误时的系统错误号</td></tr> <tr><td>FILENAME</td> <td>输入数据文件名</td></tr> <tr><td>FNR</td> <td>当前数据文件中已处理记录数。处理一个新文件时重置</td></tr> <tr><td>IGNORECASE</td> <td>设成非0值是忽略命令中出现的字符串大小写</td></tr> <tr><td>NF</td> <td>数据文件字段总数</td></tr> <tr><td>NR</td> <td>已处理的输入记录数（所有文件）</td></tr> <tr><td>OFMT</td> <td>数字的输出格式，默认为 %.6 g</td></tr> <tr><td>RLENGTH</td> <td>由match函数所匹配的子字符串长度</td></tr> <tr><td>RSTART</td> <td>由match函数所匹配的子字符串起始位置</td></tr></tbody></table> <ul><li><p>部分使用示例</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># ENVIRON 用关联数组提取shell环境变量，关联数组类似Map</span>
<span class="token function">gawk</span> <span class="token string">'BEGIN{print ENVIRON[&quot;HOME&quot;]}'</span>
</code></pre></div></li></ul></li></ol></li> <li><p><strong>自定义变量</strong></p> <ol><li><p>在脚本中给变量赋值</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">gawk</span> <span class="token string">'
&gt;BEGIN{
&gt;testing=&quot;This is a test&quot;
&gt;print testing
&gt;}'</span>

<span class="token comment"># 赋值语句还可包含数学算式处理数字值</span>
<span class="token function">gawk</span> <span class="token string">'BEGIN{x=4; x= x * 2 + 3; print x}'</span>
</code></pre></div></li> <li><p>在命令行上给变量赋值</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">cat</span> script.gawk
BEGIN<span class="token punctuation">{</span>FS<span class="token operator">=</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>
<span class="token punctuation">{</span>print <span class="token variable">$n</span><span class="token punctuation">}</span>

<span class="token comment"># 在命令行上直接给 n 赋值</span>
<span class="token function">gawk</span> <span class="token parameter variable">-f</span> script.gawk <span class="token assign-left variable">n</span><span class="token operator">=</span><span class="token number">3</span> data.txt <span class="token comment"># n=3 即显示每行的第三个字段</span>
</code></pre></div><ul><li><p>==注意==：该方法赋值的参数在BEGIN部分不能使用，需要在BEGIN部分使用，则需要在脚本代码前为gawk命令加上<code>-v</code>参数</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">gawk</span> <span class="token parameter variable">-v</span> <span class="token assign-left variable">n</span><span class="token operator">=</span><span class="token number">3</span> <span class="token parameter variable">-f</span> script.gawk data.txt
</code></pre></div></li></ul></li></ol></li> <li><p><strong>处理数组</strong></p> <ul><li><p>gawk使用关联数组（类似Map）提供数组功能</p></li> <li><p>定义数组变量</p> <div class="language-sh extra-class"><pre class="language-sh"><code>var<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element
</code></pre></div></li> <li><p>遍历数组变量</p> <ul><li>使用for的一种特殊形式可遍历关联数组</li></ul> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token keyword">for</span> <span class="token punctuation">(</span>var <span class="token keyword">in</span> array<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	statements
<span class="token punctuation">}</span>
</code></pre></div><ul><li>上述for每次将关联数组中的一个元素的<strong>下标</strong>赋值给var变量，可通过<code>数组名[var]</code>得到值</li></ul></li></ul></li> <li><p><strong>删除数组变量</strong></p> <ul><li><p>关联数组中删除变量需要用特殊命令</p> <div class="language-sh extra-class"><pre class="language-sh"><code>delete array<span class="token punctuation">[</span>index<span class="token punctuation">]</span>
</code></pre></div></li></ul></li></ul> <h3 id="使用模式"><a href="#使用模式" class="header-anchor">#</a> 使用模式</h3> <ul><li><p><strong>正则表达式</strong></p> <ul><li><p>使用正则表达式时，表达式必须出现在其要控制的程序脚本左花括号前</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">gawk</span> <span class="token string">'BEGIN{FS=&quot;,&quot;} /11/{print $1}'</span> data.txt
</code></pre></div></li> <li><p>正则表达式会对所有字段进行匹配，包括分隔符</p></li></ul></li> <li><p><strong>匹配操作符</strong></p> <ul><li><p>匹配操作符(<code>~</code>)允许将正则表达式限定在记录中的特定字段</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># 限定正则表达式仅应用于第一个字段 $1 ，打印匹配条件的第一个和最后一个字段值</span>
<span class="token function">gawk</span> -F: <span class="token string">'$1 ~ /xiao/{print $1,$NF}'</span> /etc/passwd
</code></pre></div></li> <li><p>可使用排除功能(<code>!</code>)来排除正则表达式匹配</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># 将正则表达式应用到第一个字段不匹配模式的记录</span>
<span class="token function">gawk</span> -F: <span class="token string">'$1 !~ /xiao/{print $1,$NF}'</span> /etc/passwd
</code></pre></div></li></ul></li> <li><p><strong>数学表达式</strong></p> <ul><li><p>除了正则表达式，可在匹配中使用数学表达式</p></li> <li><p>常用表达式</p> <table><thead><tr><th>表达式</th> <th>作用</th></tr></thead> <tbody><tr><td>x == y</td> <td>值相等</td></tr> <tr><td>x &lt;= y</td> <td>x小于等于y</td></tr> <tr><td>x &gt;= y</td> <td>..</td></tr> <tr><td>x &gt; y</td> <td>..</td></tr> <tr><td>x &lt; y</td> <td>..</td></tr></tbody></table></li> <li><p>示例</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># 找到所有组ID为 0 的用户</span>
<span class="token function">gawk</span> -F: <span class="token string">'$4 == 0{print $1}'</span> /etc/passwd
</code></pre></div></li></ul></li></ul> <h3 id="结构化命令-2"><a href="#结构化命令-2" class="header-anchor">#</a> 结构化命令</h3> <ul><li><p><strong>if语句</strong></p> <ul><li><p>gawk支持标准的if-then-else语句</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">gawk</span> <span class="token string">'{
&gt;if ($1 &gt; 20)
&gt;{
&gt;	x = $1 * 2
&gt;	print x
&gt;} else
&gt;{
&gt;	x = $1 /2
&gt;	print x
&gt;}}'</span> data.txt
</code></pre></div></li></ul></li> <li><p><strong>while语句</strong></p> <ul><li><p>基本格式</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token keyword">while</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	statements
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>也支持break和continue</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">gawk</span> <span class="token string">'{
&gt;total = 0
&gt;i = 1
&gt;while (i &lt; 4)
&gt;{
&gt;	total += $i
&gt;	if (i == 2)
&gt;		break
&gt;	i++
&gt;}
&gt;}'</span> data.txt
</code></pre></div></li></ul></li> <li><p><strong>do-while语句</strong></p> <ul><li><p>格式</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token keyword">do</span>
<span class="token punctuation">{</span>
	statements
<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span>
</code></pre></div></li></ul></li> <li><p><strong>for语句</strong></p> <ul><li><p>gawk支持C风格的for循环</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token keyword">for</span> <span class="token punctuation">(</span> variable assignment<span class="token punctuation">;</span> contidion <span class="token punctuation">;</span> iteration process<span class="token punctuation">)</span>
</code></pre></div></li></ul></li></ul> <h3 id="格式化打印"><a href="#格式化打印" class="header-anchor">#</a> 格式化打印</h3> <ul><li><p>gawk采用类似C语言的格式化打印，即<code>printf</code>，其用法同C中的printf</p></li> <li><p>基本格式</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token builtin class-name">printf</span> <span class="token string">&quot;format string&quot;</span>, var1, var2 <span class="token punctuation">..</span>.
</code></pre></div></li> <li><p>格式化指定符格式</p> <div class="language-sh extra-class"><pre class="language-sh"><code>%<span class="token punctuation">[</span>modifier<span class="token punctuation">]</span>control-letter
</code></pre></div></li> <li><p>常用控制字符表</p> <table><thead><tr><th>控制字母</th> <th>描述</th></tr></thead> <tbody><tr><td>c</td> <td>将一个数作为ASCII字符显示</td></tr> <tr><td>d</td> <td>显示一个整数值</td></tr> <tr><td>i</td> <td>显示一个整数值，同d</td></tr> <tr><td>e</td> <td>用科学计数法显示一个数</td></tr> <tr><td>f</td> <td>显示一个浮点数</td></tr> <tr><td>g</td> <td>用科学计数法或浮点数显示</td></tr> <tr><td>o</td> <td>显示一个八进制数</td></tr> <tr><td>s</td> <td>显示一个文本字符串</td></tr> <tr><td>x</td> <td>显示一个十六进制数</td></tr> <tr><td>X</td> <td>显示一个十六进制值，用大写字母A~F</td></tr></tbody></table></li> <li><p>除了控制字母，还有3种修饰符可进一步控制输出</p> <ul><li><code>width</code>：制定了输出字段最小宽度的数字值，若短于该值，printf会将文本右对齐并用空格填充；若长于该值，按实际输出</li> <li><code>prec</code>：一个数值，指定浮点数种小数点后的位数，或文本字符串中显示的最大字符数</li> <li><code>-(减号)</code>：指明格式化空间种放入数据时采用左对齐而不是右对齐</li></ul></li> <li><p>格式化打印本身不自动包含换行符</p></li> <li><p>指定宽度打印</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">gawk</span> <span class="token string">'BEGIN{FS=&quot;\n&quot;; RS=&quot;&quot;} {printf &quot;%16s %s\n&quot;, $1 , $4}'</span> data.txt
</code></pre></div></li> <li><p>指定小数点后保留2位</p> <div class="language- extra-class"><pre class="language-text"><code># 宽度为 5 ，小数点后保留2位
printf &quot;%5.2f&quot;, var
</code></pre></div></li></ul> <h3 id="内建函数"><a href="#内建函数" class="header-anchor">#</a> 内建函数</h3> <ul><li><p><strong>数学函数</strong></p> <table><thead><tr><th>函数</th> <th>描述</th></tr></thead> <tbody><tr><td>atan2(x,y)</td> <td>x/y的反正切，x、y以弧度为单位</td></tr> <tr><td>cos(x)</td> <td>余弦</td></tr> <tr><td>exp(x)</td> <td>e的x次方</td></tr> <tr><td>int(x)</td> <td>取整数部分</td></tr> <tr><td>log(x)</td> <td>lg x</td></tr> <tr><td>rand()</td> <td>0到1之间的随机浮点值，不包括0和1</td></tr> <tr><td>sin(x)</td> <td>正弦</td></tr> <tr><td>sqrt(x)</td> <td>平方根</td></tr> <tr><td>srand(x)</td> <td>为计算随机数指定种子</td></tr> <tr><td>and(v1,v2)</td> <td>按位与</td></tr> <tr><td>compl(val)</td> <td>执行val的补运算</td></tr> <tr><td>lshift(val,count)</td> <td>将值val左移count位</td></tr> <tr><td>or(v1,v2)</td> <td>按位或</td></tr> <tr><td>rshift(val,count)</td> <td>将值val右移count位</td></tr> <tr><td>xor(v1,v2)</td> <td>异或</td></tr></tbody></table></li> <li><p><strong>字符串函数</strong>（gawk使用关联数组实现数组）</p> <table><thead><tr><th>函数</th> <th>描述</th></tr></thead> <tbody><tr><td>asort(s [,d])</td> <td>将数组s按数据元素进行排序，索引会被替换成表示排序顺序的数字。若指定d，排序后的结果会存在d中</td></tr> <tr><td>asorti(s [,d])</td> <td>将数组s按索引值排序，生成的数组将索引值作为数据元素值。若指定d，排序结果存在d中</td></tr> <tr><td>gensub(r,s,h [,t])</td> <td>查找变量$0或目标字符串t(可选)来匹配正则表达式r，若h是一个以g或G开头的字符串，就用s替换掉匹配的文本。若h是数字，表示要替换掉第h处r匹配的地方</td></tr> <tr><td>gsub(r,s [,t])</td> <td>查找变量$0或目标字符串t(可选)来匹配正则表达式r，若找到，就全替换成s</td></tr> <tr><td>index(s,t)</td> <td>返回字符串t在s中的索引位置</td></tr> <tr><td>length([s])</td> <td>返回字符串s的长度，没指定则返回$0的长度</td></tr> <tr><td>match(s,r [,a])</td> <td>返回字符串s中正则表达式r出现位置的索引。若指定数组a，会存储s中匹配正则表达式的部分</td></tr> <tr><td>split(s,a [,r])</td> <td>将s用FS指定的字符或正则表达式r(可选)分开放到数组a中，返回字段总数</td></tr> <tr><td>sprintf(format,variables)</td> <td>用提供的format和variables返回一个类似printf输出的字符串</td></tr> <tr><td>sub(r,s, [,t])</td> <td>在变量$0或目标串t(可选)中查找正则表达式r的匹配，找到就用s替换第一处匹配</td></tr> <tr><td>substr(s,i [,n])</td> <td>返回s中从索引i开始的n个字符组成的子串，n未指定则返回i到末尾</td></tr> <tr><td>tolower(s)</td> <td>将s转换为全小写</td></tr> <tr><td>toupper(s)</td> <td>将s转换为全大写</td></tr></tbody></table></li> <li><p><strong>时间函数</strong></p> <table><thead><tr><th>函数</th> <th>描述</th></tr></thead> <tbody><tr><td>mktime(datespec)</td> <td>将一个按YYY MM DD HH MM SS[DST]格式指定的日期转换成时间戳值</td></tr> <tr><td>strftime(format [,timestamp])</td> <td>将当前时间的时间戳或timestamp(若提供)转化成格式化日期（shell date的格式）</td></tr> <tr><td>systime()</td> <td>返回当前时间的时间戳</td></tr></tbody></table></li></ul> <h3 id="自定义函数"><a href="#自定义函数" class="header-anchor">#</a> 自定义函数</h3> <ul><li><p><strong>定义函数</strong></p> <ul><li><p>格式</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token keyword">function</span> name<span class="token punctuation">(</span><span class="token punctuation">[</span>variables<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	statements
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>使用时直接<code>函数名()</code>调用即可</p></li></ul></li> <li><p>可以将所有函数写进一个文件作为函数库，然后使用gawk的<code>-f</code>参数引用该文件</p></li></ul> <h2 id="附-符号与常用环境变量含义速查"><a href="#附-符号与常用环境变量含义速查" class="header-anchor">#</a> 附：符号与常用环境变量含义速查</h2> <h2 id=""><a href="#" class="header-anchor">#</a></h2> <table><thead><tr><th>符号</th> <th>描述</th></tr></thead> <tbody><tr><td>$</td> <td>引用变量，如$HOME</td></tr> <tr><td>${}</td> <td>同上</td></tr> <tr><td>$?</td> <td>最近一条命令的退出状态码</td></tr> <tr><td>$!</td> <td>最近执行的后台进程的PID</td></tr> <tr><td>$#</td> <td>传给脚本的参数个数</td></tr> <tr><td>$0</td> <td>脚本名</td></tr> <tr><td>$1~n</td> <td>脚本参数索引</td></tr> <tr><td>${10}</td> <td>当脚本参数超10个时，需要用大括号括起来引用对应位置的参数</td></tr> <tr><td>$*</td> <td>脚本的所有参数。用类似字符串拼接后的方式存储</td></tr> <tr><td>$@</td> <td>脚本的所有参数。用类似list的方式存储，支持用for遍历</td></tr> <tr><td>$$</td> <td>当前设立了进程ID</td></tr> <tr><td>&amp;&gt;</td> <td>STDOUT和STDERR都重定向到某处</td></tr> <tr><td>1&gt;</td> <td>将文件描述符1表示的(STDOUT)重定向到某处</td></tr> <tr><td>&gt;&amp;2</td> <td>临时重定向到文件描述符 2 的位置（STDERR）</td></tr> <tr><td>command &amp;</td> <td>命令后加 &amp; 表示后台运行</td></tr> <tr><td>`command`</td> <td>var=`command`表示取命令的结果赋值给环境变量var</td></tr> <tr><td>$(command)</td> <td>同上</td></tr> <tr><td>$[ expression ]</td> <td>表达式求值，如 var=$[ 45 + 2 ]</td></tr> <tr><td>if [ $var -eq 2 ]</td> <td>[]为test语句简写方式</td></tr></tbody></table></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.969a6014.js" defer></script><script src="/assets/js/2.0c4bddf9.js" defer></script><script src="/assets/js/1.50b457b8.js" defer></script><script src="/assets/js/37.62de5401.js" defer></script>
  </body>
</html>
