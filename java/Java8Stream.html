<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JavaSE 8流库 | Longqinx&#39;s Notes</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/assets/css/0.styles.9f84806b.css" as="style"><link rel="preload" href="/assets/js/app.9fc73bf5.js" as="script"><link rel="preload" href="/assets/js/2.0c4bddf9.js" as="script"><link rel="preload" href="/assets/js/1.50b457b8.js" as="script"><link rel="preload" href="/assets/js/32.e88c0552.js" as="script"><link rel="prefetch" href="/assets/js/10.325b9f09.js"><link rel="prefetch" href="/assets/js/11.845e3692.js"><link rel="prefetch" href="/assets/js/12.ecdb524b.js"><link rel="prefetch" href="/assets/js/13.3f3f6a36.js"><link rel="prefetch" href="/assets/js/14.eb7a3d07.js"><link rel="prefetch" href="/assets/js/15.b60f3925.js"><link rel="prefetch" href="/assets/js/16.85253907.js"><link rel="prefetch" href="/assets/js/17.c2838453.js"><link rel="prefetch" href="/assets/js/18.3256f17f.js"><link rel="prefetch" href="/assets/js/19.d8afd0ae.js"><link rel="prefetch" href="/assets/js/20.10e47ab9.js"><link rel="prefetch" href="/assets/js/21.33b300c9.js"><link rel="prefetch" href="/assets/js/22.271589f5.js"><link rel="prefetch" href="/assets/js/23.36377001.js"><link rel="prefetch" href="/assets/js/24.4b7aa88b.js"><link rel="prefetch" href="/assets/js/25.56528869.js"><link rel="prefetch" href="/assets/js/26.b52f2341.js"><link rel="prefetch" href="/assets/js/27.efe3c099.js"><link rel="prefetch" href="/assets/js/28.4b2afb08.js"><link rel="prefetch" href="/assets/js/29.3395be40.js"><link rel="prefetch" href="/assets/js/3.af33e5d6.js"><link rel="prefetch" href="/assets/js/30.0f02679a.js"><link rel="prefetch" href="/assets/js/31.660f824f.js"><link rel="prefetch" href="/assets/js/33.707922df.js"><link rel="prefetch" href="/assets/js/34.7e9d365c.js"><link rel="prefetch" href="/assets/js/35.3dfd9ff7.js"><link rel="prefetch" href="/assets/js/36.6c8f895d.js"><link rel="prefetch" href="/assets/js/37.1a64224f.js"><link rel="prefetch" href="/assets/js/38.b9caece4.js"><link rel="prefetch" href="/assets/js/39.0a4f8509.js"><link rel="prefetch" href="/assets/js/4.45665f8a.js"><link rel="prefetch" href="/assets/js/40.167f9203.js"><link rel="prefetch" href="/assets/js/41.a4cc5d7f.js"><link rel="prefetch" href="/assets/js/5.7098d77a.js"><link rel="prefetch" href="/assets/js/6.0c0a0f39.js"><link rel="prefetch" href="/assets/js/7.6a854e57.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.77260563.js">
    <link rel="stylesheet" href="/assets/css/0.styles.9f84806b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.png" alt="Longqinx's Notes" class="logo"> <span class="site-name can-hide">Longqinx's Notes</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/java/" class="nav-link router-link-active">
  Java
</a></div><div class="nav-item"><a href="/c++/" class="nav-link">
  C/C++
</a></div><div class="nav-item"><a href="/linux/" class="nav-link">
  Linux
</a></div><div class="nav-item"><a href="/dsa/" class="nav-link">
  数据结构与算法
</a></div><div class="nav-item"><a href="/project/" class="nav-link">
  我的小项目
</a></div><div class="nav-item"><a href="/blog/" class="nav-link">
  技术文章
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="关于" class="dropdown-title"><span class="title">关于</span> <span class="arrow down"></span></button> <button type="button" aria-label="关于" class="mobile-dropdown-title"><span class="title">关于</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/about/contactMe.html" class="nav-link">
  联系我
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/java/" class="nav-link router-link-active">
  Java
</a></div><div class="nav-item"><a href="/c++/" class="nav-link">
  C/C++
</a></div><div class="nav-item"><a href="/linux/" class="nav-link">
  Linux
</a></div><div class="nav-item"><a href="/dsa/" class="nav-link">
  数据结构与算法
</a></div><div class="nav-item"><a href="/project/" class="nav-link">
  我的小项目
</a></div><div class="nav-item"><a href="/blog/" class="nav-link">
  技术文章
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="关于" class="dropdown-title"><span class="title">关于</span> <span class="arrow down"></span></button> <button type="button" aria-label="关于" class="mobile-dropdown-title"><span class="title">关于</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/about/contactMe.html" class="nav-link">
  联系我
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>JavaSE 8流库</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/java/Java8Stream.html#流的创建" class="sidebar-link">流的创建</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/java/Java8Stream.html#filter、map、flatmap" class="sidebar-link">filter、map、flatMap</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/java/Java8Stream.html#抽取子流和连接流" class="sidebar-link">抽取子流和连接流</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/java/Java8Stream.html#去重、排序等其他流" class="sidebar-link">去重、排序等其他流</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/java/Java8Stream.html#简单约简" class="sidebar-link">简单约简</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/java/Java8Stream.html#optional类型" class="sidebar-link">Optional类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/Java8Stream.html#如何使用" class="sidebar-link">如何使用</a></li><li class="sidebar-sub-header"><a href="/java/Java8Stream.html#创建optional值" class="sidebar-link">创建Optional值</a></li><li class="sidebar-sub-header"><a href="/java/Java8Stream.html#用flatmap-构建optional返回值的函数" class="sidebar-link">用flatMap()构建Optional返回值的函数</a></li></ul></li><li><a href="/java/Java8Stream.html#收集结果" class="sidebar-link">收集结果</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/java/Java8Stream.html#收集到映射表" class="sidebar-link">收集到映射表</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/java/Java8Stream.html#群组和分区" class="sidebar-link">群组和分区</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/java/Java8Stream.html#下游收集器" class="sidebar-link">下游收集器</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/java/Java8Stream.html#约简操作" class="sidebar-link">约简操作</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/java/Java8Stream.html#基本类型流" class="sidebar-link">基本类型流</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/java/Java8Stream.html#并行流" class="sidebar-link">并行流</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="javase-8流库"><a href="#javase-8流库" class="header-anchor">#</a> JavaSE 8流库</h1> <ul><li><p>流提供了一种可以在<strong>比集合更高的概念级别</strong>上指定计算的数据视图</p></li> <li><p>流通常关注完成什么任务而不是如何去实现</p></li> <li><p>一个小示例：统计长单词的数量</p> <ul><li>用传统的集合遍历的方式：</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">long</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">String</span> w<span class="token operator">:</span>words<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>w<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">12</span><span class="token punctuation">)</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>使用流API的方式：</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">long</span> count <span class="token operator">=</span> words<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>w <span class="token operator">-&gt;</span> w<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">12</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>可见，使用流的方式可以<strong>让代码更易读</strong></p></li> <li><p>此外，若将<code>stream()</code>改为<code>paralleStream()</code>，则可以<strong>并行进行</strong>过滤和计数操作</p></li> <li><p><strong>流与集合的差异</strong></p> <ul><li>流并不存储元素。流的元素可能存在底层的集合中，或者按需生成</li> <li>流操作不会修改数据源。如<code>filter</code>方法不会移除流中的元素，而是产生新的流</li> <li>流操作是尽可能惰性执行的。即直至需要其结果时，操作才会执行</li></ul></li> <li><p><strong>流操作的典型流程</strong></p> <ul><li>创建流</li> <li>将指定初始流转换为其他流的中间操作</li> <li>终止操作，产生结果。该操作会强制执行之前的惰性操作</li></ul></li></ul> <h2 id="流的创建"><a href="#流的创建" class="header-anchor">#</a> 流的创建</h2> <ul><li><p>常用方法</p> <table><thead><tr><th>方法</th> <th>描述</th> <th>所属类</th></tr></thead> <tbody><tr><td>defualt Stream&lt;E&gt; stream()</td> <td>集合对象调用。产生以当前集合为元素的流</td> <td>java.util.Collection&lt;E&gt;</td></tr> <tr><td>defualt Stream&lt;E&gt; parallelStream()</td> <td>集合对象调用。产生以当前集合为元素的并行流</td> <td>java.util.Collection&lt;E&gt;</td></tr> <tr><td>static &lt;T&gt; Stream&lt;T&gt; of(T... values)</td> <td>从数组、多个参数中创建流</td> <td>java.util.stream.Stream</td></tr> <tr><td>static &lt;T&gt; Stream&lt;T&gt; empty()</td> <td>创建一个不包含元素的空流</td> <td>java.util.stream.Stream</td></tr> <tr><td>static &lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</td> <td>创建无限流，其值是通过反复调用函数 s 得到的</td> <td>java.util.stream.Stream</td></tr> <tr><td>static &lt;T&gt; Stream&lt;T&gt; iterate(T seed,UnaryOperator&lt;T&gt; f)</td> <td>创建无限流，其元素包含种子、在种子上调用函数f产生的值，在前一个元素上调用f产生的值等</td> <td>java.util.stream.Stream</td></tr> <tr><td>static &lt;T&gt; Stream&lt;T&gt; stream(T[] array,int start,int end)</td> <td>从数组array中的指定范围元素创建流</td> <td>java.util.Arrays</td></tr> <tr><td>Stream&lt;String&gt; splitAsStream(CharSequence input)</td> <td>产生一个流，其元素是正则表达式模板分割字符序列后的结果</td> <td>java.util.regex.Pattern</td></tr> <tr><td>static Stream&lt;String&gt; lines(Path path)</td> <td>创建流，其元素是path指定文件中的行，字符集为UTF-8</td> <td>java.nio.file.Files</td></tr> <tr><td>static Stream&lt;String&gt; lines(Path path,Charset cs)</td> <td>创建流，其元素是path指定文件中的行，字符集为cs</td> <td>java.nio.file.Files</td></tr></tbody></table></li></ul> <h2 id="filter、map、flatmap"><a href="#filter、map、flatmap" class="header-anchor">#</a> filter、map、flatMap</h2> <ul><li><p>函数签名</p> <ul><li><code>Stream&lt;T&gt; filter(Predicate&lt; ? super T&gt; predicate)</code></li> <li><code>&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T,? extends R&gt; mapper)</code></li> <li><code>&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T,? extends Stream&lt;? extends R&gt;&gt; mapper)</code></li></ul></li> <li><p><strong>filter</strong></p> <ul><li>参数为Predicate&lt;T&gt; ，即从 T 到 boolean 的函数</li> <li>返回所有满足条件的元素构成的新流</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//返回所有长度大于12的元素构成的新流</span>
words<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>w <span class="token operator">-&gt;</span> w<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">12</span><span class="token punctuation">)</span>
</code></pre></div></li> <li><p><strong>map</strong></p> <ul><li>map函数用于按照某种方式将流元素进行转换</li> <li>如将所有单词转换为小写</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">String</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> lowercaseWords <span class="token operator">=</span> words<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">::</span><span class="token function">toLowerCae</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>通常参数会用一个Lambda表达式表示，该表达式会应用到每个元素并返回一个结果</li> <li>该表达式还<strong>可以返回一个包含多个值的流</strong>，得到的结果是包含多个流的流，如</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token char">'a'</span><span class="token punctuation">,</span><span class="token char">'b'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token char">'c'</span><span class="token punctuation">,</span><span class="token char">'d'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token char">'e'</span><span class="token punctuation">,</span><span class="token char">'f'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>
</code></pre></div><ul><li>若要展平为</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token punctuation">[</span><span class="token char">'a'</span><span class="token punctuation">,</span><span class="token char">'b'</span><span class="token punctuation">,</span><span class="token char">'c'</span><span class="token punctuation">,</span><span class="token char">'d'</span><span class="token punctuation">,</span><span class="token char">'e'</span><span class="token punctuation">,</span><span class="token char">'f'</span><span class="token punctuation">]</span>
</code></pre></div><ul><li>则可使用<code>flatMap</code></li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> flatResult <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>w<span class="token operator">-&gt;</span><span class="token function">letters</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p><strong>flatMap</strong></p> <ul><li>设有一个泛型G，以及将某种类型T转换为G&lt;U&gt;的函数f和将类型U转换为G&lt;V&gt;的函数g，则可通过flatMap来组合，即先应用f后应用g</li> <li>常用的方法是通过该函数使当前流所有元素产生的结果连接到一起</li></ul></li></ul> <h2 id="抽取子流和连接流"><a href="#抽取子流和连接流" class="header-anchor">#</a> 抽取子流和连接流</h2> <ul><li><p><code>stream.limit(n)</code></p> <ul><li>用于从当前流中抽取新的流，其包含当前流的前 n 个元素，n大于当前流长度时，则包含所有</li> <li>常用于裁剪无限流</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//包含100个double元素的流</span>
<span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Double</span><span class="token punctuation">&gt;</span></span> randoms <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">generate</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token operator">::</span><span class="token function">random</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p><code>stream.skip(n)</code></p> <ul><li>丢弃当前流的前 n 个元素</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> words <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>content<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&quot;\\PL+&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">skip</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p><code>Stream.concate()</code></p> <ul><li>静态方法。用于连接两个流，第一个流应该不是无限流，否则不会处理到第二个流</li></ul></li></ul> <h2 id="去重、排序等其他流"><a href="#去重、排序等其他流" class="header-anchor">#</a> 去重、排序等其他流</h2> <ul><li><p><code>Stream&lt;T&gt; distinct()</code></p> <ul><li>将原来的流按照相同顺序去重后产生新流，此流能够记住其已经看到过的元素</li></ul></li> <li><p><code>Stream&lt;T&gt; sorted()</code></p> <ul><li>用于操作实现了<code>Comparable</code>接口的元素</li></ul></li> <li><p><code>Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator)</code></p> <ul><li>接受一个<code>Comparator</code>为参数进行排序</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> longestFirst <span class="token operator">=</span> words<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">::</span><span class="token function">length</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p><code>Stream&lt;T&gt; peek(Consumer&lt;? super T&gt; action)</code></p> <ul><li>返回一个新流，其元素与原来的流一样。但每次获取一个元素时，都会调用一个函数</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> powers <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">iterate</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span>p<span class="token operator">-&gt;</span>p<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span>e<span class="token operator">-&gt;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;fetching &quot;</span><span class="token operator">+</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul> <h2 id="简单约简"><a href="#简单约简" class="header-anchor">#</a> 简单约简</h2> <ul><li><p>约简是一种终结操作，用于将<strong>流约简为</strong>可在程序中使用的<strong>非流值</strong>，如<code>count()</code>用于返回流中的元素个数</p></li> <li><p>常用的约简操作有：</p> <table><thead><tr><th>方法</th> <th>描述</th></tr></thead> <tbody><tr><td>Optional&lt;T&gt; count()</td> <td>返回元素数量</td></tr> <tr><td>Optional&lt;T&gt; max(comparator)</td> <td>传入一个比较器，找出流中的最大值</td></tr> <tr><td>Optional&lt;T&gt; min(comparator)</td> <td>找出流中最小值</td></tr> <tr><td>Optional&lt;T&gt; findFirst()</td> <td>返回流的第一个元素</td></tr> <tr><td>Optional&lt;T&gt; findAny()</td> <td>返回流的任意一个元素</td></tr> <tr><td>boolean anyMatch(predicate)</td> <td>以一个断言(boolean返回值函数)对元素判断，是否有一个符合条件</td></tr> <tr><td>boolean allMatch(predicate)</td> <td>.......，是否所有元素都符合条件</td></tr> <tr><td>boolean noneMatch(predicate)</td> <td>.......，是否没有任何元素符合条件</td></tr></tbody></table> <ul><li>对于返回值为Optional&lt;T&gt;的方法，在没有结果时其中不包含任何值(而不是返回null)，有结果时包装了结果</li></ul></li></ul> <h2 id="optional类型"><a href="#optional类型" class="header-anchor">#</a> Optional类型</h2> <ul><li>Optional&lt;T&gt;对象是一种包装器对象，要么包装了T类型的对象，要么没有包装任何对象。对于第一种情况，称为值为存在的</li> <li>Optional&lt;T&gt;被当作一种更安全的方式来<strong>替代类型T的引用</strong>，而这种引用可能为null，可能造成<code>NullPointerException</code></li></ul> <h3 id="如何使用"><a href="#如何使用" class="header-anchor">#</a> 如何使用</h3> <ul><li><p>关键是使用这样的方法：其值不存在时会<strong>产生一个可替代物</strong>，只有在值存在时才会使用这个值</p></li> <li><p>对于第一条规则：没有匹配时会使用某种默认值，如空串而非null</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">String</span> result <span class="token operator">=</span> optionalString<span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>也可通过调用代码计算默认值</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">String</span> result <span class="token operator">=</span> optionalString<span class="token punctuation">.</span><span class="token function">orElseGet</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token class-name">Locale</span><span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDisplayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>或在没有任何值时抛出异常</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">String</span> result <span class="token operator">=</span> optionalString<span class="token punctuation">.</span><span class="token function">orElseThrow</span><span class="token punctuation">(</span><span class="token class-name">IllegalStateExceprion</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>对于第二条规则：存在时才会使用</p> <div class="language-java extra-class"><pre class="language-java"><code>optionalValue<span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span>v<span class="token operator">-&gt;</span><span class="token class-name">Process</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>使用<code>ifPresent()</code>不会返回任何值，若需要处理函数结果，可使用map</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Boolean</span><span class="token punctuation">&gt;</span></span> added <span class="token operator">=</span> optionalValue<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>result<span class="token operator">::</span><span class="token function">add</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>整理归纳来说，常用的<code>java.util.Optional</code>包的函数有</p> <ul><li><code>orElse()</code></li> <li><code>orElseGet()</code></li> <li><code>orElseThrow()</code></li> <li><code>ifPresent()</code></li> <li><code>map()</code></li> <li><code>get()</code>：产生Optional包装的值，若不存在则抛出<code>NoSuchElementException</code>异常</li></ul></li></ul> <h3 id="创建optional值"><a href="#创建optional值" class="header-anchor">#</a> 创建Optional值</h3> <ul><li><p><code>static &lt;T&gt; Optional&lt;T&gt; of(T value)</code></p> <ul><li>创建一个包装了value的Optional，当value为null时抛出空指针异常</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">return</span> x<span class="token operator">==</span><span class="token operator">?</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p><code>static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value)</code></p> <ul><li>创建一个具有给定值的Optional，若value为null，创建一个空Optional</li></ul></li> <li><p><code>static &lt;T&gt; Optional&lt;T&gt; empty()</code></p> <ul><li>创建一个空Optional</li></ul></li></ul> <h3 id="用flatmap-构建optional返回值的函数"><a href="#用flatmap-构建optional返回值的函数" class="header-anchor">#</a> 用flatMap()构建Optional返回值的函数</h3> <ul><li><p>若有一个可产生<code>Optional&lt;T&gt;</code>对象的方法 f ，且目标类型 T 有一个可产生<code>Optional&lt;U&gt;</code>对象的方法 g ，若都是普通方法，可通过<code>s.f().g()</code>进行组合调用，但此处不行，因为 f 的返回类型为<code>Optional&lt;T&gt;</code>而不是 T，因此需要：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//若 f() 的值存在，则可以将g应用在上边，否则返回空的Optional对象</span>
<span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token operator">::</span><span class="token function">g</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>若有多个函数，则可以重复上述方式，且这种方式保证了只要调用环节中有一个返回空对象，该调用链结果为空的Optional</p></li></ul> <h2 id="收集结果"><a href="#收集结果" class="header-anchor">#</a> 收集结果</h2> <ul><li><p>常用函数</p> <table><thead><tr><th>方法</th> <th>描述</th></tr></thead> <tbody><tr><td>iterator()</td> <td>返回可用于访问元素的旧式风格迭代器</td></tr> <tr><td>forEach(func)</td> <td>将某个函数应用于每个元素。并行流上可能以任意顺序遍历</td></tr> <tr><td>toArray()</td> <td>将元素返回成一个数组</td></tr> <tr><td>toArray(generator)</td> <td>为了让元素具有正确类型，可在运行时使用此方法，通常传入相应类型构造器为参数</td></tr> <tr><td>collect(collector)</td> <td>将流中的元素收集到另一个目标中。接受一个Collector实例，见表后示例</td></tr></tbody></table></li> <li><p>对于<code>collect()</code>，<code>Collectors</code>类中提供了许多用于生成公共收集器的方法：</p> <ul><li><p><code>Collectors.toList()</code></p> <ul><li>收集为List</li></ul></li> <li><p><code>Collectors.toSet()</code></p> <ul><li>收集为Set</li></ul></li> <li><p><code>Collectors.toCollction(CollectionFactory)</code></p> <ul><li>根据工厂方法生成指定类型的Collection，如<code>Collectors.toCollection(TreeSet::new)</code></li></ul></li> <li><p><code>Collectors.joining(&quot;delimiter&quot;)</code></p> <ul><li>在元素间添加分隔符生成字符串，如<code>Collectors.joining(&quot;,&quot;)</code></li></ul></li> <li><p><code>Collectors.summarizing(Int|Long|Double)</code></p> <ul><li>该方法返回一个(Int|Long|Double)SummaryStatistics对象，用于计算总和、数量、均值、最值等</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">IntSummaryStatistics</span> summary <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">summarizingInt</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">::</span><span class="token function">length</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//返回平均值</span>
<span class="token keyword">double</span> average <span class="token operator">=</span> summary<span class="token punctuation">.</span><span class="token function">getAverage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//最大值</span>
<span class="token keyword">double</span> maxLength <span class="token operator">=</span> summary<span class="token punctuation">.</span><span class="token function">getMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul></li></ul> <h2 id="收集到映射表"><a href="#收集到映射表" class="header-anchor">#</a> 收集到映射表</h2> <ul><li><p>对于一个流，若想将其元素收集到一个映射表(Map)中以便于后续可以通过其Key来查找该元素，则可用<code>Collectors.toMap()</code>收集器</p></li> <li><p>Collectors.toMap()的多个重载形式</p> <ul><li><p><code>toMap(Function keyMapper,Function valueMapper)</code></p> <ul><li>keyMapper是用于产生键的函数，valueMapper用于产生值</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> idToName <span class="token operator">=</span> people<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toMap</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token operator">::</span><span class="token function">getId</span><span class="token punctuation">,</span><span class="token class-name">Persion</span><span class="token operator">::</span><span class="token function">getName</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>当值取实际的元素时，第二个参数可传入<code>Function.identity()</code></li></ul></li> <li><p><code>toMap(Function keyMapper,Function valueMapper,BinatyOperator mergeFunc)</code></p> <ul><li>上一个二参数形式函数在键发生冲突的时候会抛出<code>IllegalStateException</code>异常</li> <li>可通过第三个参数覆盖这种行为</li> <li>第三个参数需要传入一个二元函数，该函数参数为Map中已存在的值和新的值，可通过该函数的返回值确定对于冲突的键，是使用新值还是旧值或者新旧值的组合</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//第三参数的作用可如此理解：</span>
<span class="token comment">//当收集过程中Map中已经有了键值对['key1':'value1']的时候，后续又产生了一个键为key1的键值对</span>
<span class="token comment">//如 ['key1':'value2']。此时第三参数写为 (existValue,newValue)-&gt;existValue ，冲突发生时</span>
<span class="token comment">//value1 和 value2自动传入函数，而返回结果为existValue，即value1，所以该冲突的解决方式为</span>
<span class="token comment">//保留value1的值，舍弃value2的值，即最终的Map中存在的key1对应的值为value1</span>
<span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Locale</span><span class="token punctuation">&gt;</span></span> locales <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token class-name">Locale</span><span class="token punctuation">.</span><span class="token function">getAvailableLocales</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> languageNames <span class="token operator">=</span> locales<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toMap</span><span class="token punctuation">(</span>
    <span class="token class-name">Locale</span><span class="token operator">::</span><span class="token function">getDisplayLanguage</span><span class="token punctuation">,</span>
    l<span class="token operator">-&gt;</span>l<span class="token punctuation">.</span><span class="token function">getDisplayLanguage</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span>existValue<span class="token punctuation">,</span>newValue<span class="token punctuation">)</span><span class="token operator">-&gt;</span>existValue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>若对于键冲突的值，需要存储为一个值集而不是舍弃其中某些值时，可使用下述方式</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Set</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> countryLanguageSet <span class="token operator">=</span> locales<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toMap</span><span class="token punctuation">(</span>
    <span class="token class-name">Locale</span><span class="token operator">::</span><span class="token function">getDisplayCountry</span><span class="token punctuation">,</span>
    <span class="token comment">//为每种语言都创建一个单例集</span>
    l<span class="token operator">-&gt;</span><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singleton</span><span class="token punctuation">(</span>l<span class="token punctuation">.</span><span class="token function">getDisplayLanguage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token comment">//对于键发生冲突的值，进行合并</span>
    <span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>
        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> union <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
        union<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> union<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p><code>toMap(Function keyMapper,Function valueMapper,BinatyOperator mergeFunc,Supplier mapSupplier)</code></p> <ul><li>通过第四个参数可以产生指定类型的Map，如TreeMap：</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span><span class="token class-name">Persion</span><span class="token punctuation">&gt;</span></span> idToName <span class="token operator">=</span> people<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toMap</span><span class="token punctuation">(</span>
    <span class="token class-name">Person</span><span class="token operator">::</span><span class="token function">getId</span><span class="token punctuation">,</span>
    <span class="token class-name">Function</span><span class="token punctuation">.</span><span class="token function">identity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span>existValue<span class="token punctuation">,</span>newValue<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token class-name">TreeMap</span><span class="token operator">::</span><span class="token keyword">new</span>
<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>==对于每种重载类型，都有一个<code>toConcurrentMap()</code>与之对应，用于产生可并发的集合(线程安全)，对应处理并行流更高效==</p></li></ul></li></ul> <h2 id="群组和分区"><a href="#群组和分区" class="header-anchor">#</a> 群组和分区</h2> <ul><li><p>对于上述将同类型键冲突的值合并的处理方法显得略冗长，需要生成单例集并进行合并</p></li> <li><p>对于这种将<strong>相同特性的值聚集成组</strong>是很常见的，可通过<code>groupingBy()</code>直接完成</p></li> <li><p><code>groupingBy(Function classifier)</code>的使用，对于上一节的值集合并问题：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Locale</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> countryToLocales <span class="token operator">=</span> locales<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">Locale</span><span class="token operator">::</span><span class="token function">getCountry</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>函数<code>getCountry()</code>为分类函数，现在可通过国家代码查找对应地点:</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Locale</span><span class="token punctuation">&gt;</span></span> swissLocales<span class="token operator">=</span>countryToLocales<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;CH&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>当<strong>分类的函数是断言函数</strong>时(返回boolean)，流元素会被分为两类，返回false和返回true的</p></li> <li><p>此时使用<code>partitioningBy()</code>更高效</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Boolean</span><span class="token punctuation">,</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Locale</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> englishAndOther <span class="token operator">=</span> locales<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>
    <span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">partitioningBy</span><span class="token punctuation">(</span>l<span class="token operator">-&gt;</span>l<span class="token punctuation">.</span><span class="token function">getLanguage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">&quot;en&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>上述代码将locale分为使用英语和其他语言两种，用Boolean索引可得到结果</li></ul></li> <li><p>对应的，<code>groupingBy()</code>有<code>groupingByConcurrent()</code>版本</p></li></ul> <h2 id="下游收集器"><a href="#下游收集器" class="header-anchor">#</a> 下游收集器</h2> <ul><li><p><code>groupingBy()</code>会产生一个Map，其每个键对应的值都是一个列表。下游收集器<strong>提供了处理这些列表</strong>的方法</p></li> <li><p>下游收集器本质上还是<code>Collectors.toSet()</code>这种形式的收集器，不过现在用于处理分类后的结果</p></li> <li><p>如想获得集合而不是列表，可使用<code>Collectors.toSet()</code>收集器作为分类的第二参数</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Locale</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> countryToLocales <span class="token operator">=</span> locales<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">Locale</span><span class="token operator">::</span><span class="token function">getCountry</span><span class="token punctuation">,</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>其他常用下游收集器</p> <ul><li><p>==注意：对于收集器默认省略了Collectors.前缀，如Collectors.counting()写为counting()==</p></li> <li><p><code>counting()</code></p> <ul><li>计数</li></ul></li> <li><p><code>summing(Int|Long|Double) (Function mapper)</code></p> <ul><li>求和。接受一个函数为参数，对函数应用到每个元素上得到的返回值求和</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">City</span><span class="token operator">::</span><span class="token function">getState</span><span class="token punctuation">,</span><span class="token function">summingInt</span><span class="token punctuation">(</span><span class="token class-name">City</span><span class="token operator">::</span><span class="token function">getPopulation</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p><code>maxBy(comparator)</code>和<code>minBy(comparator)</code></p> <ul><li>接受一个比较器为参数，返回最大值/最小值</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">City</span><span class="token operator">::</span><span class="token function">getState</span><span class="token punctuation">,</span>
              <span class="token function">maxBy</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span><span class="token class-name">City</span><span class="token operator">::</span><span class="token function">getPopulation</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p><code>mapping(Function mapper,Collector downStream)</code></p> <ul><li>函数mapper应用到下游结果，并将函数返回值传递给另一个收集器</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Optional</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> stateToLongestCityName <span class="token operator">=</span> cities<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>
    <span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">City</span><span class="token operator">::</span><span class="token function">getState</span><span class="token punctuation">,</span>
               <span class="token comment">//将 getName() 应用于分组后的每个元素</span>
              <span class="token function">mapping</span><span class="token punctuation">(</span><span class="token class-name">City</span><span class="token operator">::</span><span class="token function">getName</span><span class="token punctuation">,</span>
                      <span class="token comment">//组中的元素再按照长度进行约简</span>
                     <span class="token function">maxBy</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">::</span><span class="token function">length</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>对于映射函数返回为int、long、double等类型时，可收集汇总到统计对象<code>xxSummaryStatistics</code></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">IntSummaryStatistics</span><span class="token punctuation">&gt;</span></span> stateToSummay <span class="token operator">=</span> cities<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>
    <span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">City</span><span class="token operator">::</span><span class="token function">getState</span><span class="token punctuation">,</span>
              <span class="token function">summarizingInt</span><span class="token punctuation">(</span><span class="token class-name">City</span><span class="token operator">::</span><span class="token function">getPopulation</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>之后可通过统计对象获取和、均值、最值等</li></ul></li></ul></li></ul> <h2 id="约简操作"><a href="#约简操作" class="header-anchor">#</a> 约简操作</h2> <ul><li><p><code>reduce()</code>是一种用于从流中计算某个值的通用机制。有以下几种形式：</p> <ul><li><p><code>reduce(BinaryOperator accumulator)</code></p> <ul><li>接受一个二元函数为参数，并从前两个元素开始持续应用。如求和：</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> values <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> sum <span class="token operator">=</span> values<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token operator">-&gt;</span>x<span class="token operator">+</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//得到的结果为 v0+v1+v2+....+vn</span>
<span class="token comment">//当流为空的时候会返回空的Optional</span>
<span class="token comment">//等价的简写方式为：</span>
<span class="token function">reduce</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token operator">::</span><span class="token function">sum</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>通常，当reduce有一项约简操作为<code>op</code>时，其结果为<code>v1 op v2 op v3.....</code>，该操作必须是<strong>满足结合律</strong>的</li></ul></li> <li><p><code>reduce(identity,accumulator)</code></p> <ul><li>第一种形式需要处理Optional类，第二种形式可避免处理</li> <li>当有一个<strong>幺元e</strong>使得<code>e op x =x</code>时，可利用这个元素作为计算起点，若流为空，则返回幺元</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//加法的幺元为 0 ，因为 0 + x = x</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> values <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token class-name">Integer</span> sum <span class="token operator">=</span> values<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token operator">-&gt;</span>x<span class="token operator">+</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul></li> <li><p><code>collect(supplier,accumulator,combiner)</code>约简</p> <ul><li><p>collect接受三个参数</p> <ul><li>第一个称为<strong>提供者</strong>，通常为构造器</li> <li>第二个称为<strong>累积器</strong>，其将元素添加到一个实例上，如add方法</li> <li>第三个称为<strong>组合器</strong>，将两个实例合并成一个，如addAll</li></ul></li> <li><p>操作位集示例</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">BitSet</span> result <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">BitSet</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">,</span><span class="token class-name">BitSet</span><span class="token operator">::</span><span class="token function">set</span><span class="token punctuation">,</span><span class="token class-name">BitSet</span><span class="token operator">::</span><span class="token function">or</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul></li></ul> <h2 id="基本类型流"><a href="#基本类型流" class="header-anchor">#</a> 基本类型流</h2> <ul><li><p>对于基本类型：double、float、long、short、char、byte、boolean，若用包装类封装是比较低效的。</p></li> <li><p>流库中提供了<code>IntStream</code>、<code>LongStream</code>、<code>DoubleStream</code>用于直接存储基本类型值，无需包装类如Integer</p></li> <li><p>对short、boolean、byte、char可使用IntStream，对于float可使用DoubleStream</p></li> <li><p>对于流的创建，方法与创建其他流类似。对于IntStream和LongStream还有特殊的两个方法：</p> <ul><li><code>range(start,end)</code></li> <li><code>rangeClosed(start,end)</code></li> <li>二者可生成步长为 1 的整数范围。<strong>后者取值包含end，前者不包含</strong></li></ul></li> <li><p><code>CharSequence</code>接口拥有一个<code>codePoints()</code>和<code>chars()</code>方法，可以生成由字符的Unicode码或UTF-16编码机制的码元构成的<code>IntStream</code></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">String</span> sentence <span class="token operator">=</span> <span class="token string">&quot;\uD835\uDD46&quot;</span> is the set of octonions<span class="token punctuation">;</span>
<span class="token comment">// \uD835\uDD46 是一个字符的UTF-16编码</span>

<span class="token class-name">IntStream</span> codes <span class="token operator">=</span> sentence<span class="token punctuation">.</span><span class="token function">codePoints</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//该Stream包含十六进制值 1D546 20 69 73 20 ......</span>
</code></pre></div></li> <li><p>当有个对象流时，若要将其转化为基本流，可使用<code>mapToInt()</code>、<code>mapToLong()</code>、<code>mapToDouble()</code>进行转化</p> <ul><li>若将一个字符串流的长度转换为处理为整数：</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> words<span class="token operator">=</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token class-name">IntStream</span> lengths <span class="token operator">=</span> words<span class="token punctuation">.</span><span class="token function">mapToInt</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">::</span><span class="token function">length</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>基本类型流转换为对象流使用<code>boxed()</code>方法</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> integers <span class="token operator">=</span> <span class="token class-name">IntStream</span><span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">boxed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>==Random类具有ints()、longs()、doubles()方法，可返回由随机数构成的基本类型流==</p></li></ul> <h2 id="并行流"><a href="#并行流" class="header-anchor">#</a> 并行流</h2> <ul><li>使用<code>parallelStream()</code>可以创建一个并行流</li> <li>传递给并行流的操作函数需要可以安全地并行执行</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.9fc73bf5.js" defer></script><script src="/assets/js/2.0c4bddf9.js" defer></script><script src="/assets/js/1.50b457b8.js" defer></script><script src="/assets/js/32.e88c0552.js" defer></script>
  </body>
</html>
