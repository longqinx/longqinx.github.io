<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JVM笔记 | Longqinx&#39;s Notes</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/assets/css/0.styles.9f84806b.css" as="style"><link rel="preload" href="/assets/js/app.969a6014.js" as="script"><link rel="preload" href="/assets/js/2.0c4bddf9.js" as="script"><link rel="preload" href="/assets/js/1.50b457b8.js" as="script"><link rel="preload" href="/assets/js/30.dfc04b59.js" as="script"><link rel="prefetch" href="/assets/js/10.325b9f09.js"><link rel="prefetch" href="/assets/js/11.845e3692.js"><link rel="prefetch" href="/assets/js/12.ecdb524b.js"><link rel="prefetch" href="/assets/js/13.3f3f6a36.js"><link rel="prefetch" href="/assets/js/14.eb7a3d07.js"><link rel="prefetch" href="/assets/js/15.b60f3925.js"><link rel="prefetch" href="/assets/js/16.85253907.js"><link rel="prefetch" href="/assets/js/17.c2838453.js"><link rel="prefetch" href="/assets/js/18.3256f17f.js"><link rel="prefetch" href="/assets/js/19.d8afd0ae.js"><link rel="prefetch" href="/assets/js/20.10e47ab9.js"><link rel="prefetch" href="/assets/js/21.33b300c9.js"><link rel="prefetch" href="/assets/js/22.271589f5.js"><link rel="prefetch" href="/assets/js/23.f187cd00.js"><link rel="prefetch" href="/assets/js/24.25d46f1d.js"><link rel="prefetch" href="/assets/js/25.6dbe905b.js"><link rel="prefetch" href="/assets/js/26.be06b78c.js"><link rel="prefetch" href="/assets/js/27.c1cdaecc.js"><link rel="prefetch" href="/assets/js/28.c84982d2.js"><link rel="prefetch" href="/assets/js/29.75d6d01f.js"><link rel="prefetch" href="/assets/js/3.af33e5d6.js"><link rel="prefetch" href="/assets/js/31.e768d834.js"><link rel="prefetch" href="/assets/js/32.bd424b57.js"><link rel="prefetch" href="/assets/js/33.e9f62ae9.js"><link rel="prefetch" href="/assets/js/34.6e660565.js"><link rel="prefetch" href="/assets/js/35.259ec1af.js"><link rel="prefetch" href="/assets/js/36.cabec235.js"><link rel="prefetch" href="/assets/js/37.62de5401.js"><link rel="prefetch" href="/assets/js/38.65324daa.js"><link rel="prefetch" href="/assets/js/39.d859ec36.js"><link rel="prefetch" href="/assets/js/4.45665f8a.js"><link rel="prefetch" href="/assets/js/40.3d954b2a.js"><link rel="prefetch" href="/assets/js/5.7098d77a.js"><link rel="prefetch" href="/assets/js/6.0c0a0f39.js"><link rel="prefetch" href="/assets/js/7.6a854e57.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.77260563.js">
    <link rel="stylesheet" href="/assets/css/0.styles.9f84806b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.png" alt="Longqinx's Notes" class="logo"> <span class="site-name can-hide">Longqinx's Notes</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/java/" class="nav-link router-link-active">
  Java
</a></div><div class="nav-item"><a href="/c++/" class="nav-link">
  C/C++
</a></div><div class="nav-item"><a href="/linux/" class="nav-link">
  Linux
</a></div><div class="nav-item"><a href="/dsa/" class="nav-link">
  数据结构与算法
</a></div><div class="nav-item"><a href="/project/" class="nav-link">
  我的小项目
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="关于" class="dropdown-title"><span class="title">关于</span> <span class="arrow down"></span></button> <button type="button" aria-label="关于" class="mobile-dropdown-title"><span class="title">关于</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/about/contactMe.html" class="nav-link">
  联系我
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/java/" class="nav-link router-link-active">
  Java
</a></div><div class="nav-item"><a href="/c++/" class="nav-link">
  C/C++
</a></div><div class="nav-item"><a href="/linux/" class="nav-link">
  Linux
</a></div><div class="nav-item"><a href="/dsa/" class="nav-link">
  数据结构与算法
</a></div><div class="nav-item"><a href="/project/" class="nav-link">
  我的小项目
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="关于" class="dropdown-title"><span class="title">关于</span> <span class="arrow down"></span></button> <button type="button" aria-label="关于" class="mobile-dropdown-title"><span class="title">关于</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/about/contactMe.html" class="nav-link">
  联系我
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>JVM笔记</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#运行时数据区域" class="sidebar-link">运行时数据区域</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#程序计数器" class="sidebar-link">程序计数器</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#java虚拟机栈" class="sidebar-link">Java虚拟机栈</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#本地方法栈" class="sidebar-link">本地方法栈</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#java堆" class="sidebar-link">Java堆</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#方法区" class="sidebar-link">方法区</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#运行时常量池" class="sidebar-link">运行时常量池</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#直接内存" class="sidebar-link">直接内存</a></li></ul></li><li><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#hotspot虚拟机对象" class="sidebar-link">HotSpot虚拟机对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#对象创建" class="sidebar-link">对象创建</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#对象的内存布局" class="sidebar-link">对象的内存布局</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#对象的访问定位" class="sidebar-link">对象的访问定位</a></li></ul></li><li><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#outofmemoryerror" class="sidebar-link">OutOfMemoryError</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#java堆溢出" class="sidebar-link">Java堆溢出</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#方法区和运行时常量池溢出" class="sidebar-link">方法区和运行时常量池溢出</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#本机直接内存溢出" class="sidebar-link">本机直接内存溢出</a></li></ul></li><li><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#垃圾收集与内存分配概述" class="sidebar-link">垃圾收集与内存分配概述</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#对象的生死" class="sidebar-link">对象的生死？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#引用计数算法" class="sidebar-link">引用计数算法</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#可达性分析算法" class="sidebar-link">可达性分析算法</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#引用的扩充" class="sidebar-link">引用的扩充</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#何时死亡" class="sidebar-link">何时死亡</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#回收方法区" class="sidebar-link">回收方法区</a></li></ul></li><li><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#垃圾收集算法" class="sidebar-link">垃圾收集算法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#分代收集理论" class="sidebar-link">分代收集理论</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#标记-清除算法" class="sidebar-link">标记-清除算法</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#标记-复制算法" class="sidebar-link">标记-复制算法</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#标记-整理算法" class="sidebar-link">标记-整理算法</a></li></ul></li><li><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#基础故障处理工具" class="sidebar-link">基础故障处理工具</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#jps-虚拟机进程状态工具" class="sidebar-link">jps：虚拟机进程状态工具</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#jstat-虚拟机统计信息监视工具" class="sidebar-link">jstat：虚拟机统计信息监视工具</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#jinfo-java配置信息工具" class="sidebar-link">jinfo：Java配置信息工具</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#jmap-java内存映像工具" class="sidebar-link">jmap：Java内存映像工具</a></li></ul></li><li><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#可视化故障处理工具" class="sidebar-link">可视化故障处理工具</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#jhsdb" class="sidebar-link">JHSDB</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#jconsole" class="sidebar-link">JConsole</a></li></ul></li><li><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#类文件结构" class="sidebar-link">类文件结构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#class类文件结构" class="sidebar-link">Class类文件结构</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#魔数与class类文件版本" class="sidebar-link">魔数与Class类文件版本</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#常量池" class="sidebar-link">常量池</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#字节码分析工具-javap" class="sidebar-link">#字节码分析工具：javap</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#访问标志" class="sidebar-link">访问标志</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#类索引、父类索引、接口索引集合" class="sidebar-link">类索引、父类索引、接口索引集合</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#字段表集合" class="sidebar-link">字段表集合</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#方法表集合" class="sidebar-link">方法表集合</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#属性表集合" class="sidebar-link">属性表集合</a></li></ul></li><li><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#字节码指令" class="sidebar-link">字节码指令</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#字节码与数据类型" class="sidebar-link">字节码与数据类型</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#加载和存储指令" class="sidebar-link">加载和存储指令</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#运算指令" class="sidebar-link">运算指令</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#类型转换" class="sidebar-link">类型转换</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#对象创建与访问指令" class="sidebar-link">对象创建与访问指令</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#操作数栈管理指令" class="sidebar-link">操作数栈管理指令</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#控制转移指令" class="sidebar-link">控制转移指令</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#方法调用与返回指令" class="sidebar-link">方法调用与返回指令</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#同步指令" class="sidebar-link">同步指令</a></li></ul></li><li><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#虚拟机类加载机制" class="sidebar-link">虚拟机类加载机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#类加载时机" class="sidebar-link">类加载时机</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#类加载过程-加载" class="sidebar-link">类加载过程——加载</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#类加载过程-验证" class="sidebar-link">类加载过程——验证</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#类加载过程-准备" class="sidebar-link">类加载过程——准备</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#类加载过程-解析" class="sidebar-link">类加载过程——解析</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#类加载过程-初始化" class="sidebar-link">类加载过程——初始化</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#类与类加载器" class="sidebar-link">类与类加载器</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#双亲委派模型" class="sidebar-link">双亲委派模型</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#java模块化系统" class="sidebar-link">Java模块化系统</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#模块的兼容性" class="sidebar-link">模块的兼容性</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#模块化下的类加载器" class="sidebar-link">模块化下的类加载器</a></li></ul></li><li><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#虚拟机字节码执行引擎" class="sidebar-link">虚拟机字节码执行引擎</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#运行时栈帧结构" class="sidebar-link">运行时栈帧结构</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#栈帧之局部变量表" class="sidebar-link">栈帧之局部变量表</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#栈帧之操作数栈" class="sidebar-link">栈帧之操作数栈</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#栈帧之动态链接" class="sidebar-link">栈帧之动态链接</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#栈帧之方法返回地址" class="sidebar-link">栈帧之方法返回地址</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#栈帧之附加信息" class="sidebar-link">栈帧之附加信息</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#方法调用" class="sidebar-link">方法调用</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#方法调用-解析" class="sidebar-link">方法调用——解析</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#方法调用-分派" class="sidebar-link">方法调用——分派</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#动态类型语言支持-动态类型语言" class="sidebar-link">动态类型语言支持——动态类型语言</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#java与动态类型" class="sidebar-link">Java与动态类型</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#java-lang-invoke包" class="sidebar-link">java.lang.invoke包</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#invokedynamic指令" class="sidebar-link">invokedynamic指令</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#基于栈的指令集与基于寄存器的指令集" class="sidebar-link">基于栈的指令集与基于寄存器的指令集</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#基于栈的解释器执行过程" class="sidebar-link">基于栈的解释器执行过程</a></li></ul></li><li><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#类加载及执行子系统案例" class="sidebar-link">类加载及执行子系统案例</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#tomcat-正统的类加载器架构" class="sidebar-link">Tomcat：正统的类加载器架构</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#osgi-灵活的类加载器架构" class="sidebar-link">OSGi：灵活的类加载器架构</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#字节码生成技术和动态代理实现" class="sidebar-link">字节码生成技术和动态代理实现</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#backport工具" class="sidebar-link">Backport工具</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#实战-远程执行功能实现" class="sidebar-link">实战：远程执行功能实现</a></li></ul></li><li><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#高效并发" class="sidebar-link">高效并发</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#java内存模型" class="sidebar-link">Java内存模型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#主内存与工作内存" class="sidebar-link">主内存与工作内存</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#内存间的交互操作" class="sidebar-link">内存间的交互操作</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#volatile类型变量的特殊规则" class="sidebar-link">volatile类型变量的特殊规则</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#long和double的非原子性协定" class="sidebar-link">long和double的非原子性协定</a></li></ul></li><li><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#java与线程" class="sidebar-link">Java与线程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#线程的实现" class="sidebar-link">线程的实现</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#java线程调度" class="sidebar-link">Java线程调度</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#状态转换" class="sidebar-link">状态转换</a></li></ul></li><li><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#线程安全" class="sidebar-link">线程安全</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#java语言种的线程安全" class="sidebar-link">Java语言种的线程安全</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#线程安全的实现方法" class="sidebar-link">线程安全的实现方法</a></li></ul></li><li><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#锁优化" class="sidebar-link">锁优化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#自旋锁与自适应自旋-adaptive-spinning" class="sidebar-link">自旋锁与自适应自旋(Adaptive Spinning)</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#锁消除-lock-elimination" class="sidebar-link">锁消除(Lock Elimination)</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#锁粗化-lock-coarsening" class="sidebar-link">锁粗化(Lock Coarsening)</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#轻量级锁-light-weight-locking" class="sidebar-link">轻量级锁(Light-Weight Locking)</a></li><li class="sidebar-sub-header"><a href="/java/JVM%E7%AC%94%E8%AE%B0.html#偏向锁-biased-locking" class="sidebar-link">偏向锁(Biased Locking)</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="jvm笔记"><a href="#jvm笔记" class="header-anchor">#</a> JVM笔记</h1> <h2 id="运行时数据区域"><a href="#运行时数据区域" class="header-anchor">#</a> 运行时数据区域</h2> <ul><li><p>Java 虚拟机所管理的内存包括以下运行时数据区：</p> <ul><li>方法区</li> <li>堆</li> <li>虚拟机栈</li> <li>本地方法栈</li> <li>程序计数器</li></ul></li> <li><p>其中，<strong>方法区和堆是所有线程共享的</strong>，其他三个区域是线程隔离的</p> <p><img src="/jvm-pic/image-20210405171022000.png" alt="image-20210405171022000"></p></li></ul> <h3 id="程序计数器"><a href="#程序计数器" class="header-anchor">#</a> 程序计数器</h3> <ul><li>一块较小的内存区域，可视为<strong>当前线程执行的字节码的行号指示器</strong></li> <li>每个线程都有独立的计数器且相互不影响，为线程私有</li> <li>当线程执行的是一个Java方法时，程序计数器指向执行的字节码指令的地址。若执行本地方法(Native Method)，则计数器的值应该为空(Undifined)</li> <li>此区域是JVM规范中唯一没有规定OutOfMemoryError的区域</li></ul> <h3 id="java虚拟机栈"><a href="#java虚拟机栈" class="header-anchor">#</a> Java虚拟机栈</h3> <ul><li>线程私有。生命周期同线程</li> <li>虚拟机栈描述Java方法执行的线程内存模型
<ul><li>每个方法被执行的时候，虚拟机会创建一个帧栈用于存储局部变量表、操作数栈、动态链接、方法出口等信息</li></ul></li> <li>在此内存区域中，线程请求栈深度大于区域允许最大深度时，将抛出<strong>StackOverFlow</strong>异常</li></ul> <h3 id="本地方法栈"><a href="#本地方法栈" class="header-anchor">#</a> 本地方法栈</h3> <ul><li>类似于Java虚拟机栈，不过本地方法栈为调用本地方法(Native Method)服务</li> <li>有些Java虚拟机将本地方法栈和Java虚拟机栈进行了合并</li></ul> <h3 id="java堆"><a href="#java堆" class="header-anchor">#</a> Java堆</h3> <ul><li>Java虚拟机管理内存的最大的一块。被所有线程共享</li> <li>在虚拟机启动时创建</li> <li>几乎所有的数组和对象的内存都是在堆上分配的(常量放在常量池？——方法区)</li> <li>Java堆是垃圾收集器管理的区域，因此也成为<strong>GC堆</strong></li> <li>目前主流的Java堆大小都是可扩展的，可通过参数 <strong>-Xmx和-Xms</strong> 设定</li> <li>内存分配完时，抛出OutOfMemory异常</li></ul> <h3 id="方法区"><a href="#方法区" class="header-anchor">#</a> 方法区</h3> <ul><li>线程共享的区域</li> <li>用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等数据</li> <li>此区域回收内存的主要目标是常量池的回收和类型卸载</li></ul> <h3 id="运行时常量池"><a href="#运行时常量池" class="header-anchor">#</a> 运行时常量池</h3> <ul><li>方法区的一部分</li> <li>Class文件中除了有类的版本、字段、方法、接口等描述信息，还有一项信息是<strong>常量池表</strong></li> <li>常量池表用于存放编译期生成的各种<strong>字面量</strong>和<strong>符号引用</strong>。此部分会在类加载后放到方法区的常量池中</li></ul> <h3 id="直接内存"><a href="#直接内存" class="header-anchor">#</a> 直接内存</h3> <ul><li>直接内存并<strong>不是</strong>虚拟机运行时数据区的一部分</li> <li>也可能导致OutOfMemory异常</li> <li>Java的NIO引入了基于通道(Channel)与缓冲区(Buffer)的IO方式，其可使用Native函数库直接分配<strong>堆外内存</strong>，然后通过存储在Java堆中的<code>DirectByteBuffer</code>对象作为这块内存的引用进行操作，这样可在某些场景提高性能，避免Java堆和Native堆中来回复制数据</li></ul> <h2 id="hotspot虚拟机对象"><a href="#hotspot虚拟机对象" class="header-anchor">#</a> HotSpot虚拟机对象</h2> <h3 id="对象创建"><a href="#对象创建" class="header-anchor">#</a> 对象创建</h3> <ul><li>当JVM遇到一条字节码<code>new</code>指令时，首先检查此指令的参数能否在常量池定位到一个类的符号引用，并检查此符号引用代表的类是否已经加载、解析和初始化。若没有则先执行<strong>类加载</strong>过程</li> <li>内存分配的两种常见方式
<ul><li>指针碰撞(Bump The Pointer)
<ul><li>当Java堆的内存是绝对规整时(已分配的放一边，未分配的放一边，中间用指针作为分界)，分配内存只需要将指针往空闲方向移动对象大小的距离</li></ul></li> <li>空闲列表(FreeList)
<ul><li>当Java堆内存非规整时，虚拟机需要维护一个列表记录哪些内存块可以分配，分配时划分给对象并更新表</li></ul></li></ul></li> <li>为了解决分配内存存在的<strong>并发安全</strong>问题，有两种方案：
<ul><li>对分配空间的操作进行同步处理：CAS(Compare And Swap)+失败重试</li> <li>把分配内存的操作按线程划分在不同的空间中：每个线程预先在Java堆中分配一小块内存——本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)。当线程的缓冲区用完时才需要同步</li> <li>虚拟机是否使用TLAB，通过 <strong>-XX +/-useTLAB</strong> 设定</li></ul></li> <li>内存分配完成后，虚拟机将新分配的空间( 不包含对象头)<strong>初始化为零值</strong>，保证对象实例字段不用初始化就能使用。使用了TLAB时可将初始化零值的过程放到TLAB分配时进行</li> <li>之后，JVM还要对对象进行必要设置，如对象是哪个类的实例、如何找到类的元数据信息、对象的GC分代年龄信息等。这些信息存放在 <strong>对象头(Object Header)</strong> 中</li> <li>经过上述步骤后，从JVM的角度，对象已经创建了，但从Java程序的角度，对象创建才刚开始：对象的<strong>构造函数</strong>，即<code>Class</code>文件中的<code>&lt;init&gt;()</code>方法还没执行，所有字段都为零值</li></ul> <h3 id="对象的内存布局"><a href="#对象的内存布局" class="header-anchor">#</a> 对象的内存布局</h3> <ul><li>在HotSpot中，对象在Java堆中的存储布局可分为三部分：<strong>对象头(Header)</strong>、<strong>实例数据(Instance Data)</strong>、<strong>对齐填充(Padding)</strong></li> <li><strong>对象头</strong>包含两类信息：
<ul><li>存储对象自身的运行时数据：哈希值、GC分代年龄、锁状态标志、偏向线程ID等。此部分在32、64位的虚拟机中分别占32、64bit，官方称为<strong>Mark Word</strong></li> <li>指针类型：对象指向其类型元数据的指针。JVM通过该指针确定对象是哪个类的实例</li></ul></li> <li><strong>实例数据</strong>部分是对象真正存储的有效信息，即各种字段的内容
<ul><li>此部分的存储顺序会受到虚拟机分配策略参数 <strong>-XX: FieldsAllocationStyle</strong> 和字段在代码中定义顺序的影响</li> <li>默认分配顺序为：longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers,OOPs）</li> <li>若参数 <strong>+XX: CompactFields</strong> 为 true，子类中的较窄的变量也允许插入父类变量的空隙中以节省空间</li></ul></li> <li><strong>对齐填充</strong>部分不是必然存在的，也没有特殊含义。仅起占位符的作用
<ul><li>HotSpot虚拟机的自动内存管理<strong>要求对象的起始地址必须是8字节的整数倍</strong>，即任何对象的大小都是 8 的整数倍</li> <li>当实例数据没有对齐，则由填充来实现8字节整数倍的需求</li></ul></li></ul> <h3 id="对象的访问定位"><a href="#对象的访问定位" class="header-anchor">#</a> 对象的访问定位</h3> <ul><li>Java程序会通过栈上的<code>reference</code>数据来操作堆上的具体对象</li> <li>主流的访问方式主要有使用<strong>句柄</strong>和<strong>直接指针</strong>两种
<ul><li>使用句柄访问时，Java堆中可能会划分一块内存作为句柄池，此时<code>reference</code>中存储的就是对象句柄地址，而句柄中包含的时对象的实际数据地址</li> <li>使用指针直接访问时，Java堆中的对象的内存布局需要考虑如何放置访问<strong>类型数据</strong>的相关信息，<code>reference</code>中存储的就是对象的直接地址(数据)。访问对象时不需要多一次寻址开销</li></ul></li></ul> <h2 id="outofmemoryerror"><a href="#outofmemoryerror" class="header-anchor">#</a> OutOfMemoryError</h2> <h3 id="java堆溢出"><a href="#java堆溢出" class="header-anchor">#</a> Java堆溢出</h3> <ul><li>设置堆大小的参数：
<ul><li><code>-Xms</code>：堆的最小值，如-Xms20M</li> <li><code>-Xmx</code>：堆的最大值</li> <li>当上述两个值相等时，限制堆的大小不可扩展</li></ul></li> <li>Java堆用于存储对象，只要不断创建对象并保证GC Roots到对象之间有可达路径则其不会被回收</li></ul> <h3 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="header-anchor">#</a> 方法区和运行时常量池溢出</h3> <ul><li>JDK8开始，以前的“永久代”被“元空间”替代</li> <li>从JDK7开始，原本放在永久代中的字符串常量池被移到<strong>Java堆中</strong></li> <li>Java8中，HotSpot提供了一些参数作为元空间的防御措施，主要包括：
<ul><li><code>-XX:MaxMetaspaceSize</code>：设置元空间最大值，默认为 -1 ，即不限制(只受限于本地内存)</li> <li><code>-XX:MetaspaceSize</code>：指定元空间初始大小，单位为字节。达到该值就会触发垃圾收集进行类卸载</li> <li><code>-XX:MinMetaspaceFreeRatio</code>：垃圾收集之后控制最小的元空间剩余容量的百分比。可减少因为元空间不足导致的垃圾收集频率</li></ul></li></ul> <h3 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="header-anchor">#</a> 本机直接内存溢出</h3> <ul><li>直接内存的容量可通过<code>-XX:MaxDirectMemorySize</code>指定，不指定则默认值同Java堆大小</li> <li>在使用<code>DirectByteBuffer</code>分配内存时可能会抛出内存溢出异常，但是抛出异常时并未真正向操作系统请求分配内存。而是直接通过计算判断</li> <li>真正分配内存可使用<code>Unsafe::allocateMemory()</code>方法</li></ul> <h2 id="垃圾收集与内存分配概述"><a href="#垃圾收集与内存分配概述" class="header-anchor">#</a> 垃圾收集与内存分配概述</h2> <ul><li>Java运行时内存区中，程序计数器、虚拟机栈、本地方法区3部分随线程生灭。栈中的栈帧随方法的进入和退出有序地进栈退栈</li> <li>栈帧中分配多少内存<strong>基本上在类结构确定时就已知的</strong>，因此在上述区域中，不用过多考虑如何回收内存。在线程结束是会自动回收</li> <li>而对于<strong>Java堆，只有在运行时才能确定要创建哪些对象，需要多少内存</strong>，因此，垃圾回收机制主要管理的就是Java堆的内存回收</li></ul> <h2 id="对象的生死"><a href="#对象的生死" class="header-anchor">#</a> 对象的生死？</h2> <h3 id="引用计数算法"><a href="#引用计数算法" class="header-anchor">#</a> 引用计数算法</h3> <ul><li>在对象中添加一个<strong>引用计数器</strong>，每当有一个地方引用时，计数器值加一，当引用失效时，计数器减一，当计数器的值为 0 时，表示此对象已经不再被使用</li> <li>但主流的Java虚拟机并未使用引用计数，因为其可能存在一些难以处理的如循环引用的情况</li></ul> <h3 id="可达性分析算法"><a href="#可达性分析算法" class="header-anchor">#</a> 可达性分析算法</h3> <ul><li><p>Java、C#等语言都使用可达性分析(Reachability Analysis)算法判定对象是否存活</p></li> <li><p>算法的思路为：通过一些列被称为<strong>GC Roots</strong>的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程走过的路径称为<strong>引用链(Reference Chain)</strong>，若某对象到GC Roots之间没有任何引用链(图论术语不可达)，则该对象不会再被使用</p> <p><img src="/jvm-pic/image-20210407222234130.png" alt="image-20210407222234130"></p></li></ul> <h3 id="引用的扩充"><a href="#引用的扩充" class="header-anchor">#</a> 引用的扩充</h3> <ul><li>JDK1.2后，Java对引用进行了扩充，将引用分为：
<ul><li>强引用(Strongly Reference)
<ul><li>最传统的引用方式。如<code>Object obj = new Object()</code>这种引用关系。只要有强引用，GC就不会回收该对象</li></ul></li> <li>软引用(Soft Reference)
<ul><li>描述一些还有用但非必须的对象</li> <li>通过<code>SoftReference</code>类实现软引用</li> <li>只被软引用引用的对象<strong>在系统将要发生内存溢出前被列进回收返回进行二次回收</strong>，回收后仍不够内存才抛出异常</li></ul></li> <li>弱引用(Weak Reference)
<ul><li>描述有用但非必须的对象，比软引用更弱</li> <li>通过<code>WeakReference</code>类实现弱引用</li> <li>被弱引用的对象<strong>只能生存到下一次垃圾回收</strong>发生为止。下一次垃圾回收发生时，弱引用的对象就会被回收，不管内存是否足够</li></ul></li> <li>虚引用(Phantom Reference)
<ul><li>最弱的引用关系。对象是否有虚引用的存在完全不影响其生存周期。</li> <li>无法通过虚引用获得对象实例</li> <li>用虚引用的唯一目的是为了能在对象被回收时收到一个系统通知</li> <li>使用<code>PhantomReference</code>类实现虚引用</li></ul></li></ul></li></ul> <h3 id="何时死亡"><a href="#何时死亡" class="header-anchor">#</a> 何时死亡</h3> <ul><li><p>在可达性分析中判定为不可达的对象并非一定被回收不可，此时还处于“缓刑”阶段</p></li> <li><p>一个对象真正“死亡”至少需要经过两次标记</p> <ul><li>可达性分析时不可达则被<strong>第一次标记</strong>。随后进行一次筛选，条件是此对象是否有必要执行<code>finalize()</code>方法，若对象没有覆盖<code>finalize()</code>方法或已经被虚拟机调用，则认为没有必要执行</li> <li>若对象被判定有必要执行<code>finalize()</code>方法，则该对象被放在一个叫<strong>F-Queue</strong>的队列中，并在之后由一个虚拟机创建的、低调度优先级的<strong>Finalizer</strong>线程去执行对象的<code>finalize()</code>方法</li> <li><code>finalize()</code>方法是对象不被回收的最后的机会。稍后垃圾收集将对<strong>F-Queue</strong>中的对象进行<strong>第二次小规模标记</strong>。对象可通过<code>finalize()</code>方法将自己关联到引用链上即可避免被回收(虽然执行了finalize())，否则就会被回收</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
* 此代码演示了两点：
* 1.对象可以在被GC时自我拯救。
* 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次
*/</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FinalizeEscapeGC</span> <span class="token punctuation">{</span>
    <span class="token comment">// 可作为GC Roots 的静态变量</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">FinalizeEscapeGC</span> <span class="token constant">SAVE_HOOK</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;yes, i am still alive :)&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">//重写 finalize 方法</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;finalize method executed!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//将 this 赋给静态变量，挂在引用链上，实现“自我救赎”</span>
        <span class="token class-name">FinalizeEscapeGC</span><span class="token punctuation">.</span><span class="token constant">SAVE_HOOK</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
        <span class="token constant">SAVE_HOOK</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FinalizeEscapeGC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//对象第一次成功拯救自己</span>
        <span class="token constant">SAVE_HOOK</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token comment">//手动调用垃圾回收</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">SAVE_HOOK</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token constant">SAVE_HOOK</span><span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;no, i am dead :(&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了，因为finalize()只调用一次</span>
        <span class="token constant">SAVE_HOOK</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">SAVE_HOOK</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token constant">SAVE_HOOK</span><span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;no, i am dead :(&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p><code>finalize()</code>方法运行代价高且具有不确定性，无法得知哪个对象的该方法先被调用，一般不推荐使用</p></li></ul> <h3 id="回收方法区"><a href="#回收方法区" class="header-anchor">#</a> 回收方法区</h3> <ul><li>方法区的垃圾回收主要回收两部分内容：
<ul><li>废弃的常量</li> <li>不再使用的类型</li></ul></li> <li>判断常量是否被引用的条件相对简单，而判断类型是否是不再使用的类，需要同时满足三个条件
<ul><li>该类所有的实例都已经被回收</li> <li>加载该类的类加载器已经被回收</li> <li>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用</li></ul></li> <li>对于同时满足上述三个条件的类型，虚拟机<strong>允许</strong>该类型被回收，而具体的类型是否被回收取决于虚拟机参数</li> <li>HotSpot提供了<code>-Xnoclassgc</code>参数用于指定不回收类型</li> <li>此外，可使用<code>-verbose:class</code>以及<code>-XX:+TraceClassLoading</code>、<code>-XX:+TraceClassUnLoading</code>查看类加载和卸载信息。其中，前二者可在Product版虚拟机中使用，后者需要FastDebug版虚拟机支持</li> <li>在大量使用反射、动态代理、GCLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常需要虚拟机具备类型卸载能力</li></ul> <h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="header-anchor">#</a> 垃圾收集算法</h2> <h3 id="分代收集理论"><a href="#分代收集理论" class="header-anchor">#</a> 分代收集理论</h3> <ul><li>多数商业虚拟机都遵循了“分代收集理论”</li> <li>建立在两个假说之上
<ul><li><strong>弱分代假说</strong> <ul><li>绝大多数对象都是朝生夕灭的</li></ul></li> <li><strong>强分代假说</strong> <ul><li>熬过越多次垃圾回收过程的对象越难消亡</li></ul></li></ul></li> <li>根据上述假说，衍生出多数垃圾收集的原则：将Java堆划分为多个区域，然后将回收对象<strong>根据年龄</strong>分配到不同区域</li> <li>根据区域划分回收，衍生出垃圾回收的分类：MinorGC、MajorGC、FullGC</li> <li>分代理论在具体的虚拟机上，体现为至少将Java堆划分为<strong>新生代(Young Generation)<strong>和</strong>老年代(Old Generation)</strong></li> <li>新生代中每次回收都会有大量对象“死去”，存留下来的逐渐进入老年代</li> <li>收集分类：
<ul><li>新生代收集(MinorGC/YoungGC)：只回收新生代</li> <li>老年代收集(MajorGC/OldGC)：只回收老年代</li> <li>混合收集(MixedGC)：整个新生代和部分老年代</li> <li>整堆收集(FullGC)：整个Java堆和方法区</li></ul></li></ul> <h3 id="标记-清除算法"><a href="#标记-清除算法" class="header-anchor">#</a> 标记-清除算法</h3> <h3 id="标记-复制算法"><a href="#标记-复制算法" class="header-anchor">#</a> 标记-复制算法</h3> <h3 id="标记-整理算法"><a href="#标记-整理算法" class="header-anchor">#</a> 标记-整理算法</h3> <h2 id="基础故障处理工具"><a href="#基础故障处理工具" class="header-anchor">#</a> 基础故障处理工具</h2> <h3 id="jps-虚拟机进程状态工具"><a href="#jps-虚拟机进程状态工具" class="header-anchor">#</a> jps：虚拟机进程状态工具</h3> <ul><li><p>jps(JVM Process Status)：列出正在运行的虚拟机进程，并显示虚拟机执行主类(main函数所在类)名称，以及这些进程的本地虚拟机唯一ID</p></li> <li><p>格式</p> <div class="language-bash extra-class"><pre class="language-bash"><code>jps <span class="token punctuation">[</span>options<span class="token punctuation">]</span> <span class="token punctuation">[</span>hostid<span class="token punctuation">]</span>
</code></pre></div></li> <li><p>主要选项</p> <ul><li>-q：只输出LVMID(本地虚拟机ID)，省略主类名称</li> <li>-m：输出虚拟机启动时传递给main()函数的参数</li> <li>-l：输出主类的全名，若执行的是jar包，则输出jar路径</li> <li>-v：输出虚拟机进程启动时的JVM参数</li></ul></li></ul> <h3 id="jstat-虚拟机统计信息监视工具"><a href="#jstat-虚拟机统计信息监视工具" class="header-anchor">#</a> jstat：虚拟机统计信息监视工具</h3> <ul><li><p>jstat(JVM statistics Monitoring Tool)：用于监视虚拟机各种运行状态信息的命令工具</p></li> <li><p>可显示本地或远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行数据</p></li> <li><p>格式</p> <div class="language-bash extra-class"><pre class="language-bash"><code>jstat <span class="token punctuation">[</span>option vmid <span class="token punctuation">[</span>intervals<span class="token punctuation">[</span>s<span class="token operator">|</span>ms<span class="token punctuation">]</span> <span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token punctuation">]</span>
</code></pre></div></li> <li><p>对于vmid，在本地使用时同LVMID，远程时应使用以下格式：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token punctuation">[</span>protocol:<span class="token punctuation">]</span> <span class="token punctuation">[</span>//<span class="token punctuation">]</span> lvmid<span class="token punctuation">[</span>@hostname<span class="token punctuation">[</span>:port<span class="token punctuation">]</span>/servername<span class="token punctuation">]</span>
</code></pre></div></li> <li><p>参数intervals 和 count表示查询间隔和次数</p></li> <li><p>假设需要每250ms查询2764进程的GC信息(20次)：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>jstat <span class="token parameter variable">-gc</span> <span class="token number">2764</span> <span class="token number">250</span> <span class="token number">20</span>
</code></pre></div></li></ul> <h3 id="jinfo-java配置信息工具"><a href="#jinfo-java配置信息工具" class="header-anchor">#</a> jinfo：Java配置信息工具</h3> <ul><li>jinfo(Configuration Info forJava)：实时查看和调整虚拟机各项参数</li> <li>可使用<code>jinfo -flag</code>进行未被显式指定参数的系统默认值</li> <li>也可用<code>jinfo -sysprops</code>把虚拟机进程的System.getProperties()打印出来</li> <li>使用<code>jinfo -flag [+/-]name</code>或<code>jinfo -flag name=value</code>的方式可动态修改一些虚拟机参数</li></ul> <h3 id="jmap-java内存映像工具"><a href="#jmap-java内存映像工具" class="header-anchor">#</a> jmap：Java内存映像工具</h3> <ul><li><p>jmap(Memory Map for Java)：用于生成堆转储快照(heap dump或dump文件)</p></li> <li><p>jmap的作用不仅仅是获取堆转存快照，还可以查询finalize执行队列、Java堆和方法区的详细信息。如空间使用率、使用何种GC收集器等</p></li> <li><p>jmap主要选项</p> <table><thead><tr><th>选项</th> <th>描述</th></tr></thead> <tbody><tr><td>-dump</td> <td>生成Java堆转存快照。格式：-dump:[live,]format=b,file=&lt;filename&gt; live指明是否只dump出活的对象</td></tr> <tr><td>-finalizerinfo</td> <td>显式在F-Queue中等待执行finalize方法的对象</td></tr> <tr><td>-heap</td> <td>显式Java堆的详细信息，如何种收集器、参数配置等</td></tr> <tr><td>-histo</td> <td>显式堆中对象统计信息，类、实例数量、合计容量等</td></tr> <tr><td>-permstat</td> <td>以ClassLoader为统计口径显示永久代内存状态</td></tr> <tr><td>-F</td> <td>当虚拟机进程对-dump无响应时，可使用此参数强制dump</td></tr></tbody></table></li> <li><p>示例</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//将内容LVMID=3500的虚拟机快照存为 eclipse.bin</span>
jmap <span class="token operator">-</span>dump<span class="token operator">:</span>format<span class="token operator">=</span>b<span class="token punctuation">,</span>file<span class="token operator">=</span>eclipse<span class="token punctuation">.</span>bin <span class="token number">3500</span>
<span class="token comment">//....</span>
<span class="token class-name">Dumping</span> heap <span class="token keyword">to</span> <span class="token class-name">C</span><span class="token operator">:</span>\<span class="token class-name">Users</span>\<span class="token class-name">IcyFenix</span>\eclipse<span class="token punctuation">.</span>bin <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token class-name">Heap</span> dump file created
</code></pre></div></li> <li><p>and so on.......</p></li></ul> <h2 id="可视化故障处理工具"><a href="#可视化故障处理工具" class="header-anchor">#</a> 可视化故障处理工具</h2> <ul><li>JConsole、JHSDB、VisualVM、JMC等可可视化地对程序进行分析</li></ul> <h3 id="jhsdb"><a href="#jhsdb" class="header-anchor">#</a> JHSDB</h3> <ul><li><p>JHSDB是一款基于服务性代理(Serviceability Agent,AS)实现的进程外调试工具</p></li> <li><p>启动方式：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>jhsdb hsdb <span class="token parameter variable">--pid</span> <span class="token function">id</span>
or
jhsdb hsdb
</code></pre></div></li></ul> <h3 id="jconsole"><a href="#jconsole" class="header-anchor">#</a> JConsole</h3> <ul><li><p>JConsole是一款基于JMX(Java Management Extensions)的可视化监视、管理工具</p></li> <li><p>其功能主要是通过JMX的MBean对系统进行信息收集和参数动态调整</p></li> <li><p>启动方式</p> <div class="language-bash extra-class"><pre class="language-bash"><code>jconsole
</code></pre></div></li></ul> <p>and so on.....</p> <h2 id="类文件结构"><a href="#类文件结构" class="header-anchor">#</a> 类文件结构</h2> <h3 id="class类文件结构"><a href="#class类文件结构" class="header-anchor">#</a> Class类文件结构</h3> <ul><li><p>任意一个Class文件都对应唯一的一个类或接口的定义信息。(但类和接口不一定必须定义在文件中，因为可以动态生成)</p></li> <li><p>Class文件是一个由<strong>8字节</strong>为基础单位的二进制流。各数据项严格按顺序紧凑地排列在文件中，没有任何分隔符。</p></li> <li><p>当需要占用8字节以上空间时，则会按照<strong>高位在前</strong>的方式分割成若干个8字节进行存储</p></li> <li><p>根据Java虚拟机规范，Class文件格式采用一种类似C语言结构体的伪结构来存储数据，这种伪结构只有两种数据类型：</p> <ul><li><strong>无符号数</strong> <ul><li>属于基本的数据类型，以u1、u2、u4、u8分别表示1字节、2字节....的无符号(Unsigned)数</li> <li>可用于描述数字、索引引用、数量值或UTF-8编码的字符串</li></ul></li> <li><strong>表</strong> <ul><li>由多个无符号数或其他表作为数据项构成的复合数据结构，表的结尾通常以<code>_info</code>结尾</li> <li>用于描述有层次关系的复合结构数据</li></ul></li></ul></li> <li><p>Class文件中的数据项表</p> <p><img src="/jvm-pic/image-20210422222229125.png" alt="image-20210422222229125"></p> <h3 id="魔数与class类文件版本"><a href="#魔数与class类文件版本" class="header-anchor">#</a> 魔数与Class类文件版本</h3> <ul><li><p>每个Class文件的<strong>头4个字节</strong>称为<strong>魔数(Magic Number)</strong></p></li> <li><p>魔数的作用是确定某个文件是否是虚拟机能接受的Class文件</p></li> <li><p>Class文件的魔数值为<strong>0XCAFEBABY</strong></p></li> <li><p>紧接着魔数的4个字节存储的是Class文件的版本号：</p> <ul><li>第5、6个字节是次版本号(Minor Version)</li> <li>第7、8个字节是主版本号(Major Version)</li></ul> <blockquote><p>注：Java的版本号是从 45 开始计算的。如文件中十六进制的38为十进制的56，56-45=11表示该Class文件可被JDK12及以上版本执行</p></blockquote></li></ul></li></ul> <h3 id="常量池"><a href="#常量池" class="header-anchor">#</a> 常量池</h3> <ul><li><p>紧接着主、次版本号之后的是常量池入口，常量池可看作Class文件的资源仓库</p></li> <li><p>常量池是Class文件中与其他数据项关联最多的数据</p></li> <li><p>因常量池中的常量数量是不固定的，因此常在常量池入口放置一个<strong>u2</strong>类型(无符号2字节)的数据表示常量池容量计数(constant_pool_count)</p></li> <li><p>容量计数从 1 开始</p></li> <li><p>常量池中主要存放两大类常量：</p> <ul><li>字面量(Literal)：文本字符串、被声明为final的常量等接近Java语言层面的</li> <li>符号引用(Symbol Reference)：被导入、开放的包，方法名称和描述、字段名称和描述等编译方面的</li></ul></li> <li><p>常量池项目类型：</p> <p><img src="/jvm-pic/image-20210423102955036.png" alt="image-20210423102955036"></p> <p><img src="/jvm-pic/image-20210423103026410.png" alt="image-20210423103026410"></p></li> <li><p>常量池项目类型结构：</p> <p><img src="/jvm-pic/image-20210423103546399.png" alt="image-20210423103546399"></p> <p><img src="/jvm-pic/image-20210423103604432.png" alt="image-20210423103604432"></p> <p><img src="/jvm-pic/image-20210423103625366.png" alt="image-20210423103625366"></p> <h3 id="字节码分析工具-javap"><a href="#字节码分析工具-javap" class="header-anchor">#</a> #字节码分析工具：javap</h3> <ul><li><p><code>javap -verbose xx</code>可用于Class文件的字节码内容</p></li> <li><p>如:</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token constant">PS</span> <span class="token class-name">C</span><span class="token operator">:</span>\<span class="token class-name">Users</span>\xiao\<span class="token class-name">Desktop</span>\test<span class="token operator">&gt;</span> javap <span class="token operator">-</span>verbose <span class="token class-name">Main</span>
<span class="token class-name">Classfile</span> <span class="token operator">/</span><span class="token class-name">C</span><span class="token operator">:</span><span class="token operator">/</span><span class="token class-name">Users</span><span class="token operator">/</span>xiao<span class="token operator">/</span><span class="token class-name">Desktop</span><span class="token operator">/</span>test<span class="token operator">/</span><span class="token class-name">Main</span><span class="token punctuation">.</span><span class="token keyword">class</span>
  <span class="token class-name">Last</span> modified <span class="token number">2021</span>年<span class="token number">4</span>月<span class="token number">23</span>日<span class="token punctuation">;</span> size <span class="token number">406</span> bytes
  <span class="token constant">MD5</span> checksum <span class="token number">3e9</span>bef6e55772798e178a68f3291d5ac
  <span class="token class-name">Compiled</span> from <span class="token string">&quot;Main.java&quot;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span>
  minor version<span class="token operator">:</span> <span class="token number">0</span>
  major version<span class="token operator">:</span> <span class="token number">56</span>
  flags<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token number">0x0021</span><span class="token punctuation">)</span> <span class="token constant">ACC_PUBLIC</span><span class="token punctuation">,</span> <span class="token constant">ACC_SUPER</span>
  this_class<span class="token operator">:</span> #<span class="token number">5</span>                          <span class="token comment">// Main</span>
  super_class<span class="token operator">:</span> #<span class="token number">6</span>                         <span class="token comment">// java/lang/Object</span>
  interfaces<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> fields<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> methods<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> attributes<span class="token operator">:</span> <span class="token number">1</span>
<span class="token class-name">Constant</span> pool<span class="token operator">:</span>
   #<span class="token number">1</span> <span class="token operator">=</span> <span class="token class-name">Methodref</span>          #<span class="token number">6.</span>#<span class="token number">17</span>         <span class="token comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span>
   #<span class="token number">2</span> <span class="token operator">=</span> <span class="token class-name">Fieldref</span>           #<span class="token number">18.</span>#<span class="token number">19</span>        <span class="token comment">// java/lang/System.out:Ljava/io/PrintStream;</span>
   #<span class="token number">3</span> <span class="token operator">=</span> <span class="token class-name">Fieldref</span>           #<span class="token number">5.</span>#<span class="token number">20</span>         <span class="token comment">// Main.m:I</span>
   #<span class="token number">4</span> <span class="token operator">=</span> <span class="token class-name">Methodref</span>          #<span class="token number">21.</span>#<span class="token number">22</span>        <span class="token comment">// java/io/PrintStream.println:(I)V</span>
   #<span class="token number">5</span> <span class="token operator">=</span> <span class="token class-name">Class</span>              #<span class="token number">23</span>            <span class="token comment">// Main</span>
   #<span class="token number">6</span> <span class="token operator">=</span> <span class="token class-name">Class</span>              #<span class="token number">24</span>            <span class="token comment">// java/lang/Object</span>
   #<span class="token number">7</span> <span class="token operator">=</span> <span class="token class-name">Utf8</span>               m
   #<span class="token number">8</span> <span class="token operator">=</span> <span class="token class-name">Utf8</span>               <span class="token class-name">I</span>
   #<span class="token number">9</span> <span class="token operator">=</span> <span class="token class-name">Utf8</span>               <span class="token generics"><span class="token punctuation">&lt;</span>init<span class="token punctuation">&gt;</span></span>
  #<span class="token number">10</span> <span class="token operator">=</span> <span class="token class-name">Utf8</span>               <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token class-name">V</span>
  #<span class="token number">11</span> <span class="token operator">=</span> <span class="token class-name">Utf8</span>               <span class="token class-name">Code</span>
  #<span class="token number">12</span> <span class="token operator">=</span> <span class="token class-name">Utf8</span>               <span class="token class-name">LineNumberTable</span>
  #<span class="token number">13</span> <span class="token operator">=</span> <span class="token class-name">Utf8</span>               main
  #<span class="token number">14</span> <span class="token operator">=</span> <span class="token class-name">Utf8</span>               <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token class-name">Ljava</span><span class="token operator">/</span>lang<span class="token operator">/</span><span class="token class-name">String</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token class-name">V</span>
  #<span class="token number">15</span> <span class="token operator">=</span> <span class="token class-name">Utf8</span>               <span class="token class-name">SourceFile</span>
  #<span class="token number">16</span> <span class="token operator">=</span> <span class="token class-name">Utf8</span>               <span class="token class-name">Main</span><span class="token punctuation">.</span>java
  #<span class="token number">17</span> <span class="token operator">=</span> <span class="token class-name">NameAndType</span>        #<span class="token number">9</span><span class="token operator">:</span>#<span class="token number">10</span>         <span class="token comment">// &quot;&lt;init&gt;&quot;:()V</span>
  #<span class="token number">18</span> <span class="token operator">=</span> <span class="token class-name">Class</span>              #<span class="token number">25</span>            <span class="token comment">// java/lang/System</span>
  #<span class="token number">19</span> <span class="token operator">=</span> <span class="token class-name">NameAndType</span>        #<span class="token number">26</span><span class="token operator">:</span>#<span class="token number">27</span>        <span class="token comment">// out:Ljava/io/PrintStream;</span>
  #<span class="token number">20</span> <span class="token operator">=</span> <span class="token class-name">NameAndType</span>        #<span class="token number">7</span><span class="token operator">:</span>#<span class="token number">8</span>          <span class="token comment">// m:I</span>
  #<span class="token number">21</span> <span class="token operator">=</span> <span class="token class-name">Class</span>              #<span class="token number">28</span>            <span class="token comment">// java/io/PrintStream</span>
  #<span class="token number">22</span> <span class="token operator">=</span> <span class="token class-name">NameAndType</span>        #<span class="token number">29</span><span class="token operator">:</span>#<span class="token number">30</span>        <span class="token comment">// println:(I)V</span>
  #<span class="token number">23</span> <span class="token operator">=</span> <span class="token class-name">Utf8</span>               <span class="token class-name">Main</span>
  #<span class="token number">24</span> <span class="token operator">=</span> <span class="token class-name">Utf8</span>               java<span class="token operator">/</span>lang<span class="token operator">/</span><span class="token class-name">Object</span>
  #<span class="token number">25</span> <span class="token operator">=</span> <span class="token class-name">Utf8</span>               java<span class="token operator">/</span>lang<span class="token operator">/</span><span class="token class-name">System</span>
  #<span class="token number">26</span> <span class="token operator">=</span> <span class="token class-name">Utf8</span>               out
  #<span class="token number">27</span> <span class="token operator">=</span> <span class="token class-name">Utf8</span>               <span class="token class-name">Ljava</span><span class="token operator">/</span>io<span class="token operator">/</span><span class="token class-name">PrintStream</span><span class="token punctuation">;</span>
  #<span class="token number">28</span> <span class="token operator">=</span> <span class="token class-name">Utf8</span>               java<span class="token operator">/</span>io<span class="token operator">/</span><span class="token class-name">PrintStream</span>
  #<span class="token number">29</span> <span class="token operator">=</span> <span class="token class-name">Utf8</span>               println
  #<span class="token number">30</span> <span class="token operator">=</span> <span class="token class-name">Utf8</span>               <span class="token punctuation">(</span><span class="token class-name">I</span><span class="token punctuation">)</span><span class="token class-name">V</span>
<span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token class-name">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    descriptor<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token class-name">V</span>
    flags<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token number">0x0001</span><span class="token punctuation">)</span> <span class="token constant">ACC_PUBLIC</span>
    <span class="token class-name">Code</span><span class="token operator">:</span>
      stack<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> locals<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> args_size<span class="token operator">=</span><span class="token number">1</span>
         <span class="token number">0</span><span class="token operator">:</span> aload_0
         <span class="token number">1</span><span class="token operator">:</span> invokespecial #<span class="token number">1</span>                  <span class="token comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span>
         <span class="token number">4</span><span class="token operator">:</span> <span class="token keyword">return</span>
      <span class="token class-name">LineNumberTable</span><span class="token operator">:</span>
        line <span class="token number">1</span><span class="token operator">:</span> <span class="token number">0</span>

  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    descriptor<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token class-name">Ljava</span><span class="token operator">/</span>lang<span class="token operator">/</span><span class="token class-name">String</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token class-name">V</span>
    flags<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token number">0x0009</span><span class="token punctuation">)</span> <span class="token constant">ACC_PUBLIC</span><span class="token punctuation">,</span> <span class="token constant">ACC_STATIC</span>
    <span class="token class-name">Code</span><span class="token operator">:</span>
      stack<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> locals<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> args_size<span class="token operator">=</span><span class="token number">1</span>
         <span class="token number">0</span><span class="token operator">:</span> getstatic     #<span class="token number">2</span>                  <span class="token comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span>
         <span class="token number">3</span><span class="token operator">:</span> getstatic     #<span class="token number">3</span>                  <span class="token comment">// Field m:I</span>
         <span class="token number">6</span><span class="token operator">:</span> invokevirtual #<span class="token number">4</span>                  <span class="token comment">// Method java/io/PrintStream.println:(I)V</span>
         <span class="token number">9</span><span class="token operator">:</span> <span class="token keyword">return</span>
      <span class="token class-name">LineNumberTable</span><span class="token operator">:</span>
        line <span class="token number">4</span><span class="token operator">:</span> <span class="token number">0</span>
        line <span class="token number">5</span><span class="token operator">:</span> <span class="token number">9</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>对于常量&quot;I、V、&lt;init&gt;、LineNumberTable&quot;等常量是编译器自动生成的，用于描述一些不方便用固定字节进行表达的内容</p></li></ul></li></ul> <h3 id="访问标志"><a href="#访问标志" class="header-anchor">#</a> 访问标志</h3> <ul><li><p>常量池结束后，紧接着的2个字节表示访问标志(Access Flag)</p></li> <li><p>访问标志用于识别一些类或接口层次的访问信息，如Class是类还是接口，是否是public修饰、是否是abstract等</p></li> <li><p>访问标志含义：</p> <p><img src="/jvm-pic/image-20210423105632523.png" alt="image-20210423105632523"></p></li> <li><p>假设有ACC_PUBLIC和ACC_SUPER，则访问标志位的值应为0x0001|0x0020 = 0x0021</p></li></ul> <h3 id="类索引、父类索引、接口索引集合"><a href="#类索引、父类索引、接口索引集合" class="header-anchor">#</a> 类索引、父类索引、接口索引集合</h3> <ul><li>类索引(this_class)和父类索引(super_class)都是u2类型的数据，而接口索引集合(interfaces)是一组u2类型的数据集合(接口可以实习多个，类仅能继承一个)</li> <li>此三个索引按顺排列在访问标志之后。对于前二者，u2数据中存放了指向一个CONSTANT_Class_info的索引值</li> <li>而接口索引集合多一个接口计数器(interfaces_count)表示容量，后续每一个u2索引一个接口信息</li></ul> <h3 id="字段表集合"><a href="#字段表集合" class="header-anchor">#</a> 字段表集合</h3> <ul><li><p>字段表(field_info)用于描述类或接口中声明的变量。包含类级别变量和实例级别，但不包含方法中声明的局部变量</p></li> <li><p>字段表结构</p> <p><img src="/jvm-pic/image-20210423111937188.png" alt="image-20210423111937188"></p></li> <li><p>字段访问标志</p> <p><img src="/jvm-pic/image-20210423112016094.png" alt="image-20210423112016094"></p></li> <li><p>访问标志之后是两项索引：name_index和descriptor_index，都是对常量池的索引，一个为简单名称，一个为方法描述符</p></li> <li><p>简单名称、全限定名、描述符的区别：</p> <ul><li>全限定名即包含包名的完整名称，如<code>org.example.Main</code></li> <li>简单名称即方法、变量等的字面名称，如函数f()，变量 int k，其简单名称为 f、k</li> <li>描述符的作用是描述字段数据类型、方法的返回值、参数列表等。根据规则，基本数据类型以及代表无返回值的void类型都用一个<code>大写字符表示</code>。而对象类型则用<code>L+对象全限定名</code>表示</li> <li>对于数组，每一维度将使用一个前置<code>[</code>来描述，如<code>java.lang.String[][]</code>描述为<code>[[Ljava.lang.String</code>.而<code>int[]</code> 被描述为<code>[I</code></li> <li>当用描述符描述方法时，按<strong>先参数列表后返回值</strong>的顺序，如<code>void inc()</code>描述为<code>()V</code></li></ul> <p><img src="/jvm-pic/image-20210423112848424.png" alt="image-20210423112848424"></p></li></ul> <h3 id="方法表集合"><a href="#方法表集合" class="header-anchor">#</a> 方法表集合</h3> <ul><li><p>Class文件对方法的描述和字段几乎相同。</p></li> <li><p>方法表结构</p> <p><img src="/jvm-pic/image-20210423194635888.png" alt="image-20210423194635888"></p></li> <li><p>方法访问标志</p> <p><img src="/jvm-pic/image-20210423194706450.png" alt="image-20210423194706450"></p></li> <li><p>对于方法中的Java代码，经过javac 编译后，存放在<strong>方法属性表集合</strong>中一个名为<code>Code</code>的属性中</p></li> <li><p>方法表实例</p> <p><img src="/jvm-pic/image-20210423195156673.png" alt="image-20210423195156673"></p></li></ul> <h3 id="属性表集合"><a href="#属性表集合" class="header-anchor">#</a> 属性表集合</h3> <ul><li><p>与Class文件中其他的数据项要求严格的顺序、长度和内容不同，属性表不要求具有严格顺序</p></li> <li><p>虚拟机规范预定义的属性</p> <p><img src="/jvm-pic/image-20210423195643553.png" alt="image-20210423195643553"></p> <p><img src="/jvm-pic/image-20210423195701743.png" alt="image-20210423195701743"></p></li> <li><p>对于每个属性，都需要从常量池中引用一个CONSTANT_Utf-8_info类型的常量来表示</p></li> <li><p>符合规则的属性表结构</p> <p><img src="/jvm-pic/image-20210423200142933.png" alt="image-20210423200142933"></p></li></ul> <h2 id="字节码指令"><a href="#字节码指令" class="header-anchor">#</a> 字节码指令</h2> <ul><li>Java虚拟机的指令由一个<strong>1字节长</strong>、代表着某种特定操作含义的数字(称为操作码，Opcode)，以及跟随其后的0个或多个代表此操作的参数(操作数，Operand)构成</li> <li>因为Java虚拟机采用面向<strong>操作数栈</strong>而不是<strong>寄存器</strong>的架构，所以大多数指令都不包含操作数，仅有一个操作码，指令参数都在操作数栈中</li></ul> <h3 id="字节码与数据类型"><a href="#字节码与数据类型" class="header-anchor">#</a> 字节码与数据类型</h3> <ul><li><p>Java虚拟机指令中，大多数都包含了其操作数对应的数据类型，如<code>iload</code>和<code>fload</code>分别表示从局部变量表中加载int/float型的数据到操作数栈中</p></li> <li><p>对于大多数与数据类型相关的字节码指令，其操作码助记符中都有特殊字符来表示数据类型。如i表示int，l表示long，s表示short，b代表byte，c代表char，a代表reference</p></li> <li><p>Java虚拟机支持的指令数据类型表(T表示模板，可取int、long等)</p> <p><img src="/jvm-pic/image-20210423203656966.png" alt="image-20210423203656966"></p> <p><img src="/jvm-pic/image-20210423203710314.png" alt="image-20210423203710314"></p></li></ul> <h3 id="加载和存储指令"><a href="#加载和存储指令" class="header-anchor">#</a> 加载和存储指令</h3> <ul><li>加载和存储指令用于将数据在帧栈中的<strong>局部变量表</strong>和<strong>操作数栈</strong>间来回传输</li> <li>分类：
<ul><li>局部变量加载到操作数栈：iload、iload_&lt;n&gt;........</li> <li>将数值从操作数栈存在局部变量表：istore、istore_&lt;n&gt;.......</li> <li>将常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_&lt;i&gt;.........</li> <li>扩充局部变量表的访问索引指令：wide</li></ul></li> <li>除了加载和存储指令，还有少量指令如访问对象字段或数值元素也会向操作数栈传输数据</li></ul> <h3 id="运算指令"><a href="#运算指令" class="header-anchor">#</a> 运算指令</h3> <ul><li>算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存到操作数栈顶</li> <li>==不存在直接支持byte、short、boolean类型的算术指令，应该使用操作int类型的指令代替==</li> <li>算术指令包含加减乘除、求余取反、按位与或异或、位移、自增、比较等</li></ul> <h3 id="类型转换"><a href="#类型转换" class="header-anchor">#</a> 类型转换</h3> <ul><li>类型转换指令可以将两种不同数值类型进行转换，一般用于实现用户代码中的显示类型转换。</li> <li>也可用于处理字节码指令集中的数据类型相关指令无法与数据类型一一对应的问题</li> <li>Java虚拟机直接支持以下数值类型的<strong>宽化转换</strong>(无需显式转换指令)
<ul><li>int到long、float、double</li> <li>long到float、double</li> <li>float到都变了</li></ul></li> <li>处理窄化转换时，需要对应的指令，包括：i2b、i2c、i2s、l2i、f2i、d2i、d2f、d2l</li></ul> <h3 id="对象创建与访问指令"><a href="#对象创建与访问指令" class="header-anchor">#</a> 对象创建与访问指令</h3> <ul><li>实例和数组都是对象，但Java对实例和数组的创建使用了不同的字节码指令</li> <li>创建类实例的指令：new</li> <li>创建数组的指令：newarray、anewarray、multianewarray</li> <li>访问类字段和实例字段的指令：getfield、putfield、getstatic、putstatic</li> <li>将数组元素加载到操作数栈：baload、caload、sastore、iastore.......</li> <li>求数组长度：arraylength</li> <li>检查类实例：instanceof、checkcast</li></ul> <h3 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="header-anchor">#</a> 操作数栈管理指令</h3> <ul><li>类似处理普通的数据栈，可直接对操作数栈进行压入与弹出操作</li> <li>将操作数栈栈顶的一个或两个元素出栈：pop、pop2</li> <li>复制栈顶一个或两个数值并将复制的值或双份的复制值(压入两次相同值)重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2</li> <li>交换栈顶最顶端的两个值：swap</li></ul> <h3 id="控制转移指令"><a href="#控制转移指令" class="header-anchor">#</a> 控制转移指令</h3> <ul><li>控制转移指令可以让虚拟机有条件或无条件地从指令指定位置的<strong>下一条</strong>指令继续执行</li> <li>控制转移指令包括：
<ul><li>条件分支：ifeq、iflt、ifnull........</li> <li>复合条件分支：tableswitch、lookupswitch</li> <li>无条件分支：goto、goto_w、jsr、ret</li></ul></li></ul> <h3 id="方法调用与返回指令"><a href="#方法调用与返回指令" class="header-anchor">#</a> 方法调用与返回指令</h3> <ul><li>invokevirtual：用于调用对象的实例方法，根据对象的实际类型进行分派。最常见的分派方式</li> <li>invokeinterface：用于调用接口方法，会在运行时搜索实现该接口的对象找出合适的方法进行调用</li> <li>invokespecial：用于调用一些需要特殊处理的方法，如实例初始化方法、私有方法、父类方法</li> <li>invokestatic：用于调用类静态方法</li> <li>invokedynamic：用于在运行时动态解析出调用点限定符所引用的方法并执行</li> <li>方法调用指令与数据类型无关，而返回类型与数据类型相关，包括ireturn(int以及位数小于int的，如byte等)、lreturn、freturn、areturn....，特殊地，return用于返回为void的情况</li></ul> <h3 id="同步指令"><a href="#同步指令" class="header-anchor">#</a> 同步指令</h3> <ul><li>Java虚拟机支持方法级的同步和方法内部一段指令序列的同步。两种类型的同步都是通过**管程(Monitor)**来实现</li> <li>方法级的同步是隐式的，无需通过字节码实现。可通过方法表结构中的ACC_SYNCHRONIZED访问标志判断是否为同步方法</li> <li>同步一段指令集通常在Java语言中可使用synchronized语句块实现，指令集中，有<code>monitorenter</code>和<code>monitorexit</code>两条指令支持</li></ul> <h2 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="header-anchor">#</a> 虚拟机类加载机制</h2> <ul><li>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析、初始化，最终形成可被虚拟机直接使用的Java类型，此过程即类加载机制</li> <li>不同于C++等在编译时需要链接，Java的类加载、链接和初始化都是在运行时完成</li></ul> <h3 id="类加载时机"><a href="#类加载时机" class="header-anchor">#</a> 类加载时机</h3> <ul><li><p>一个类型被加载到虚拟机内存，直到被卸载，整个生命周期会经历七个阶段：</p> <ul><li>加载(Loading)</li> <li>验证(Verification)</li> <li>准备(Preparation)</li> <li>解析(Resolution)</li> <li>初始化(Initialization)</li> <li>使用(Using)</li> <li>卸载(Unloading)</li></ul> <p><img src="/jvm-pic/image-20210424093426094.png" alt="image-20210424093426094"></p></li></ul> <h3 id="类加载过程-加载"><a href="#类加载过程-加载" class="header-anchor">#</a> 类加载过程——加载</h3> <ul><li>加载阶段需要完成的三件事：
<ul><li>通过类的<strong>全限定名</strong>来获取定义该类的二进制字节流</li> <li>将此字节流定义的静态存储结构转换为方法区的运行时数据结构</li> <li>在内存中生成一个代表该类的<code>java.lang.Class</code>对象，作为方法区该类的各种<strong>访问入口</strong></li></ul></li> <li>其中，获取二进制字节流并非必须从Class文件中获取，还可以指定从Zip文件、网络、运行时自动生成等方式灵活得到</li> <li>加载阶段是开发者可控性最强的阶段，加载阶段既可以使用JVM内置的引导类加载器，也可使用用户自定义的加载器</li> <li>开发者可通过自定义类加载器控制字节流的获取方式——通过重写一个类加载器的<code>findClass()</code>或<code>loadClass()</code>方法实现运行时代码动态性</li> <li>对数组而言有所不同，<strong>数组本身不通过类加载机制创建</strong>，而是由JVM直接在内存中动态构造。但数组元素类型需要依赖类加载</li></ul> <h3 id="类加载过程-验证"><a href="#类加载过程-验证" class="header-anchor">#</a> 类加载过程——验证</h3> <ul><li>验证时链接阶段的第一步，目的是确保Class文件中的字节流信息符合Java虚拟机规范的要求，保证将字节流当作代码运行后不会危害虚拟机安全</li> <li>验证大致分为四种：
<ul><li>文件格式验证：检验Class文件是否符合格式规范，能否被当前版本的虚拟机处理等</li> <li>元数据验证：对字节码描述的信息进行语义分析，看是否符合要求。如类是否继承、是否继承了不能被继承的类等</li> <li>字节码验证：通过数据流和控制流分析，确定程序语义是否合法、符合逻辑</li> <li>符号引用验证：发生在虚拟机将符号引用转换为直接引用时，通常此动作发生在解析阶段。</li></ul></li> <li>验证阶段是重要但非必须的阶段，可通过<code>-Xverify:none</code>关闭验证</li></ul> <h3 id="类加载过程-准备"><a href="#类加载过程-准备" class="header-anchor">#</a> 类加载过程——准备</h3> <ul><li>准备阶段是正式为**类中的变量(静态变量，不包括实例变量)**分配内存并设置初始值的阶段</li> <li>准备阶段对静态变量的初始值都是变量类型对应的零值</li></ul> <h3 id="类加载过程-解析"><a href="#类加载过程-解析" class="header-anchor">#</a> 类加载过程——解析</h3> <ul><li>解析阶段是将常量池中的<strong>符号引用转换为直接引用</strong>的过程</li> <li>符号引用(Symbolic References)：用一组符号来描述引用的目标，符号引用可以是任何形式的字面量</li> <li>直接引用(Direct References)：直接引用是可以直接指向目标的指针、相对偏移量或一个能间接定位到目标的句柄</li></ul> <h3 id="类加载过程-初始化"><a href="#类加载过程-初始化" class="header-anchor">#</a> 类加载过程——初始化</h3> <ul><li>类的初始化是类加载的最后一个阶段，直到初始化阶段，Java虚拟机才真正开始执行类中编译的Java代码，将主导权交给程序</li> <li>初始化阶段可以看作执行类构造器<code>&lt;clinit&gt;()</code>方法的过程，<code>&lt;clinit&gt;()</code>是javac编译自动生成的，而非Java代码</li> <li><code>&lt;clinit&gt;()</code>是编译器自动收集类中所有类变量(静态变量)的赋值动作和静态语句块(static{}块)中的语句构成</li> <li><code>&lt;clinit&gt;()</code>与类的构造函数(虚拟机中的<code>&lt;init&gt;()</code>构造器)不同，其不用显式调用父类构造器</li> <li>父类中的<code>&lt;clinit&gt;()</code>肯定在子类之前执行，所以父类的static{}语句块在子类的static{}之前执行</li> <li><code>&lt;clinit&gt;()</code>对于接口(接口不能定义静态块)或类来说不是必须的，当没有静态变量或静态语句块时可能不会生成</li> <li>Java虚拟机必须保证<code>&lt;clinit&gt;()</code>方法在多线程访问下被正确加锁同步</li></ul> <h3 id="类与类加载器"><a href="#类与类加载器" class="header-anchor">#</a> 类与类加载器</h3> <ul><li>对于任意一个类，都必须由加载它的类加载器和这个类本身共同确立其在Java虚拟机中的唯一性</li> <li>每个类加载器都有一个独立的类名称空间</li> <li>==对于同一个Class文件，由不同的类加载器加载得到的类型是不相同的==，因此在使用equals、instanceof等操作时得到的结果都是false</li></ul> <h3 id="双亲委派模型"><a href="#双亲委派模型" class="header-anchor">#</a> 双亲委派模型</h3> <ul><li><p>在Java虚拟机的角度看只有两种类加载器</p> <ul><li>启动类加载器(Bootstrap ClassLoader)：由C++实现，虚拟机自身的一部分</li> <li>其他所有类加载器：由Java实现，独立于虚拟机外部，全部继承自抽象类<code>java.lang.ClassLoader</code></li></ul></li> <li><p>Java8及以前的<strong>三层类加载器</strong></p> <ul><li>启动类加载器(Bootstrap ClassLoader)：负责加载存放在<code>JAVA_HOME/lib</code>目录或被<code>-Xbootclasspath</code>参数指定的存放路径中的并且能被识别的类库加载到虚拟机内存</li> <li>扩展类加载器(Extension ClassLoader)：在类sun.misc.Launcher$ExtClassLoader中以Java代码的形式实现。负责加载<code>JAVA_HOME/lib/ext</code>目录中或被<code>java.ext.dirs</code>系统变量指定的路径中的类库。因为由Java代码实现，因此可直接被开发者使用</li> <li>应用程序类加载器(Application ClassLoader)：在sun.misc.Launcher$AppClassLoader中实现。该加载器是<code>ClassLoader</code>类中<code>getSystemClassLoader()</code>方法的返回值，因此也称为“系统类加载器”。负责加载用于类路径(classpath)上的类库</li></ul></li> <li><p>Java9之前的类加载双亲委派模型</p> <p><img src="/jvm-pic/image-20210424105833736.png" alt="image-20210424105833736"></p></li> <li><p>双亲委派模型的工作过程：</p> <ul><li>一个类收到一个类加载请求，通常不先自己加载，而是委派给父类(通常不是继承，而是组合)加载器</li> <li>当父类反馈无法加载时，子类才会自己去加载</li></ul></li> <li><p>双亲委派模型可以保证Java程序的稳定性，因为不同类加载器加载的类被视作不同类型，双亲委派模型总是优先将类加载委派给父类，所以可以很好地处理这种问题</p></li></ul> <h3 id="java模块化系统"><a href="#java模块化系统" class="header-anchor">#</a> Java模块化系统</h3> <ul><li>JDK9中引入的Java模块化系统(Java Platform Module System,JPMS)实现了模块化的目标——可配置的封装隔离机制</li> <li>Java模块定义包含内容：
<ul><li>依赖其他模块的列表</li> <li>导出的包列表——其他模块可使用的包列表</li> <li>开放的包列表——其他模块可以反射访问的包列表</li> <li>使用的服务列表</li> <li>提供服务的实现列表</li></ul></li></ul> <h3 id="模块的兼容性"><a href="#模块的兼容性" class="header-anchor">#</a> 模块的兼容性</h3> <ul><li>为了使可配置封装隔离机制兼容传统的类路径查找机制，JDK9提出了与类路径(classpath)对应的模块路径(modulepath)</li> <li>某个类库是模块还是jar包，仅取决于它放在哪种路径上</li></ul> <h3 id="模块化下的类加载器"><a href="#模块化下的类加载器" class="header-anchor">#</a> 模块化下的类加载器</h3> <ul><li>扩展类加载器被平台类加载器(Platform ClassLoader)取代：原来的rt.jar和tools.jar被拆分为多个JMOD文件</li> <li>平台类加载器和应用程序类加载器都不再派生自<code>java.net.URLClassLoader</code></li> <li>启动类加载器、平台类加载器、应用程序类加载器都派生自<code>jdk.internal.loader.BuildinClassLoader</code></li></ul> <h2 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="header-anchor">#</a> 虚拟机字节码执行引擎</h2> <h3 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="header-anchor">#</a> 运行时栈帧结构</h3> <ul><li>Java虚拟机以“方法”为最基本的执行单元。<strong>栈帧</strong>是用于支持JVM进行方法调用和执行的背后数据结构</li> <li>栈帧是虚拟机运行时数据区中<strong>虚拟机栈</strong>中的元素</li> <li>栈帧主要存储以下信息
<ul><li>局部变量表</li> <li>操作数栈</li> <li>动态链接</li> <li>方法返回地址等</li></ul></li> <li>在编译Java代码时，栈帧中需要多大的局部变量表、多深的操作数栈等已经被计算出来，并写入方法表的<strong>Code</strong>属性中。所以栈帧需要分配多少内存在编译时就定了</li></ul> <h3 id="栈帧之局部变量表"><a href="#栈帧之局部变量表" class="header-anchor">#</a> 栈帧之局部变量表</h3> <ul><li>局部变量表用于存储<strong>方法参数</strong>和方法内部定义的<strong>局部变量</strong>。在编译为Class文件时，就在方法表的Code属性的max_locals确定了最大容量</li> <li>局部变量表的容量以**变量槽(Variable Slot)**为单位，该单位没有规定所占位数大小，但规定了能够存储基本类型和引用类型。可以存储32位以内的数据</li> <li>对64位的数据，如long和double，占用两个变量槽</li> <li>当一个方法被调用时，JVM会使用局部变量表来完成<strong>实参到形参</strong>的传递</li> <li>当执行的是实例方法时(非static)，局部变量表的第 0 个槽默认用于传递方法所属对象的引用，即<strong>this</strong></li> <li>为了尽可能节省内存，局部变量表的槽是可复用的。当超过变量的作用域时，该槽就可能被其他变量复用</li> <li>局部变量不像类变量那样存在准备阶段(即初始化赋零值)，对于<strong>定义但未赋值的局部变量是不能使用的</strong></li></ul> <h3 id="栈帧之操作数栈"><a href="#栈帧之操作数栈" class="header-anchor">#</a> 栈帧之操作数栈</h3> <ul><li>操作数栈是一个LIFO(后进先出)栈，栈中的每个元素都可以是任意Java类型</li> <li>对于32位数据，占据栈容量为1，64为数据占栈容量为 2</li> <li>以整数加法指令(iadd)为例说明栈操作：
<ul><li>执行该指令时要求栈中最接近栈顶的两个元素已经存入两个int类型值</li> <li>执行此指令会将两个int值出栈并相加，然后将结果入栈</li></ul></li></ul> <h3 id="栈帧之动态链接"><a href="#栈帧之动态链接" class="header-anchor">#</a> 栈帧之动态链接</h3> <ul><li>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有此引用即为了支持动态链接</li></ul> <h3 id="栈帧之方法返回地址"><a href="#栈帧之方法返回地址" class="header-anchor">#</a> 栈帧之方法返回地址</h3> <ul><li>方法退出的过程实际上等于栈帧出栈的过程</li> <li>退出时可能执行的操作有：
<ul><li>恢复上层方法的局部变量表和操作数栈</li> <li>把返回值压入调用者的操作数栈</li> <li>调整PC计数器</li></ul></li></ul> <h3 id="栈帧之附加信息"><a href="#栈帧之附加信息" class="header-anchor">#</a> 栈帧之附加信息</h3> <ul><li>可附加如调试、性能收集信息等附加信息</li></ul> <h3 id="方法调用"><a href="#方法调用" class="header-anchor">#</a> 方法调用</h3> <ul><li>方法调用阶段的唯一任务就是确定要调用哪个方法，而不涉及具体的方法内部代码执行</li></ul> <h3 id="方法调用-解析"><a href="#方法调用-解析" class="header-anchor">#</a> 方法调用——解析</h3> <ul><li><p>所有方法调用的目标方法在Class文件中表现为常量池中的<strong>符号引用</strong></p></li> <li><p>在类加载阶段，会将一些符号引用转换为直接引用(Q:动态链接需要等到运行时？)</p></li> <li><p>调用目标在程序代码写好，编译器进行编译时就确定下来这类方法的调用称为<strong>解析(Resolution)</strong></p></li> <li><p>解析主要包含两类方法：</p> <ul><li>静态方法：直接与类关联，不会被重写</li> <li>私有方法：外部类无法访问，也不会被重写</li></ul></li> <li><p>Java虚拟机支持 5 条方法调用字节码指令：</p> <table><thead><tr><th>指令</th> <th>描述</th></tr></thead> <tbody><tr><td>invokestatic</td> <td>用于调用静态方法</td></tr> <tr><td>invokespecial</td> <td>用于调用实例构造器&lt;init&gt;()方法、私有方法、父类方法</td></tr> <tr><td>invokevirtual</td> <td>用于调用所有虚方法</td></tr> <tr><td>invokeinterface</td> <td>用于调用接口方法</td></tr> <tr><td>invokedynamic</td> <td>先在运行时动态解析出调用点限定符引用的方法，然后执行该方法</td></tr></tbody></table> <blockquote><p>前四条指令的 分派 逻辑都固化在JVM中，最后一条的分派逻辑由用户设定的引导方法来决定</p></blockquote></li> <li><p>只要能使用<code>invokestatic</code>和<code>invokespecial</code>调用的方法都可以在解析阶段确定调用目标。符合这一条件的有静态方法、私有方法、实例构造器、父类方法。加上被final修饰的方法(使用<code>invokevirtual</code>调用)，可在类加载时解析为方法的直接引用。这5类方法称为<strong>非虚方法</strong>，其他方法称为虚方法</p></li> <li><p>解析调用是静态过程，在类加载阶段就确定了调用方法的直接地址</p></li></ul> <h3 id="方法调用-分派"><a href="#方法调用-分派" class="header-anchor">#</a> 方法调用——分派</h3> <ol><li><p><strong>静态分派</strong></p> <ul><li><p>静态分派与Java中的重载有关</p></li> <li><p>实例代码</p></li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StaticDispatch</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Human</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Man</span> <span class="token keyword">extends</span> <span class="token class-name">Human</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Woman</span> <span class="token keyword">extends</span> <span class="token class-name">Human</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token class-name">Human</span> guy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello,guy!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token class-name">Man</span> guy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello,gentleman!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token class-name">Woman</span> guy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello,lady!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//编译时只知道 man 变量的静态类型是Human，而不知道运行时类型是 Man</span>
        <span class="token comment">//因此调用时调用以静态类型确定的重载函数中参数为Human类型的那个函数</span>
        <span class="token class-name">Human</span> man <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Man</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Human</span> woman <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Woman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">StaticDispatch</span> sr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StaticDispatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 输出都是 hello,guy</span>
        sr<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span>man<span class="token punctuation">)</span><span class="token punctuation">;</span>
        sr<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span>woman<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>前置定义：</li></ul> <blockquote><p>在上述代码中</p> <p>Human被称为变量的<strong>静态类型(Static Type)</strong>，也叫“外观类型(Apparent Type)”</p> <p>Man被称为变量的<strong>实际类型(Actual Type)</strong>，也叫“运行时类型(Runtime Type)”</p> <p>变量的最终的静态类型在编译时是确定的、可知的；而实际类型在运行时才能确定，编译时并不知道具体是什么类型</p></blockquote> <ul><li>虚拟机在决定<strong>采用哪个重载函数版本</strong>的时候，取决于传入参数的<strong>数量和类型</strong>，而对于类型的判断，编译时使用的是<strong>静态类型</strong></li> <li>当没有静态类型相同的重载版本时，JVM会在类型安全的情况下进行转型并寻找合适的其他版本</li></ul></li> <li><p><strong>动态分派</strong></p> <ul><li>动态分派与Java中的多态特性相关</li> <li>实例代码</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DynamicDispatch</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Human</span> <span class="token punctuation">{</span>
        <span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Man</span> <span class="token keyword">extends</span> <span class="token class-name">Human</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;man say hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Woman</span> <span class="token keyword">extends</span> <span class="token class-name">Human</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;woman say hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Human</span> man <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Man</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Human</span> woman <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Woman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//典型的多态特性的体现</span>
        man<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//man say hello</span>
        woman<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//woman say hello</span>
        man <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Woman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//woman say hello</span>
        man<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>调用函数的字节码指令</li></ul> <div class="language-java extra-class"><pre class="language-java"><code>aload_1
invokevirtual #<span class="token number">22</span><span class="token punctuation">;</span> <span class="token comment">//Method DynamicDispatch$Human.sayHello:()V</span>
aload_2
invokevirtual #<span class="token number">22</span><span class="token punctuation">;</span> <span class="token comment">//Method DynamicDispatch$Human.sayHello:()V</span>
</code></pre></div><ul><li>从字节码指令可见，无论是指令还是参数都相同，因此推断出多态的关键是<code>invokevirtual</code>指令本身而非字节码参数</li> <li><code>invokevirtual</code>指令的运行时解析大概步骤：
<ul><li>找到操作数栈顶的第一个元素指向的对象<strong>实际类型 C</strong></li> <li>若在C中找到常量描述符和简单名称都相符的方法，则进行访问权限校验，通过则返回方法的直接引用，否则抛IllegalAccessError异常</li> <li>否则，按继承关系从下往上对父类进行搜索和校验</li> <li>若最终无结果，则抛出AbstractMethodError异常</li></ul></li> <li>==注意：字段不参与多态==</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FieldHasNoPolymorphic</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">int</span> money <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token class-name">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            money <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token function">showMeTheMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">showMeTheMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;I am Father, i have $&quot;</span> <span class="token operator">+</span> money<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">int</span> money <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            money <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
            <span class="token function">showMeTheMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//重写了父类中的 showMeTheMoney()，可以表现多态性质</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">showMeTheMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;I am Son, i have $&quot;</span> <span class="token operator">+</span> money<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Father</span> gay <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;This gay has $&quot;</span> <span class="token operator">+</span> gay<span class="token punctuation">.</span>money<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
输出：
<span class="token comment">//构造Son时先调用父类的构造函数(此时的this指向是Son类实例)</span>
<span class="token comment">//而父类构造函数中showMeTheMoney具有多态性质</span>
<span class="token comment">//因此会调用子类的showMeTheMoney函数，为 0</span>
<span class="token comment">//0值是类加载准备阶段(初始化前)默认的值</span>
<span class="token class-name">I</span> am <span class="token class-name">Son</span><span class="token punctuation">,</span>i have $ <span class="token number">0</span> 
<span class="token comment">//而后调用子类的构造函数</span>
<span class="token class-name">I</span> am <span class="token class-name">Son</span><span class="token punctuation">,</span>i have $ <span class="token number">4</span>
<span class="token comment">//字段不参与多态，因此用静态类型Father访问父类直接得到字段值为 2</span>
<span class="token class-name">This</span> guy has $ <span class="token number">2</span>
</code></pre></div></li> <li><p><strong>单分派与多分派</strong></p> <ul><li>方法的接收者与方法的参数统称为方法的<strong>宗量</strong></li> <li>根据分派基于多少宗量，分为单分派与多分派</li> <li>目前的Java是<strong>静态多分派，动态单分派的语言</strong></li></ul></li></ol> <h3 id="动态类型语言支持-动态类型语言"><a href="#动态类型语言支持-动态类型语言" class="header-anchor">#</a> 动态类型语言支持——动态类型语言</h3> <ul><li>动态类型语言关键特征是其<strong>类型检查的主体过程</strong>发生在<strong>运行时而不是编译时</strong></li> <li>动态类型语言还有一个核心：<strong>变量无类型而变量值才有类型</strong></li></ul> <h3 id="java与动态类型"><a href="#java与动态类型" class="header-anchor">#</a> Java与动态类型</h3> <ul><li>JDK以前需要通过比较复杂的动态类型支持，而JDK7中新增的<code>invokedynamic</code>指令以及<code>java.lang.invoke</code>包的出现使得虚拟机可以在底层直接支持动态类型</li></ul> <h3 id="java-lang-invoke包"><a href="#java-lang-invoke包" class="header-anchor">#</a> java.lang.invoke包</h3> <ul><li><p>此包的主要目的是在此前的<strong>单纯靠符号引用</strong>来确定调用的目标方法外，提供一种<strong>动态确定</strong>调用目标方法的机制，称为<strong>方法句柄(Method Handle)</strong></p></li> <li><p>有方法句柄之后，Java可以实现类似C++的函数指针的一些效果</p></li> <li><p>示例：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MethodHandleTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ClassA</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
        <span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">ClassA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 无论obj最终是哪个实现类，下面这句都能正确调用到println方法。</span>
        <span class="token function">getPrintlnMH</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">invokeExact</span><span class="token punctuation">(</span><span class="token string">&quot;icyfenix&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//模拟 invokevirtual 指令，不过分派方式不同</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">MethodHandle</span> <span class="token function">getPrintlnMH</span><span class="token punctuation">(</span><span class="token class-name">Object</span> reveiver<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
        <span class="token comment">// MethodType：代表“方法类型”，包含了方法的返回值（methodType()的第一个参数）和</span>
        <span class="token comment">//具体参数（methodType()第二个及以后的参数）。</span>
        <span class="token class-name">MethodType</span> mt <span class="token operator">=</span> <span class="token class-name">MethodType</span><span class="token punctuation">.</span><span class="token function">methodType</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// lookup()方法来自于MethodHandles.lookup，这句的作用是在指定类中查找符合给定的方法</span>
        <span class="token comment">//名称、方法类型，并且符合调用权限的方法句柄。</span>
        <span class="token comment">// 因为这里调用的是一个虚方法，按照Java语言的规则，方法第一个参数是隐式的，代表该方法的接</span>
        <span class="token comment">//收者，也即this指向的对象，这个参数以前是放在参数列表中进行传递，现在提供了bindTo()</span>
        <span class="token comment">//方法来完成这件事情。</span>
        <span class="token keyword">return</span> <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findVirtual</span><span class="token punctuation">(</span>reveiver<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;println&quot;</span><span class="token punctuation">,</span> mt<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bindTo</span><span class="token punctuation">(</span>reveiver<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>上述代码可以使用反射机制完成。二者关系为：</p> <ul><li>Reflection和MethodHandle机制本质上都是在模拟方法调用，但是Reflection是在模拟Java代码层次的方法调用，而MethodHandle是在模拟字节码层次的方法调用。</li> <li>·Reflection中的java.lang.reflect.Method对象远比MethodHandle机制中的java.lang.invoke.MethodHandle对象所包含的信息来得多</li> <li>用开发人员通俗的话来讲，Reflection是重量级，而MethodHandle是轻量级</li></ul></li></ul> <h3 id="invokedynamic指令"><a href="#invokedynamic指令" class="header-anchor">#</a> invokedynamic指令</h3> <ul><li><code>invokedynamic</code>的与<code>MethodHandle</code>作用类似，都用于完成”动态分派“。但前者是基于字节码，后者是基于上层API的</li> <li>每一个含有<code>invokedynamic</code>指令的位置称为<strong>动态调用点</strong>，该指令第一个参数不再是代表方法符号引用的CONSTANT_Methodref_info常量，而是CONSTANT_InvokeDynamic_info常量，从该常量可得到3个信息：
<ul><li>引导方法：固定参数，返回值规定是<code>java.lang.invoke.CallSite</code>对象，代表了真正要执行的目标方法调用</li> <li>方法类型</li> <li>方法名称</li></ul></li></ul> <h3 id="基于栈的指令集与基于寄存器的指令集"><a href="#基于栈的指令集与基于寄存器的指令集" class="header-anchor">#</a> 基于栈的指令集与基于寄存器的指令集</h3> <ul><li><p>Javac编译器输出的字节码指令流基本上都是基于栈的指令集架构(ISA)</p></li> <li><p>与基于寄存器的指令集区别：以计算 1+1为例</p> <ul><li><p>基于栈的指令集：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//连续把两个常数压入栈</span>
iconst_1
iconst_1
<span class="token comment">//把栈顶两个值出栈相加然后将结果压回</span>
iadd
<span class="token comment">//把栈顶值放到局部变量表的第 0 个槽中</span>
istore_0
</code></pre></div></li> <li><p>基于寄存器的指令集：</p> <div class="language-assembly extra-class"><pre class="language-text"><code>mov eax,1
add eax,1
</code></pre></div></li></ul></li></ul> <h3 id="基于栈的解释器执行过程"><a href="#基于栈的解释器执行过程" class="header-anchor">#</a> 基于栈的解释器执行过程</h3> <ul><li><p>示例代码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">300</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span> <span class="token operator">*</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>对应字节码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Code</span><span class="token operator">:</span>
		<span class="token comment">// stack=2表示需要一个深度为 2 的操作数栈空间</span>
		<span class="token comment">// locals=4 表示需要一个有 4 个变量槽的局部变量空间</span>
		<span class="token comment">// Args_size=1 表示该方法有一个参数。(即作为对象的方法，有一个默认的 this 参数)</span>
    	<span class="token class-name">Stack</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token class-name">Locals</span><span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token class-name">Args_size</span><span class="token operator">=</span><span class="token number">1</span>
             <span class="token number">0</span><span class="token operator">:</span>  bipush <span class="token number">100</span>			<span class="token comment">// bipush用于将单字节(-128——127)的整型常量入操作数栈。参数为要存的值</span>
             <span class="token number">2</span><span class="token operator">:</span>  istore_1			<span class="token comment">// istore_1 将操作数栈栈顶的元素出栈并存到第一个变量槽中(第0个存的是this)</span>
             <span class="token number">3</span><span class="token operator">:</span>  sipush <span class="token number">200</span>
             <span class="token number">6</span><span class="token operator">:</span>  istore_2
             <span class="token number">7</span><span class="token operator">:</span>  sipush <span class="token number">300</span>
            <span class="token number">10</span><span class="token operator">:</span>  istore_3
            <span class="token number">11</span><span class="token operator">:</span>  iload_1			<span class="token comment">// iload_1用于将局部变量表中的第1个槽中的整型值复制到操作数栈顶</span>
            <span class="token number">12</span><span class="token operator">:</span>  iload_2
            <span class="token number">13</span><span class="token operator">:</span>  iadd				<span class="token comment">// iadd用于弹出操作数栈顶的两个整型数相加并将结果压入栈</span>
            <span class="token number">14</span><span class="token operator">:</span>  iload_3			
            <span class="token number">15</span><span class="token operator">:</span>  imul				<span class="token comment">// imul用于弹出栈顶两个数相乘并将结果压回</span>
            <span class="token number">16</span><span class="token operator">:</span>  ireturn			<span class="token comment">// ireturn 将栈顶的整型数返回给方法调用者并结束方法</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>以上仅仅是概念模型。实际的虚拟机执行可能并不按照上述顺序执行，因为虚拟机可能会做出一些优化来提高性能</p></li></ul> <h2 id="类加载及执行子系统案例"><a href="#类加载及执行子系统案例" class="header-anchor">#</a> 类加载及执行子系统案例</h2> <h3 id="tomcat-正统的类加载器架构"><a href="#tomcat-正统的类加载器架构" class="header-anchor">#</a> Tomcat：正统的类加载器架构</h3> <ul><li><p>主流的Web服务器一般都实现了自己的类加载器。因为功能健全的Web服务器需要解决以下问题：</p> <ul><li>部署在同一个服务器上的两个Web程序所使用的Java类库<strong>可以相互隔离</strong></li> <li>部署在同一个服务器上的两个Web应用程序所使用的Java类库<strong>可以互相共享</strong></li> <li>服务器需要尽可能地保证自身的安全不受部署的Web应用程序影响。服务器依赖的类库应该与程序依赖的类库隔离</li></ul></li> <li><p>基于上述问题，许多Web服务器都提供了好几个有不同含义的<strong>ClassPath</strong>供用户存放第三方库，路径一般用lib、classes命名</p></li> <li><p>不同class path下的类库，具有不同的访问范围和服务对象，<strong>通常每个目录都有一个相应的自定义类加载器去加载类库</strong></p></li> <li><p>以Tomcat6及以前目录结构为例：</p> <ul><li>放置在/common目录中。类库可被Tomcat和所有的Web应用程序共同使用。</li> <li>放置在/server目录中。类库可被Tomcat使用，对所有的Web应用程序都不可见。</li> <li>放置在/shared目录中。类库可被所有的Web应用程序共同使用，但对Tomcat自己不可见。</li> <li>放置在/WebApp/WEB-INF目录中。类库仅仅可以被该Web应用程序使用，对Tomcat和其他Web应用程序都不可见。</li></ul></li> <li><p>类加载模型——基于双亲委派</p> <p><img src="/jvm-pic/image-20210502101331061.png" alt="image-20210502101331061"></p></li></ul> <h3 id="osgi-灵活的类加载器架构"><a href="#osgi-灵活的类加载器架构" class="header-anchor">#</a> OSGi：灵活的类加载器架构</h3> <ul><li>OSGi(Open Service Gateway Initiative)是一个基于Java语言的动态模块化规范。</li> <li>OSGi中的模块(称为Bundle)类似与Java中的类库，都以jar格式封装。但一个Bundle可以声明其所依赖的Package，也可以声明其可以导出生成的Package</li> <li>OSGi中，传统的上层模块依赖底层模块转变为平级模块之间的依赖</li> <li>类库的可见性可以通过OSGi得到精确的控制，一个模块中只有被Export过的Package才能被其他模块访问</li> <li>目前，引入OSGi的理由主要是基于OSGi框架可以实现模块化的热插拔功能</li> <li>OSGi的类加载器之间只有关联，没有固定的委派关系。如，某个Bundle声明了一个它依赖的Package，如果有其他Bundle声明了发布这个Package后，那么所有对这个Package的类加载动作都会委派给发布它的Bundle类加载器去完成。不涉及某个具体的Package时，各个Bundle加载器都是平级的关系，只有具体使用到某个Package和Class的时候，才会根据Package导入导出定义来构造Bundle间的委派和依赖。</li></ul> <h3 id="字节码生成技术和动态代理实现"><a href="#字节码生成技术和动态代理实现" class="header-anchor">#</a> 字节码生成技术和动态代理实现</h3> <ul><li><p>动态代理中的动态，是针对使用Java代码实际编写了静态代理类而言的。优势在于<strong>实现了在原始类和接口还未知的时候就确定代理类的行为</strong>，当代理类与原始类脱离关系后，就可以被其他场景重用</p></li> <li><p>动态代理示例：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DynamicProxyTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">interface</span> <span class="token class-name">IHello</span> <span class="token punctuation">{</span>
        <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Hello</span> <span class="token keyword">implements</span> <span class="token class-name">IHello</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//动态代理</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DynamicProxy</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span> <span class="token punctuation">{</span>
        <span class="token class-name">Object</span> originalObj<span class="token punctuation">;</span>
        <span class="token class-name">Object</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token class-name">Object</span> originalObj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>originalObj <span class="token operator">=</span> originalObj<span class="token punctuation">;</span>
            <span class="token comment">//newProxyInstance为重点，此方法返回一个实现了IHello的接口，并且代理了new Hello()实例行为的对象</span>
            <span class="token keyword">return</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>originalObj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> originalObj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        <span class="token comment">// invoke 方法在调用被代理类的所有方法时都会被调用。因此invoke方法的执行逻辑某种程度上说就是</span>
        <span class="token comment">// 动态代理的逻辑</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;welcome&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>originalObj<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">IHello</span> hello <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">IHello</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">DynamicProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//输出：</span>
        <span class="token comment">//welcome</span>
        <span class="token comment">//hello world</span>
        hello<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h3 id="backport工具"><a href="#backport工具" class="header-anchor">#</a> Backport工具</h3> <ul><li>Java逆向移植工具(Java Backporting Tools)可以把高版本JDK编写的代码放到低版本JDK上运行</li></ul> <h3 id="实战-远程执行功能实现"><a href="#实战-远程执行功能实现" class="header-anchor">#</a> 实战：远程执行功能实现</h3> <ul><li><p>即在服务端执行临时代码</p></li> <li><p><strong>目标：</strong></p> <ul><li>不依赖某个JDK版本才加入的特性</li> <li>不改变原来服务器端的部署，不依赖其他类库</li> <li>不侵入原有程序</li> <li>临时代码应该直接支持Java语言</li> <li>临时代码有足够的自由度，不依赖特定类或接口</li> <li>执行结果可以返回客户端</li></ul></li> <li><p><strong>思路：</strong></p> <ul><li>三个问题：如何编译、如何执行、如何收集结果</li> <li>编译：依赖服务器编译 OR 在客户端编译后传字节码到服务器</li> <li>执行：让服务器类加载器加载目标代码的Class文件并用反射调用某个方法即可。提交上去的类应该要能够访问服务端的其他类库，并且执行完后应该被卸载</li> <li>收集输出结果：如果使用System.setOut()/System.setErr()方法把输出流重定向到自己定义的PrintStream对象上固然可以收集到输出信息，但也会对原有程序产生影响：会把其他线程向标准输出中打印的信息也收集了。通常直接在执行的类中把对System.out的符号引用替换为我们准备的PrintStream的符号引用</li></ul></li> <li><p><strong>实现：</strong></p> <ul><li>HotSwapClassLoader 实现“同一个类的代码可以被多次加载”</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
* 为了多次载入执行类而加入的加载器
* 把defineClass方法开放出来，只有外部显式调用的时候才会使用到loadByte方法
* 由虚拟机调用时，仍然按照原有的双亲委派规则使用loadClass方法进行类加载
*/</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HotSwapClassLoader</span> <span class="token keyword">extends</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">{</span>
    <span class="token comment">//构造函数中指定加载 HotSwapClassLoader的加载器为父类加载器，如此可以实现提交的执行代码可以访问服务端引用类库的需求</span>
    <span class="token comment">//因为HotSwapClassLoader的加载必定是虚拟机中加载一般类库的加载器完成的</span>
    <span class="token comment">//将目标执行代码的加载也委派给该加载器，则满足同一个加载器加载的需求</span>
    <span class="token keyword">public</span> <span class="token class-name">HotSwapClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token class-name">HotSwapClassLoader</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//用于将提交执行的Java类的byte数组转换为Class对象，即加载类</span>
    <span class="token keyword">public</span> <span class="token class-name">Class</span> <span class="token function">loadByte</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> classByte<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">defineClass</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> classByte<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> classByte<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>实现将<code>java.lang.System</code>替换为自定义的<code>HackSystem</code>类。
<ul><li>直接修改符合Class文件格式的byte数组中的<strong>常量池</strong>部分，将常量池中指定内容的CONSTANT_Utf8_info替换为新的字符串。</li> <li>经过处理后的byte数组直接传递给HotSwapClassLoader加载</li></ul></li> <li>ClassModifier：实现类”替换“</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
* 修改Class文件，暂时只提供修改常量池常量的功能
*/</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassModifier</span> <span class="token punctuation">{</span>
    <span class="token comment">/**
    * Class文件中常量池的起始偏移
    */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">CONSTANT_POOL_COUNT_INDEX</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
    <span class="token comment">/**
    * CONSTANT_Utf8_info常量的tag标志
    */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token class-name">CONSTANT_Utf8_info</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
     <span class="token comment">/**
    * 常量池中11种常量所占的长度，CONSTANT_Utf8_info型常量除外，因为它不是定长的
    */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token constant">CONSTANT_ITEM_LENGTH</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> u1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> u2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> classByte<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">ClassModifier</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> classByte<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>classByte <span class="token operator">=</span> classByte<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/**
    * 修改常量池中CONSTANT_Utf8_info常量的内容
    * @param oldStr 修改前的字符串
    * @param newStr 修改后的字符串
    * @return 修改结果
    */</span>
    <span class="token keyword">public</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">modifyUTF8Constant</span><span class="token punctuation">(</span><span class="token class-name">String</span> oldStr<span class="token punctuation">,</span> <span class="token class-name">String</span> newStr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> cpc <span class="token operator">=</span> <span class="token function">getConstantPoolCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> offset <span class="token operator">=</span> <span class="token constant">CONSTANT_POOL_COUNT_INDEX</span> <span class="token operator">+</span> u2<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cpc<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> tag <span class="token operator">=</span> <span class="token class-name">ByteUtils</span><span class="token punctuation">.</span><span class="token function">bytes2Int</span><span class="token punctuation">(</span>classByte<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> u1<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>tag <span class="token operator">==</span> <span class="token class-name">CONSTANT_Utf8_info</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token class-name">ByteUtils</span><span class="token punctuation">.</span><span class="token function">bytes2Int</span><span class="token punctuation">(</span>classByte<span class="token punctuation">,</span> offset <span class="token operator">+</span> u1<span class="token punctuation">,</span> u2<span class="token punctuation">)</span><span class="token punctuation">;</span>
                offset <span class="token operator">+=</span> <span class="token punctuation">(</span>u1 <span class="token operator">+</span> u2<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token class-name">ByteUtils</span><span class="token punctuation">.</span><span class="token function">bytes2String</span><span class="token punctuation">(</span>classByte<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>oldStr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> strBytes <span class="token operator">=</span> <span class="token class-name">ByteUtils</span><span class="token punctuation">.</span><span class="token function">string2Bytes</span><span class="token punctuation">(</span>newStr<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> strLen <span class="token operator">=</span> <span class="token class-name">ByteUtils</span><span class="token punctuation">.</span><span class="token function">int2Bytes</span><span class="token punctuation">(</span>newStr<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> u2<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    classByte <span class="token operator">=</span> <span class="token class-name">ByteUtils</span><span class="token punctuation">.</span><span class="token function">bytesReplace</span><span class="token punctuation">(</span>classByte<span class="token punctuation">,</span> offset <span class="token operator">-</span> u2<span class="token punctuation">,</span> u2<span class="token punctuation">,</span> strLen<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    classByte <span class="token operator">=</span> <span class="token class-name">ByteUtils</span><span class="token punctuation">.</span><span class="token function">bytesReplace</span><span class="token punctuation">(</span>classByte<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> len<span class="token punctuation">,</span> strBytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span> classByte<span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    offset <span class="token operator">+=</span> len<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                offset <span class="token operator">+=</span> <span class="token constant">CONSTANT_ITEM_LENGTH</span><span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> classByte<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
     <span class="token comment">/**
    * 获取常量池中常量的数量
    * @return 常量池数量
    */</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getConstantPoolCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">ByteUtils</span><span class="token punctuation">.</span><span class="token function">bytes2Int</span><span class="token punctuation">(</span>classByte<span class="token punctuation">,</span> <span class="token constant">CONSTANT_POOL_COUNT_INDEX</span><span class="token punctuation">,</span> u2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>ByteUtils：封装byte的替换操作</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
* Bytes数组处理工具
*/</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ByteUtils</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">bytes2Int</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> end <span class="token operator">=</span> start <span class="token operator">+</span> len<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">;</span>
            n <span class="token operator">&lt;&lt;=</span> <span class="token punctuation">(</span><span class="token operator">--</span>len<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">;</span>
            sum <span class="token operator">=</span> n <span class="token operator">+</span> sum<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">int2Bytes</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            b<span class="token punctuation">[</span>len <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>value <span class="token operator">&gt;&gt;</span> <span class="token number">8</span> <span class="token operator">*</span> i<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">bytes2String</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> start<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">string2Bytes</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">bytesReplace</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> originalBytes<span class="token punctuation">,</span> <span class="token keyword">int</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> replaceBytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newBytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>originalBytes<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token punctuation">(</span>replaceBytes<span class="token punctuation">.</span>length <span class="token operator">-</span> len<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>originalBytes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> newBytes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>replaceBytes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> newBytes<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> replaceBytes<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>originalBytes<span class="token punctuation">,</span> offset <span class="token operator">+</span> len<span class="token punctuation">,</span> newBytes<span class="token punctuation">,</span> offset <span class="token operator">+</span> replaceBytes<span class="token punctuation">.</span>length<span class="token punctuation">,</span> originalBytes<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token keyword">return</span> newBytes<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>HackSystem：用于替换java.lang.System的类</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
* 为Javaclass劫持java.lang.System提供支持
* 除了out和err外，其余的都直接转发给System处理
*/</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HackSystem</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">InputStream</span> in <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ByteArrayOutputStream</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">PrintStream</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintStream</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">PrintStream</span> err <span class="token operator">=</span> out<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">getBufferString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> buffer<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">clearBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        buffer<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setSecurityManager</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">SecurityManager</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">setSecurityManager</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">SecurityManager</span> <span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">arraycopy</span><span class="token punctuation">(</span><span class="token class-name">Object</span> src<span class="token punctuation">,</span> <span class="token keyword">int</span> srcPos<span class="token punctuation">,</span> <span class="token class-name">Object</span> dest<span class="token punctuation">,</span> <span class="token keyword">int</span> destPos<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span> srcPos<span class="token punctuation">,</span> dest<span class="token punctuation">,</span> destPos<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">identityHashCode</span><span class="token punctuation">(</span><span class="token class-name">Object</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">identityHashCode</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 下面所有的方法都与java.lang.System的名称一样</span>
    <span class="token comment">// 实现都是字节转调System的对应方法</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>JavaClassExecuter：提供外部调用的入口</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
* Javaclass执行工具
*/</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JavaclassExecuter</span> <span class="token punctuation">{</span>
     <span class="token comment">/**
    * 执行外部传过来的代表一个Java类的Byte数组&lt;br&gt;
    * 将输入类的byte数组中代表java.lang.System的CONSTANT_Utf8_info常量修改为劫持后的HackSystem类
    * 执行方法为该类的static main(String[] args)方法，输出结果为该类向System.out/err输出的信息
    * @param classByte 代表一个Java类的Byte数组
    * @return 执行结果
    */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> classByte<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">HackSystem</span><span class="token punctuation">.</span><span class="token function">clearBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ClassModifier</span> cm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassModifier</span><span class="token punctuation">(</span>classByte<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//调用修改器将 System类替换为HackSystem</span>
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> modiBytes <span class="token operator">=</span> cm<span class="token punctuation">.</span><span class="token function">modifyUTF8Constant</span><span class="token punctuation">(</span><span class="token string">&quot;java/lang/System&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;org/xxxx/HackSystem&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">HotSwapClassLoader</span> loader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HotSwapClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Class</span> clazz <span class="token operator">=</span> loader<span class="token punctuation">.</span><span class="token function">loadByte</span><span class="token punctuation">(</span>modiBytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">//获取该类的Main方法并调用</span>
            <span class="token class-name">Method</span> method <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">&quot;main&quot;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">null</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token class-name">HackSystem</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token class-name">HackSystem</span><span class="token punctuation">.</span><span class="token function">getBufferString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="高效并发"><a href="#高效并发" class="header-anchor">#</a> 高效并发</h2> <h2 id="java内存模型"><a href="#java内存模型" class="header-anchor">#</a> Java内存模型</h2> <ul><li>Java内存模型的主要目的是定义程序中<strong>各种变量的访问规则</strong>，即关注把变量存到内存和从内存取出的底层细节</li> <li>此处的变量不同于Java语言中的变量，它包含实例字段、静态字段、构成数组对象的元素。但是不包含局部变量和方法参数。因为后者为线程私有，不会存在竞争</li></ul> <h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="header-anchor">#</a> 主内存与工作内存</h3> <ul><li><p>Java内存模型规定<strong>所有的变量(Variables)都存在主内存(Main Memory)中</strong></p></li> <li><p>每条线程都有自己的<strong>工作内存(Working Memory)</strong>，线程的工作内存中保存了被该线程使用的变量的<strong>主内存副本</strong>，线程对变量的操作都必须在工作内存中进行</p></li> <li><p>交互关系：</p> <p><img src="/jvm-pic/image-20210503110336936.png" alt="image-20210503110336936"></p></li></ul> <h3 id="内存间的交互操作"><a href="#内存间的交互操作" class="header-anchor">#</a> 内存间的交互操作</h3> <ul><li><p>对于主内存和工作内存之间的交互，Java虚拟机规范定义了8种操作(都是原子的)</p> <table><thead><tr><th>操作</th> <th>描述</th></tr></thead> <tbody><tr><td>lock</td> <td>作用于主内存变量，将一个变量表示为线程独占</td></tr> <tr><td>unlock</td> <td>作用于主内存变量，将一个锁定的变量解锁</td></tr> <tr><td>read</td> <td>作用于主内存变量，将变量值从主内存传到工作内存，便于后续load使用</td></tr> <tr><td>load</td> <td>作用于工作内存变量，把由read得到的值放入工作内存的变量副本中</td></tr> <tr><td>use</td> <td>作用于工作内存变量，将变量值传递给执行引擎，当某条指令需要用到该变量时执行该操作</td></tr> <tr><td>assign</td> <td>作用于工作内存变量，于use的操作相反</td></tr> <tr><td>store</td> <td>作用于工作内存变量，将工作内存变量传递到主内存以便随后的write操作</td></tr> <tr><td>write</td> <td>作用于主内存变量，将store的变量值存到主内存变量中</td></tr></tbody></table></li></ul> <h3 id="volatile类型变量的特殊规则"><a href="#volatile类型变量的特殊规则" class="header-anchor">#</a> volatile类型变量的特殊规则</h3> <ul><li><p>关键词volatile可以说是Java虚拟机提供的最轻量级的同步机制</p></li> <li><p>当一个变量为定义为<code>volatile</code>之后，具有如下特性：</p> <ul><li>保证此变量<strong>对所有线程的可见性</strong>。即一个线程修改了此变量后，新值对于其他线程而言是立即可以得知的。而普通变量的值在线程之间传递需要经过主内存完成</li> <li><strong>注意：<strong>虽然被此关键字修饰的变量在各个线程中具有一致性，但是，因为</strong>Java中的运算操作符并非原子</strong>的，所有<code>volatile</code>修饰的变量<strong>运算在并发时不是安全的</strong></li></ul></li> <li><p>由于<code>volatile</code>修饰的变量只能保证可见性，因此，在<strong>不符合</strong>以下规则的运算场景中<strong>仍需要加锁</strong>来保证原子性</p> <ul><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li> <li>变量不需要与其他的状态变量共同参与不变约束。</li></ul></li> <li><p>适合使用<code>volatile</code>的一种情形</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//当 shutdown() 执行后，可以保证其他线程的 doWork() 停止执行</span>
<span class="token keyword">volatile</span> <span class="token keyword">boolean</span> shutdownRequested<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    shutdownRequested <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>shutdownRequested<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 代码的业务逻辑</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>使用<code>volatile</code>的第二种语义是<strong>禁止指令重排序优化</strong></p> <ul><li>普通变量只能保证在该方法执行过程中所有依赖值结果的地方都能获取正确结果，但<strong>不能保证变量赋值的操作顺序与代码中的执行顺序一致</strong></li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//指令重排示例</span>
<span class="token class-name">Map</span> configOptions<span class="token punctuation">;</span>
<span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> configText<span class="token punctuation">;</span>
<span class="token comment">// 此变量必须定义为volatile</span>
<span class="token keyword">volatile</span> <span class="token keyword">boolean</span> initialized <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token comment">// 假设以下代码在线程A中执行</span>
<span class="token comment">// 模拟读取配置信息，当读取完成后</span>
<span class="token comment">// 将initialized设置为true,通知其他线程配置可用</span>
configOptions <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
configText <span class="token operator">=</span> <span class="token function">readConfigFile</span><span class="token punctuation">(</span>fileName<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">processConfigOptions</span><span class="token punctuation">(</span>configText<span class="token punctuation">,</span> configOptions<span class="token punctuation">)</span><span class="token punctuation">;</span>
initialized <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token comment">// 假设以下代码在线程B中执行</span>
<span class="token comment">// 等待initialized为true，代表线程A已经把配置信息初始化完成</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>initialized<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 使用线程A中初始化好的配置信息</span>
<span class="token function">doSomethingWithConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>假设上例的<code>initialized</code>没有被<code>volatile</code>修饰，则可能因为指令重排优化导致<code>initialized=true</code>先被执行，导致逻辑发生错误</li> <li>双锁检测(Double Check Lock, DCL)单例示例：</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token comment">//需要声明为 volatile</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p><code>volatile</code>的特点</p> <ul><li>volatile变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢上一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。</li> <li>大多数场景下volatile的总开销仍然要比锁来得更低</li></ul></li></ul> <h3 id="long和double的非原子性协定"><a href="#long和double的非原子性协定" class="header-anchor">#</a> long和double的非原子性协定</h3> <ul><li>对于64位的数据类型(long和double)，Java内存模型规定了一条宽松的规则：允许虚拟机将<strong>没有被volatile</strong>修饰的64位数据的读写拆分为2次32位数据读写</li> <li>即允许虚拟机实现自行选择是否保证64位数据的load、store、read、write的原子性</li> <li>但现在几乎不会存在此问题</li></ul> <h2 id="java与线程"><a href="#java与线程" class="header-anchor">#</a> Java与线程</h2> <h3 id="线程的实现"><a href="#线程的实现" class="header-anchor">#</a> 线程的实现</h3> <ul><li>每个已经调用过<code>start()</code>方法且还未结束的<code>java.lang.Thread</code>类的实例就是一个线程</li> <li>实现线程主要有3种方式：
<ul><li>使用内核线程(1:1实现)</li> <li>使用用户线程(1:N实现)</li> <li>使用用户线程加轻量级进程混合实现(N:M实现)</li></ul></li></ul> <ol><li><p>使用内核线程实现</p> <ul><li><p>内核线程(Kernel-Level Thread, KLT)是直接由操作系统内核支持的线程。</p></li> <li><p>这种线程由内核完成线程切换，内核通过调度器对线程进行调度。每个线程可看作内核的一个分身</p></li> <li><p>程序一般不会使用内核级线程，而是使用内核线程的一种高级接口——轻量级进程(Light Weight Process,LWP)</p></li> <li><p>轻量级进程和内核线程之间的一对一关系：</p> <p><img src="/jvm-pic/image-20210504103834453.png" alt=""></p></li> <li><p>轻量级进程的局限性</p> <ul><li>基于内核线程实现，各种操作(创建、析构等)都需要系统调用。而系统调用代价较高，需要在用户态和核心态之间切换</li> <li>每个轻量级进程都需要一个内核线程支持，因此会消耗一定的内核资源</li></ul></li></ul></li> <li><p>用户线程实现</p> <ul><li><p>广义上非内核线程就可以叫作用户线程(User Thread,UT)；狭义上的用户线程是指完全建立在用户空间的线程库上，系统内核不能感知到其是否存在和如何实现的线程</p></li> <li><p>用户线程的建立、同步、销毁和调度都在用户态下进行，不需要内核帮助</p></li> <li><p>进程和用户线程关系：</p> <p><img src="/jvm-pic/image-20210504104708470.png" alt="image-20210504104708470"></p></li> <li><p>劣势：</p> <ul><li>所有线程操作都需要用户处理，比较麻烦且复杂</li> <li>切换、阻塞、处理器映射关系比较难以处理</li></ul></li></ul></li> <li><p>混合实现</p> <ul><li><p>将用户线程和内核线程混合使用。此时用户线程仍在用户空间中，创建等操作依然消耗较少。而内核支持的轻量级进程作为内核线程和用户线程之间的桥梁。即用户线程负责创建等消耗小的操作，内核负责调度和处理器映射等操作</p></li> <li><p>用户线程与轻量级进程的关系：</p> <p><img src="/jvm-pic/image-20210504105257050.png" alt="image-20210504105257050"></p></li></ul></li> <li><p>Java线程的实现</p> <ul><li>Java线程如何实现不受虚拟机规范约束。从JDK1.3起，主流平台的主流商用Java虚拟机线程模型普遍替换为基于操作系统原生线程模型来实现，即1:1实现</li> <li>HotSpot中的每个Java线程都直接映射到操作系统的一个原生线程。所以HotSpot本身不会干涉线程的调度</li></ul></li></ol> <h3 id="java线程调度"><a href="#java线程调度" class="header-anchor">#</a> Java线程调度</h3> <ul><li>线程调度即分配处理机使用权的过程。主要有<strong>协同式调度</strong>(Cooperative Threads Scheduling)和<strong>抢占式调度</strong>(Preemptive Threads Scheduling)</li> <li>协同式调度：线程的<strong>执行时间由线程本身来控制</strong>，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上去</li> <li>抢占式调度：那么每个<strong>线程将由系统来分配执行时间</strong>，线程的切换不由线程本身来决定。譬如在Java中，有<code>Thread::yield()</code>方法可以主动让出执行时间，但是如果想要主动获取执行时间，线程本身是没有什么办法的。</li> <li>Java使用的是抢占式调度</li> <li>虽然Java中的线程调度由操作系统完成，但可以设置<strong>优先级</strong>让线程得到多一点的时间执行</li></ul> <h3 id="状态转换"><a href="#状态转换" class="header-anchor">#</a> 状态转换</h3> <ul><li><p>Java中定义了线程的6种状态：</p> <ul><li><strong>新建</strong>：创建后但未启动</li> <li><strong>运行</strong>：处于此状态的线程可能在运行，也可能在等待操作系统调度</li> <li><strong>无限期等待</strong>：处于此状态线程不会被分配处理器执行时间，需要<strong>其他线程显式唤醒</strong>，可能造成此状态的情形：
<ul><li><code>Object.wait()</code>没有设置Timeout参数</li> <li><code>Object.join()</code>没有设置Timeout参数</li> <li><code>LockSupport.park()</code>调用</li></ul></li> <li><strong>限期等待</strong>：该状态不会被分配处理器执行时间，但在一定时间后会自动唤醒，而不需要显式唤醒：
<ul><li><code>Thread.sleep()</code></li> <li><code>Object.wait()</code>设置了Timeout参数</li> <li><code>Object.join()</code>设置了Timeout参数</li> <li><code>LockSupport::parkNanos()</code></li> <li><code>LockSupport::parkUntil()</code></li></ul></li> <li><strong>阻塞</strong>：线程进入同步区域需要获得一个排它锁时进入此状态</li> <li><strong>结束</strong>：线程已经结束运行</li></ul></li> <li><p>转换关系</p> <p><img src="/jvm-pic/image-20210504111944334.png" alt="image-20210504111944334"></p></li></ul> <h2 id="线程安全"><a href="#线程安全" class="header-anchor">#</a> 线程安全</h2> <h3 id="java语言种的线程安全"><a href="#java语言种的线程安全" class="header-anchor">#</a> Java语言种的线程安全</h3> <ul><li>按“安全程度”，Java中各种操作共享的数据可大概分为5种类型
<ul><li>不可变</li> <li>绝对线程安全</li> <li>相对线程安全</li> <li>线程兼容</li> <li>线程对立</li></ul></li></ul> <ol><li><p>不可变</p> <ul><li>不可变(Immutable)对象一定是线程安全的</li> <li>若共享的数据类型为基本类型，只需要在定义时使用<code>final</code>关键字修饰即可保证其不变性。但对于对象类型，则需要该对象自身保证行为不会影响其状态，通常是将其成员变量设为final</li></ul></li> <li><p>绝对线程安全</p> <ul><li><p>“绝对”的体现示例：</p> <ul><li><code>java.util.Vector</code>是一个线程安全的容器，因为其<code>add()</code>、<code>get()</code>等方法都是被<code>synchronized</code>修饰的。即便如此，也不意味着调用时不需要同步</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Vector</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> vector <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vector</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            vector<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">Thread</span> removeThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> vector<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    vector<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span> printThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> vector<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span>vector<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        removeThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        printThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//不要同时产生过多的线程，否则会导致操作系统假死</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">activeCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>上述代码很可能产生下标越界错误。要保证不会出错，则应该加锁</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Thread</span> removeThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//对 vector 的访问进行同步</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>vector<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> vector<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                vector<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Thread</span> printThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>vector<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> vector<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span>vector<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>对于绝对线程安全，则是不管如何调用都不需要自己进行同步操作的。但绝对线性安全的实现可能会有更多的开销</p></li></ul></li> <li><p>相对线程安全</p> <ul><li>即通常意义上的线程安全，Java中多数的称为线程安全的类都是相对线程安全。如<code>Vector</code>等</li> <li>相对线程安全的保证了单次调用是线程安全的。但某些特殊的调用顺序不能保证线程安全</li></ul></li> <li><p>线程兼容</p> <ul><li>指类对象本身不是线程安全的。需要调用端通过一些同步操作保证线程安全。如ArrayList等</li></ul></li> <li><p>线程对立</p> <ul><li>指调用端不管是否采用同步，都无法在多线程环境下并发使用代码。</li> <li>如<code>Thread</code>类的<code>suspend()</code>和<code>resume()</code>方法，若两个线程同时对一个对象操作，且分别使用这两个方法，假设suspend一个正要resume的线程，则可能造成死锁</li></ul></li></ol> <h3 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="header-anchor">#</a> 线程安全的实现方法</h3> <ol><li><strong>互斥同步(Mutual Exclusion &amp; Synchronization)</strong> <ul><li>最常见也是最主要手段。</li> <li>同步指多个线程并发访问共享数据时，共享数据在同一个时刻只能被一个线程(使用信号量时可以是多个)访问</li> <li><strong>互斥是实现同步的一种手段</strong>。即互斥是方法，同步是目的。<strong>临界区</strong>(Critical Section)、<strong>信号量</strong>(Semaphore)、<strong>互斥量</strong>(Mutex)都是常见的互斥实现方式</li> <li>Java中最基本的互斥同步手段是<code>synchronized</code>关键字，这是一种<strong>块结构</strong>的同步语法。</li> <li><code>synchronized</code>关键字经过javac编译后，会在同步块前后形成<code>monitorenter</code>和<code>monitorexit</code>两个字节码指令</li> <li>上述两个指令都需要一个reference类型参数来指定要锁定或解锁的对象。若没有指定，则根据<code>synchronized</code>修饰的<strong>方法类型</strong>(实例方法还是static修饰的类方法)来决定要使用方法所在对象还是类来作为线程持有的锁</li> <li>在执行monitorenter指令时，首先要去<strong>尝试获取对象的锁</strong>。如果这个对象没被锁定，或者当前线程已经持有了那个对象的锁，就把锁的<strong>计数器的值增加一</strong>，而在执行monitorexit指令时会将锁计数器的值减一。一旦计数器的值为零，锁随即就被释放了</li> <li>关于synchronized的两条结论和注意事项
<ul><li>被synchronized修饰的同步块对同一条线程来说是<strong>可重入的</strong>。这意味着同一线程反复进入同步块也不会出现自己把自己锁死的情况。</li> <li>被synchronized修饰的同步块在持有锁的线程执行完毕并释放锁之前，会<strong>无条件地阻塞</strong>后面其他线程的进入。这意味着无法像处理某些数据库中的锁那样，强制已获取锁的线程释放锁；也无法强制正在等待锁的线程中断等待或超时退出</li></ul></li> <li>从执行成本的角度看，<strong>持有锁是一个重量级（Heavy-Weight）的操作</strong>：因为Java的线程是映射到操作系统原生线程上的，因此阻塞或唤醒需要操作系统帮忙，则需要用户态和核心态的切换，比较耗费处理时间</li> <li>虚拟机本身会为<code>synchronized</code>做一定优化，如阻塞线程之间加上一个自旋等待过程，避免频繁切换到核心态</li> <li>考虑到<code>synchronized</code>的局限性(重量级)，JDK5开始提供了一个<code>java.util.concurrent</code>(J.U.C)包，其中的<code>java.util.concurrent.locks.Lock</code>接口成了一种全新的同步互斥手段</li> <li>基于Lock接口，可以以<strong>非块结构</strong>实现同步。</li> <li>重入锁(ReentrantLock)是Lock接口最常见的一种实现。同<code>synchronized</code>一样是可重入的。相比而言，增加了一些高级功能：
<ul><li><strong>等待可中断</strong> <ul><li>当持有锁的线程长期不释放锁的时候，<strong>正在等待的线程可以选择放弃等待，改为处理其他事情</strong>。可中断特性对处理执行时间非常长的同步块很有帮助</li></ul></li> <li><strong>公平锁</strong> <ul><li>多个线程在等待同一个锁时，必须<strong>按照申请锁的时间顺序来依次获得锁</strong>。</li> <li>ReentrantLock在<strong>默认情况下也是非公平的</strong>，但可以通过带布尔值的构造函数要求使用公平锁。不过一旦使用了公平锁，将会导致ReentrantLock的性能急剧下降</li></ul></li> <li><strong>锁绑定多个条件</strong> <ul><li>一个ReentrantLock对象<strong>可以同时绑定多个Condition对象</strong></li> <li>synchronized中，锁对象的wait()跟它的notify()或者notifyAll()方法配合可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外添加一个锁；</li> <li>而ReentrantLock则无须这样做，多次调用newCondition()方法即可</li></ul></li></ul></li> <li>从性能上来说，JDK6对<code>synchronized</code>进行了优化，其性能基本与<code>ReentrantLock</code>持平。对于JDK6及以上版本，性能已经不是选择二者的决定因素了。</li></ul></li> <li><strong>非阻塞同步</strong> <ul><li>互斥同步面临的主要问题是进行线程阻塞和唤醒所带来的性能开销，因此这种同步也被称为阻塞同步（Blocking Synchronization）</li> <li>互斥同步属于一种<strong>悲观的并发策略</strong>，其总是认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题</li> <li>另外一种选择为基于冲突检测的<strong>乐观并发策略</strong>，通俗地说就是<strong>不管风险，先进行操作</strong>，如果没有其他线程争用共享数据，那操作就直接成功了；如果共享的数据的确被争用，产生了冲突，那再进行其他的补偿措施，最常用的补偿措施是不断地重试，直到出现没有竞争的共享数据为止</li> <li>这种乐观并发策略的实现<strong>不再需要把线程阻塞挂起</strong>，因此这种同步操作被称为非阻塞同步（Non-Blocking Synchronization），使用这种措施的代码也常被称为无锁（Lock-Free）编程。</li> <li><strong>乐观并发需要硬件指令集的扩展</strong>。因为必须要操作和冲突检测有原子性。而使用互斥保证原子性就没有意义了，因此需要硬件指令直接完成，如常用的：
<ul><li><strong>测试并设置</strong>(Test-and-Set)</li> <li><strong>获取并增加</strong>(Fetch-and-Increment)</li> <li><strong>交换</strong>(Swap)</li> <li><strong>比较并交换</strong>(Compare-and-Swap, CAS)</li> <li><strong>加载链接</strong>/<strong>条件存储</strong>(Load-Linked/Store-Conditional, LL/SC)</li></ul></li> <li>在Java中，CAS指令需要3个操作数，分别为内存位置、旧的期望值、准备设置的值。CAS指令执行时，<strong>当且仅当旧的期望值符合内存位置的值时，才将准备设置的值来更新内存位置的值</strong>。(保证了更新时没有其他线程改变过该值)而不管是否更新，都返回旧值。<strong>CAS是一个原子操作</strong></li> <li>在JDK 5之后，Java类库中才开始使用CAS操作，该操作由<code>sun.misc.Unsafe</code>类里面的<code>compareAndSwapInt()</code>和<code>compareAndSwapLong()</code>等几个方法包装提供</li> <li>JDK9之前，如果用户程序也有使用CAS操作的需求，那要么就采用反射手段突破Unsafe的访问限制，要么就只能通过Java类库API来间接使用它。直到JDK 9之后，Java类库才在VarHandle类里开放了面向用户程序使用的CAS操作</li> <li>CAS在逻辑上有一个漏洞：如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然为A值，此时并不能说明该值没有改变过，有可能改为B之后再改为A，但CAS并不知道。即ABA问题</li></ul></li> <li><strong>无同步方案</strong> <ul><li>线程安全和互斥同步并无必然联系。某些不涉及共享数据的代码就不需要同步。有些代码本身就是线程安全的，如：</li> <li><strong>可重入代码</strong>(Reentrant Code)：可以在代码执行的任何时候中断，而在控制权转回的时候原来程序不会出现任何错误，结果也不受影响。</li> <li>如果一个方法的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求</li> <li><strong>线程本地存储</strong>(Thread Local Storage)：共享数据的可见范围限制在同一个线程之内。</li> <li>可以通过<code>java.lang.ThreadLocal</code>类来实现线程本地存储的功能</li> <li>每一个线程的Thread对象中都有一个<code>ThreadLocalMap</code>对象，这个对象存储了一组以<code>ThreadLocal.threadLocalHashCode</code>为键，以<strong>本地线程变量为值</strong>的K-V值对</li> <li>ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的threadLocalHashCode值，<strong>使用这个值就可以在线程K-V值对中找回对应的本地线程变量</strong></li></ul></li></ol> <h2 id="锁优化"><a href="#锁优化" class="header-anchor">#</a> 锁优化</h2> <h3 id="自旋锁与自适应自旋-adaptive-spinning"><a href="#自旋锁与自适应自旋-adaptive-spinning" class="header-anchor">#</a> 自旋锁与自适应自旋(Adaptive Spinning)</h3> <ul><li>共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。</li> <li>可以<strong>让后面请求锁的那个线程“稍等一会”</strong>，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只须<strong>让线程执行一个忙循环（自旋）</strong>，这项技术就是所谓的<strong>自旋锁</strong></li> <li>如果锁被占用的时间很短，自旋等待的效果就会非常好，反之如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有价值的工作，这就会带来性能的浪费</li> <li>如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程。自旋次数的默认值是十次，用户也可以使用参数<code>-XX：PreBlockSpin</code>来自行更改。</li> <li>JDK 6中对自旋锁的优化，引入了<strong>自适应的自旋</strong>。自适应意味着自旋的时间不再是固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的</li></ul> <h3 id="锁消除-lock-elimination"><a href="#锁消除-lock-elimination" class="header-anchor">#</a> 锁消除(Lock Elimination)</h3> <ul><li>锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被<strong>检测到不可能存在共享数据竞争的锁进行消除</strong></li> <li>锁消除的主要判定依据来源于<strong>逃逸分析</strong>的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须再进行。</li></ul> <h3 id="锁粗化-lock-coarsening"><a href="#锁粗化-lock-coarsening" class="header-anchor">#</a> 锁粗化(Lock Coarsening)</h3> <ul><li>如果虚拟机探测到有这样<strong>一串零碎的操作都对同一个对象加锁</strong>，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。以减少频繁的互斥与同步带来的性能损耗</li></ul> <h3 id="轻量级锁-light-weight-locking"><a href="#轻量级锁-light-weight-locking" class="header-anchor">#</a> 轻量级锁(Light-Weight Locking)</h3> <ul><li><p>轻量级锁是JDK 6时加入的新型锁机制，它名字中的“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的,因此传统的锁机制就被称为“重量级”锁</p></li> <li><p>轻量级锁并不是用来代替重量级锁的，它设计的初衷是<strong>在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗</strong></p></li> <li><p>HotSpot虚拟机中对象的内存布局简介：</p> <ul><li><strong>对象头</strong>(Object Header)分为两部分
<ul><li>第一部分：存储对象自身的运行时数据，如哈希码、GC分代年龄等。该部分在32位和64位机器中分别占32或64比特。称为<strong>Mark Word</strong>。<strong>是实现轻量锁和偏向锁的关键</strong></li> <li>第二部分：存储指向方法区对象类型数据(Class类保存的元数据？)的指针。若为数组，还有一个额外部分用于存储长度</li></ul></li> <li>Mark Word图示：</li></ul> <p><img src="/jvm-pic/image-20210504170245449.png" alt="image-20210504170245449"></p></li> <li><p>轻量级锁的工作过程：</p> <ul><li><p>在代码即将进入同步块的时候，<strong>如果此同步对象没有被锁定</strong>（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中<strong>建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝</strong>（官方为这份拷贝加了一个Displaced前缀，即Displaced Mark Word）(用于CAS)，图示如下：</p> <p><img src="/jvm-pic/image-20210504172305310.png" alt="image-20210504172305310"></p></li> <li><p>然后，虚拟机使用CAS操作尝试把对象的Mark Word更新为指向Lock Record(Mark Word在栈中的拷贝)的指针</p></li> <li><p>如果这个更新动作成功了，即代表该线程拥有了这个对象的锁，并且对象Mark Word的<strong>锁标志位（Mark Word的最后两个比特）将转变为“00”，表示此对象处于轻量级锁定状态</strong></p></li> <li><p>如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。虚拟机首先会<strong>检查对象的Mark Word是否指向当前线程的栈帧</strong>，如果是，说明当前线程已经拥有了这个对象的锁，那直接进入同步块继续执行就可以了，否则就说明这个锁对象已经被其他线程抢占</p></li> <li><p>如果出现<strong>两条以上</strong>的线程<strong>争用同一个锁</strong>的情况，那轻量级锁就不再有效，(同时建立Lock Record，但CAS时都失败？)必须要膨胀为重量级锁，锁标志的状态值变为“10”，此时Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也必须进入阻塞状态</p></li> <li><p>上述为加锁，<strong>解锁过程</strong>也同样是通过CAS操作来进行的，如果对象的Mark Word仍然指向线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的DisplacedMark Word替换回来</p></li> <li><p>假如能够成功替换，那整个同步过程就顺利完成了</p></li> <li><p>如果替换失败，则说明有其他线程尝试过获取该锁，就要在释放锁的同时，唤醒被挂起的线程</p></li></ul></li> <li><p>轻量级锁能提升程序同步性能的<strong>依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”这一经验法则</strong>。如果没有竞争，轻量级锁便<strong>通过CAS操作成功避免了使用互斥量的开销</strong>；但如果确实存在锁竞争，除了互斥量的本身开销外，还额外发生了CAS操作的开销。因此在有竞争的情况下，轻量级锁反而会比传统的重量级锁更慢</p></li></ul> <h3 id="偏向锁-biased-locking"><a href="#偏向锁-biased-locking" class="header-anchor">#</a> 偏向锁(Biased Locking)</h3> <ul><li><p>偏向锁也是JDK 6中引入的一项锁优化措施，它的<strong>目的是消除数据在无竞争情况下的同步原语</strong>，进一步提高程序的运行性能</p></li> <li><p>偏向锁在无竞争的情况下把整个同步都消除掉，连CAS操作都不去做</p></li> <li><p>“偏”的意思是这个<strong>锁会偏向于第一个获得它的线程</strong>，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步</p></li> <li><p>当锁对象<strong>第一次</strong>被线程获取的时候，虚拟机将会把对象头中的标志位设置为“01”、把偏向模式设置为“1”，表示进入偏向模式</p></li> <li><p>同时使用<strong>CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中</strong>。如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作</p></li> <li><p>一旦出现<strong>另外一个线程去尝试获取这个锁</strong>的情况，偏向模式就马上宣告结束</p></li> <li><p>根据<strong>锁对象目前是否处于被锁定的状态</strong>决定是否撤销偏向（偏向模式设置为“0”），撤销后标志位恢复到未锁定（标志位为“01”）或轻量级锁定（标志位为“00”）的状态，后续的同步操作同轻量级锁操作</p></li> <li><p>当一个对象<strong>已经计算过一致性哈希码后，它就再也无法进入偏向锁状态了</strong>；而当一个对象当前正处于偏向锁状态，又收到需要计算其一致性哈希码请求时(重写hashCode()方法计算哈希码时并不会这种请求)，它的偏向状态会被立即撤销，并且锁会<strong>膨胀为重量级锁</strong></p></li> <li><p>转换关系图</p> <p><img src="/jvm-pic/image-20210504174516832.png" alt="image-20210504174516832"></p></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.969a6014.js" defer></script><script src="/assets/js/2.0c4bddf9.js" defer></script><script src="/assets/js/1.50b457b8.js" defer></script><script src="/assets/js/30.dfc04b59.js" defer></script>
  </body>
</html>
