<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>2023/7/22 | Longqinx&#39;s Notes</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/assets/css/0.styles.9f84806b.css" as="style"><link rel="preload" href="/assets/js/app.80bf8062.js" as="script"><link rel="preload" href="/assets/js/2.0c4bddf9.js" as="script"><link rel="preload" href="/assets/js/1.50b457b8.js" as="script"><link rel="preload" href="/assets/js/23.c4452db2.js" as="script"><link rel="prefetch" href="/assets/js/10.325b9f09.js"><link rel="prefetch" href="/assets/js/11.845e3692.js"><link rel="prefetch" href="/assets/js/12.ecdb524b.js"><link rel="prefetch" href="/assets/js/13.3f3f6a36.js"><link rel="prefetch" href="/assets/js/14.eb7a3d07.js"><link rel="prefetch" href="/assets/js/15.b60f3925.js"><link rel="prefetch" href="/assets/js/16.85253907.js"><link rel="prefetch" href="/assets/js/17.c2838453.js"><link rel="prefetch" href="/assets/js/18.3256f17f.js"><link rel="prefetch" href="/assets/js/19.d8afd0ae.js"><link rel="prefetch" href="/assets/js/20.10e47ab9.js"><link rel="prefetch" href="/assets/js/21.33b300c9.js"><link rel="prefetch" href="/assets/js/22.271589f5.js"><link rel="prefetch" href="/assets/js/24.176c15d5.js"><link rel="prefetch" href="/assets/js/25.566051ae.js"><link rel="prefetch" href="/assets/js/26.adb32047.js"><link rel="prefetch" href="/assets/js/27.e117ae25.js"><link rel="prefetch" href="/assets/js/28.8b31e99c.js"><link rel="prefetch" href="/assets/js/29.577fa04a.js"><link rel="prefetch" href="/assets/js/3.af33e5d6.js"><link rel="prefetch" href="/assets/js/30.7dc4f8a5.js"><link rel="prefetch" href="/assets/js/31.b01a7a78.js"><link rel="prefetch" href="/assets/js/32.e3117515.js"><link rel="prefetch" href="/assets/js/33.47c58abe.js"><link rel="prefetch" href="/assets/js/34.4fe20b46.js"><link rel="prefetch" href="/assets/js/35.f1925386.js"><link rel="prefetch" href="/assets/js/36.0032150c.js"><link rel="prefetch" href="/assets/js/37.05360e4a.js"><link rel="prefetch" href="/assets/js/4.45665f8a.js"><link rel="prefetch" href="/assets/js/5.7098d77a.js"><link rel="prefetch" href="/assets/js/6.0c0a0f39.js"><link rel="prefetch" href="/assets/js/7.6a854e57.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.77260563.js">
    <link rel="stylesheet" href="/assets/css/0.styles.9f84806b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.png" alt="Longqinx's Notes" class="logo"> <span class="site-name can-hide">Longqinx's Notes</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/java/" class="nav-link">
  Java
</a></div><div class="nav-item"><a href="/c++/" class="nav-link router-link-active">
  C/C++
</a></div><div class="nav-item"><a href="/linux/" class="nav-link">
  Linux
</a></div><div class="nav-item"><a href="/dsa/" class="nav-link">
  数据结构与算法
</a></div><div class="nav-item"><a href="/project/" class="nav-link">
  我的小项目
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="关于" class="dropdown-title"><span class="title">关于</span> <span class="arrow down"></span></button> <button type="button" aria-label="关于" class="mobile-dropdown-title"><span class="title">关于</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/about/contactMe.html" class="nav-link">
  联系我
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/java/" class="nav-link">
  Java
</a></div><div class="nav-item"><a href="/c++/" class="nav-link router-link-active">
  C/C++
</a></div><div class="nav-item"><a href="/linux/" class="nav-link">
  Linux
</a></div><div class="nav-item"><a href="/dsa/" class="nav-link">
  数据结构与算法
</a></div><div class="nav-item"><a href="/project/" class="nav-link">
  我的小项目
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="关于" class="dropdown-title"><span class="title">关于</span> <span class="arrow down"></span></button> <button type="button" aria-label="关于" class="mobile-dropdown-title"><span class="title">关于</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/about/contactMe.html" class="nav-link">
  联系我
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>2023/7/22</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/c++/C++Primer.html#_2023-7-22" class="sidebar-link">2023/7/22</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/c++/C++Primer.html#_2023-7-23" class="sidebar-link">2023/7/23</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/c++/C++Primer.html#_2023-07-26" class="sidebar-link">2023/07/26</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/c++/C++Primer.html#_2022-07-27" class="sidebar-link">2022/07/27</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/c++/C++Primer.html#_2023-08-01" class="sidebar-link">2023/08/01</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/c++/C++Primer.html#_2023-08-02" class="sidebar-link">2023/08/02</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/c++/C++Primer.html#_2023-08-03" class="sidebar-link">2023/08/03</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/c++/C++Primer.html#_2023-08-08" class="sidebar-link">2023/08/08</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/c++/C++Primer.html#_2023-08-10" class="sidebar-link">2023/08/10</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/c++/C++Primer.html#_2023-08-14" class="sidebar-link">2023/08/14</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/c++/C++Primer.html#_2023-08-16" class="sidebar-link">2023/08/16</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/c++/C++Primer.html#_2023-08-21" class="sidebar-link">2023/08/21</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/c++/C++Primer.html#_2023-08-24" class="sidebar-link">2023/08/24</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/c++/C++Primer.html#_2023-08-30" class="sidebar-link">2023/08/30</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/c++/C++Primer.html#_2023-08-31" class="sidebar-link">2023/08/31</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/c++/C++Primer.html#_2023-09-03" class="sidebar-link">2023/09/03</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/c++/C++Primer.html#_2023-09-05" class="sidebar-link">2023/09/05</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/c++/C++Primer.html#_2023-09-06" class="sidebar-link">2023/09/06</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/c++/C++Primer.html#_2023-09-12" class="sidebar-link">2023/09/12</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/c++/C++Primer.html#_2023-09-16" class="sidebar-link">2023/09/16</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/c++/C++Primer.html#_2023-09-17" class="sidebar-link">2023/09/17</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/c++/C++Primer.html#_2023-09-19" class="sidebar-link">2023/09/19</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/c++/C++Primer.html#_2023-09-21" class="sidebar-link">2023/09/21</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/c++/C++Primer.html#_2023-10-7" class="sidebar-link">2023/10/7</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/c++/C++Primer.html#_2023-10-08" class="sidebar-link">2023/10/08</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/c++/C++Primer.html#_2023-10-09" class="sidebar-link">2023/10/09</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/c++/C++Primer.html#_2023-10-10" class="sidebar-link">2023/10/10</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/c++/C++Primer.html#_2023-10-16" class="sidebar-link">2023/10/16</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/c++/C++Primer.html#_2023-10-21" class="sidebar-link">2023/10/21</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/c++/C++Primer.html#_2023-10-22" class="sidebar-link">2023/10/22</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/c++/C++Primer.html#_2023-10-26" class="sidebar-link">2023/10/26</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/c++/C++Primer.html#_2023-10-29" class="sidebar-link">2023/10/29</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/c++/C++Primer.html#_2023-10-30" class="sidebar-link">2023/10/30</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/c++/C++Primer.html#_2023-10-31" class="sidebar-link">2023/10/31</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/c++/C++Primer.html#_2023-11-1" class="sidebar-link">2023/11/1</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/c++/C++Primer.html#_2023-11-02" class="sidebar-link">2023/11/02</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="_2023-7-22"><a href="#_2023-7-22" class="header-anchor">#</a> 2023/7/22</h2> <ul><li><p><code>::</code>表示作用域操作符，可通过<code>::vname</code>访问全局变量</p></li> <li><p><code>constexpr</code>表示常量表达式类型，该类型变量能在编译时确定值</p></li> <li><p>负数赋值给无符号类型，相当于该负数对无符号类型最大值求模，如</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">unsigned</span> u <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">32</span><span class="token punctuation">;</span>
<span class="token comment">//会把负数转为unsigned，即等价于</span>
<span class="token keyword">unsigned</span> u <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">%</span> UINT_MAX<span class="token punctuation">;</span>
</code></pre></div></li> <li><p>两种方法定义类型别名：</p> <ol><li><p><code>typedef</code></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">double</span> newdouble<span class="token punctuation">;</span>  <span class="token comment">//newdouble是double的同义词</span>
<span class="token keyword">typedef</span> newdouble base<span class="token punctuation">,</span><span class="token operator">*</span>p<span class="token punctuation">;</span> <span class="token comment">//base是double的同义词，p是 double*的同义词</span>
</code></pre></div></li> <li><p><code>using</code>（别名声明）</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">using</span> SI <span class="token operator">=</span> Sales_item<span class="token punctuation">;</span>   <span class="token comment">//SI是Sales_item的同义词</span>
</code></pre></div></li></ol></li> <li><p><code>decltype</code>类型指示符：用于返回操作数的数据类型，不会实际计算表达式的值</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> sum <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">//sum的类型就是函数f的返回类型</span>
</code></pre></div><ul><li><code>decltype((variable))</code>的返回结果永远是引用</li></ul></li></ul> <h2 id="_2023-7-23"><a href="#_2023-7-23" class="header-anchor">#</a> 2023/7/23</h2> <ul><li><p><code>std::string::size_type</code>数据类型，这种类型用于存放string.size()函数的返回结果，不应该直接使用int或其他类型，以做到与具体实现无关。</p></li> <li><p>老旧的<code>verctor</code>嵌套声明时，可能需要多个空格，如<code>verctor&lt;vector&lt;int&gt; &gt;</code></p></li> <li><p>C++ 11 的列表初始化语法依赖<code>{}</code>，下面的形式都可以</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> i<span class="token punctuation">{</span><span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>字符数组的特殊性</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">char</span> a1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token char">'C'</span><span class="token punctuation">,</span> <span class="token char">'+'</span><span class="token punctuation">,</span> <span class="token char">'+'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token comment">//列表初始化，结尾无空字符</span>
<span class="token keyword">char</span> a2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token char">'C'</span><span class="token punctuation">,</span> <span class="token char">'+'</span><span class="token punctuation">,</span> <span class="token char">'+'</span><span class="token punctuation">,</span> <span class="token char">'\0'</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//列表初始化，手动添加空字符</span>
<span class="token keyword">char</span> a3<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;C++&quot;</span><span class="token punctuation">;</span>				  <span class="token comment">//自动添加表示字符串结尾的空字符</span>
<span class="token keyword">char</span> a4<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;Daniel&quot;</span><span class="token punctuation">;</span>			  <span class="token comment">//错误，6不够存放内容，因为最后会自动添加结尾空字符</span>
</code></pre></div></li> <li><p>标准库string类型通过<code>s.c_str()</code>可转换为C风格字符串，不能直接赋值</p></li> <li><p>强制类型转换，通常有以下形式</p> <div class="language-c extra-class"><pre class="language-c"><code>cast<span class="token operator">-</span>name<span class="token operator">&lt;</span>type<span class="token operator">&gt;</span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>其中<code>type</code>时目标类型，<code>expression</code>是需要转换的值。<code>cast-name</code>可取</p> <ul><li><p><code>static_cast</code>：具有明确定义的类型转换。如可以将<code>void*</code>指针转换为实际类型，不能包含底层const</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">88</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>d<span class="token punctuation">;</span>
<span class="token keyword">double</span> <span class="token operator">*</span>dp <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p><code>dynamic_cast</code>：支持运行时类型识别</p></li> <li><p><code>const_cast</code>：只能改变运算对象的底层const</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>cosnt <span class="token keyword">char</span> <span class="token operator">*</span>pc<span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>pc<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//可以转换，但是通过 p 进行写值是未定义行为</span>
</code></pre></div></li> <li><p><code>reinterpret_cast</code>：通常为运算对象的位模式提供较低层次上的重新解释，如</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token operator">*</span>ip<span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span>pc <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul></li> <li><p>函数返回引用时可做左值，如</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">char</span> <span class="token operator">&amp;</span><span class="token function">get_val</span><span class="token punctuation">(</span>string <span class="token operator">&amp;</span>str<span class="token punctuation">,</span>string<span class="token operator">::</span>size_type ix<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> str<span class="token punctuation">[</span>ix<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    string <span class="token function">s</span><span class="token punctuation">(</span><span class="token string">&quot;a value&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token function">get_val</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token char">'A'</span><span class="token punctuation">;</span><span class="token comment">//不会报错，会改变 s 的第 0 个字符</span>
    cout <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>列表初始化返回值：C++11规定，函数可以返回花括号包围的值的列表，类似其他返回结果，此处的列表可用来对函数返回的临时量进行初始化</p> <div class="language-c extra-class"><pre class="language-c"><code>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>xxx<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>xxx<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token string">&quot;function x&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;okey&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token string">&quot;function x&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;failed&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>对数组的typedef</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">int</span> attrT<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//arrT时一个类型别名，表示类型为有10个int元素的数组</span>
<span class="token keyword">using</span> arrT <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
attT <span class="token operator">*</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>因为定义数组时，数组的维度必须在数组名称之后，而定义函数时，参数列表也要在函数名称之后，两个一起使用时，函数的参数列表应该先于数组的维度，因此返回数组指针的函数形式如下：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token function">Type</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token function">function</span><span class="token punctuation">(</span>parameter_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span>dimension<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>C++11新标准提供了一种<strong>尾置返回类型</strong>，对于返回类型比较复杂的函数很有效</p> <ul><li>参数列表后跟<code>-&gt;</code>指定返回类型</li> <li>原来放返回类型的地方放 <code>auto</code></li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//接收int参数，返回10个整数的数组的指针</span>
<span class="token keyword">auto</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>如果知道函数返回的指针将指向哪个数组，则可以使用<code>decltype</code>关键字声明返回类型</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> odd<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> even<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//返回一个指针，指向含有 5 个整数的数组</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>odd<span class="token punctuation">)</span> <span class="token operator">*</span><span class="token function">attPtr</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>i<span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token operator">&amp;</span>odd<span class="token operator">:</span><span class="token operator">&amp;</span>even<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p><code>NDEBUG</code>预处理变量和<code>assert(expr)</code></p> <ul><li><code>assert</code>用于断言，expr为0时输出信息并终止程序，否则什么也不做。其定义在头文件<code>assert</code>中</li> <li>当定义了预处理变量<code>NDEBUG</code>时，所有assert都不会生效</li> <li>可使用<code>NDEBUG</code>定义自己的调试代码，如</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>size_t size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">NDEBUG</span></span>
    cerr<span class="token operator">&lt;&lt;</span><span class="token constant">__func__</span><span class="token operator">&lt;&lt;</span><span class="token string">&quot;: array size is &quot;</span><span class="token operator">&lt;&lt;</span>size<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>预处理其提供了对程序调试很有作用的名字：</p> <ul><li><code>__func__</code>：表示当前函数名</li> <li><code>__FILE__</code>：当前文件名</li> <li><code>__LINE__</code>：当前行号</li> <li><code>__TIME__</code>：当前编译时间时间</li> <li><code>__DATE__</code>：编译日期</li></ul></li> <li><p>通过类型别名和<code>decltype</code>简化使用函数指针</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">bool</span> <span class="token function">lengthCompare</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">,</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//Func和Func2是函数类型</span>
<span class="token keyword">typedef</span> <span class="token keyword">bool</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">,</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>lengthCompare<span class="token punctuation">)</span> Func2<span class="token punctuation">;</span><span class="token comment">//与上一个等价</span>

<span class="token comment">//FuncP和Func2P是函数指针</span>
<span class="token keyword">typedef</span> <span class="token keyword">bool</span> <span class="token punctuation">(</span><span class="token operator">*</span>FuncP<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">,</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>lengthCompare<span class="token punctuation">)</span> <span class="token operator">*</span>FuncP2<span class="token punctuation">;</span><span class="token comment">//与上一个等价</span>
</code></pre></div></li> <li><p>用作形参时，函数类型自动转为函数指针</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//下述表示方法等价</span>
<span class="token keyword">void</span> <span class="token function">useBigger</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">,</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">,</span>Func<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">useBigger</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">,</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">,</span>FuncP2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>返回指向函数的指针</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">using</span> F <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//PF是函数类型</span>
<span class="token keyword">using</span> PF <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//PF是函数指针</span>
</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code>PF <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//正确，返回函数指针</span>
F <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//错误，返回值不像形参列表会自动将函数类型转为指针</span>
F <span class="token operator">*</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//正确</span>
</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//直接声明的形式</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//尾置返回形式</span>
<span class="token keyword">auto</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>也可使用<code>decltype</code></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>string<span class="token double-colon punctuation">::</span>size_type <span class="token function">sumLength</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">,</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">decltype</span><span class="token punctuation">(</span>sumLength<span class="token punctuation">)</span> <span class="token operator">*</span><span class="token function">getFunc</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul> <h2 id="_2023-07-26"><a href="#_2023-07-26" class="header-anchor">#</a> 2023/07/26</h2> <ul><li><p><strong>类本身就是一个作用域</strong>，因此有些类外访问、类外定义函数等可能会见到<code>Clazz::xxx</code>这种使用作用域操作符<code>::</code>的形式</p> <div class="language-c extra-class"><pre class="language-c"><code>class Test<span class="token punctuation">{</span>
public<span class="token operator">:</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> abcd<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">setx</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//类外初始化静态变量</span>
<span class="token keyword">int</span> Test<span class="token operator">::</span>abcd <span class="token operator">=</span> <span class="token number">111</span><span class="token punctuation">;</span>
<span class="token comment">//类外指定成员函数实现</span>
<span class="token keyword">void</span> Test<span class="token operator">::</span><span class="token function">setx</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>成员函数的参数列表之后添加<code>const</code>关键字表示这是常量成员函数，不会改变成员值，这里的const本质上是修饰<code>this</code>指针的，类似于<code>const Classname * const this</code></p></li> <li><p>未定义构造函数时，编译器会自动创建一个默认构造函数，这个编译器创建的默认构造函数又称为<strong>合成默认构造函数</strong>。编译器仅在没有构造函数时生成默认构造函数</p></li> <li><p>C++ 11中，如果需要默认行为，则可以在参数列表后写上 <code>= default</code>来要求编译器生成构造函数。和其他函数一样，如果 <code>= default</code>在类内部，则默认构造函数是内联的，否则默认不是内联</p></li> <li><p>构造函数初始值列表，在参数列表后跟冒号指定</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>string str<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Test</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>str<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">str</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>C++中，<code>struct</code>和<code>class</code>类似，区别在于默认访问权限不同</p> <ul><li>class：在任何访问修饰符之前定义的成员默认为private</li> <li>struct：在任何访问修饰符之前定义的成员默认为public</li></ul> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">A</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>  <span class="token comment">//public</span>
public<span class="token operator">:</span>
    <span class="token keyword">int</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
class B<span class="token punctuation">{</span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>  <span class="token comment">//private</span>
public<span class="token operator">:</span>
    <span class="token keyword">int</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p><strong>友元</strong>可以允许其他类或函数访问当前类的非公有成员，友元可以类内任何地方，不受访问修饰符限制</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//将函数当友元</span>
<span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>
    <span class="token comment">//声明友元</span>
    <span class="token keyword">friend</span> <span class="token keyword">void</span> <span class="token function">printTest</span><span class="token punctuation">(</span>Test <span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">a</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">printTest</span><span class="token punctuation">(</span>Test <span class="token operator">&amp;</span> t<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//这里可以直接访问私有变量</span>
    cout<span class="token operator">&lt;&lt;</span>t<span class="token punctuation">.</span>a<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>规模较小的函数可通过<code>inline</code>声明为内联函数（定义在类内部的函数会自动内联）</p></li> <li><p>有时希望即使在const成员函数内也能修改某个数据成员，此时可在变量声明时用<code>mutable</code>指定</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">mutable</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span><span class="token comment">// mutable</span>
    <span class="token keyword">int</span> y<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token operator">-&gt;</span>x <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token comment">//正确，可以修改</span>
        <span class="token keyword">this</span><span class="token operator">-&gt;</span>y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//报错，不能修改</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p><code>const</code>成员函数返回的<code>*this</code>是指向常量对象的，因此该返回值不能用于改变成员变量</p></li></ul> <h2 id="_2022-07-27"><a href="#_2022-07-27" class="header-anchor">#</a> 2022/07/27</h2> <ul><li><p>类还可以把其他类定义为友元，也可以把其他类的成员函数定义成友元</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Test2</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
    <span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">Test2</span><span class="token punctuation">;</span><span class="token comment">//将类声明为友元</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">int</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Test2</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">visitTest</span><span class="token punctuation">(</span>Test <span class="token operator">&amp;</span> t<span class="token punctuation">)</span><span class="token punctuation">{</span>
        t<span class="token punctuation">.</span>x<span class="token punctuation">;</span><span class="token comment">//友元类可以访问私有成员</span>
        t<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">;</span><span class="token comment">//先声明，Test2中才能引用</span>
<span class="token keyword">class</span> <span class="token class-name">Test2</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">visitTest</span><span class="token punctuation">(</span>Test <span class="token operator">&amp;</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这里只能声明，如果在这里实现，Test被视为不完整类型，找不到成员 x 和 y</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
    <span class="token keyword">friend</span> <span class="token keyword">void</span> <span class="token class-name">Test2</span><span class="token double-colon punctuation">::</span><span class="token function">visitTest</span><span class="token punctuation">(</span>Test <span class="token operator">&amp;</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将成员函数声明为友元</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">int</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//在Test定义后再定义，才能看到 x 和 y</span>
<span class="token keyword">void</span> <span class="token class-name">Test2</span><span class="token double-colon punctuation">::</span><span class="token function">visitTest</span><span class="token punctuation">(</span>Test <span class="token operator">&amp;</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    t<span class="token punctuation">.</span>x<span class="token punctuation">;</span>
    t<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="_2023-08-01"><a href="#_2023-08-01" class="header-anchor">#</a> 2023/08/01</h2> <ul><li><p>成员的初始化顺序和它们在<strong>类定义中出现顺序</strong>一致，构造函数初始值列表中初始值的前后位置关系不会影响实际初始化顺序</p></li> <li><p>下述代码是错误的</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">X</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">int</span> j<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">//按照定义顺序，i先于j之前初始化，因此这里使用未初始化的j初始化i会出错</span>
    <span class="token function">X</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">j</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">i</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p><strong>委托构造函数（delegating constructor）</strong>，C++11引入的特性，委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程</p></li> <li><p>委托构造函数相当于允许在一个构造函数中调用其他构造函数。受委托的构造函数初始值列表和函数体会先执行</p> <div class="language-c extra-class"><pre class="language-c"><code>class Test <span class="token punctuation">{</span>
    <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">int</span> y<span class="token punctuation">;</span>
    string z<span class="token punctuation">;</span>
public<span class="token operator">:</span>
    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> string z<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">z</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token comment">//下述两个构造函数委托第一个完成初始化功能</span>
    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Test</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token function">Test</span><span class="token punctuation">(</span>string z<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> z<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，有时将这种构造函数称为<strong>转换构造函数（converting constructor）</strong></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">MyString</span> <span class="token punctuation">{</span>
    string str<span class="token punctuation">;</span>
    <span class="token keyword">int</span> len<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">//接收一个参数的构造函数，相当于定义 string --&gt; MyString 的隐式转换规则</span>
    <span class="token function">MyString</span><span class="token punctuation">(</span>string str<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">str</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">concatenate</span><span class="token punctuation">(</span>MyString s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token operator">-&gt;</span>str <span class="token operator">+=</span> s<span class="token punctuation">.</span>str<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;str: &quot;</span> <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    MyString <span class="token function">s1</span><span class="token punctuation">(</span><span class="token string">&quot;mystr&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    string s2 <span class="token operator">=</span> <span class="token string">&quot;ok&quot;</span><span class="token punctuation">;</span>
    s1<span class="token punctuation">.</span><span class="token function">concatenate</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这里本来参数类型是MyString，但是因为有转换构造函数，传string时这里会进行隐式转换，即会创建一个新的MyString出来作为真正传入的参数</span>
    s1<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>只允许一步类型转换：上述代码如果改为下述情况则会报错，因为需要进行&quot;ok&quot;转string再转MyString，编译器只会自动进行一步类型转换</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    MyString <span class="token function">s1</span><span class="token punctuation">(</span><span class="token string">&quot;mystr&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    s1<span class="token punctuation">.</span><span class="token function">concatenate</span><span class="token punctuation">(</span><span class="token string">&quot;ok&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    s1<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>可改为：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    MyString <span class="token function">s1</span><span class="token punctuation">(</span><span class="token string">&quot;mystr&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    s1<span class="token punctuation">.</span><span class="token function">concatenate</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">&quot;ok&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//或者 MyString(&quot;ok&quot;);</span>
    s1<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>上述隐式转换行为可以通过在构造函数前加<code>explicit</code>关键字进行阻止</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">MyString</span> <span class="token punctuation">{</span>
    string str<span class="token punctuation">;</span>
    <span class="token keyword">int</span> len<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">//有explicit关键字的构造函数</span>
    <span class="token keyword">explicit</span> <span class="token function">MyString</span><span class="token punctuation">(</span>string str<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">str</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">concatenate</span><span class="token punctuation">(</span>MyString s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token operator">-&gt;</span>str <span class="token operator">+=</span> s<span class="token punctuation">.</span>str<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;str: &quot;</span> <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    MyString <span class="token function">s1</span><span class="token punctuation">(</span><span class="token string">&quot;mystr&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    string s2 <span class="token operator">=</span> <span class="token string">&quot;ok&quot;</span><span class="token punctuation">;</span>
    s1<span class="token punctuation">.</span><span class="token function">concatenate</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//因为单参数构造函数加了explicit，这里会出错</span>
    s1<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p><code>explicit</code>只对一个实参的构造函数有效，只允许出现在类内部定义</p></li> <li><p><code>explicit</code>构造函数只能用于直接初始化，不能用于隐式转换和拷贝初始化（用<code>=</code>）</p></li> <li><p>编译器不会将<code>explicit</code>的构造函数用于隐式转换，但可以用这种构造函数显式进行强制转换，下述转换都是正确的</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>s1<span class="token punctuation">.</span><span class="token function">concatenate</span><span class="token punctuation">(</span><span class="token punctuation">(</span>MyString<span class="token punctuation">)</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
s1<span class="token punctuation">.</span><span class="token function">concatenate</span><span class="token punctuation">(</span><span class="token function">MyString</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
s1<span class="token punctuation">.</span><span class="token function">concatenate</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>MyString<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul> <h2 id="_2023-08-02"><a href="#_2023-08-02" class="header-anchor">#</a> 2023/08/02</h2> <ul><li><p>**聚合类（aggregate class）**使得用户可以直接访问其成员，并且具有特殊初始化语法的形式。需要满足以下条件</p> <ul><li>所有成员都是public的</li> <li>没有定义任何构造函数</li> <li>没有类内初始值</li> <li>没有基类，没有virtual函数</li></ul></li> <li><p>聚合类示例</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">Data</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> ival<span class="token punctuation">;</span>
    string s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>可提供一个花括号括起来的成员初始值列表来初始化聚合类的数据成员</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>Data val1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">&quot;abcd&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>初始值的顺序必须与声明顺序一致。初始值少于成员时，靠后没有指定初始值的成员与数组初始化一致，都用默认初始值初始化</p></li> <li><p>类的静态成员</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//使用作用域运算符访问</span>
<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token class-name">Test</span><span class="token double-colon punctuation">::</span><span class="token function">staticFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//通过实例访问</span>
Test t1<span class="token punctuation">;</span>
Test <span class="token operator">*</span>t2 <span class="token operator">=</span> <span class="token operator">&amp;</span>t1<span class="token punctuation">;</span>
x <span class="token operator">=</span> t1<span class="token punctuation">.</span><span class="token function">staticFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
x <span class="token operator">=</span> t2<span class="token operator">-&gt;</span><span class="token function">staticFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//成员函数可以不通过作用域运算符直接访问静态变量</span>
</code></pre></div></li> <li><p>类外定义静态成员时不能重复<code>static</code>关键字</p></li> <li><p>静态成员不是由构造函数初始化的，必须在类外定义和初始化每个静态成员</p></li> <li><p>静态成员可用但普通成员不行的场景</p> <ul><li>静态数据成员可以是不完全类型</li></ul> <blockquote><p>不完全类型是指声明了但是还没有定义的类型。不完全类型不能用于定义变量或者类成员；但是可以用不完全类型定义指针或者引用</p></blockquote> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Bar</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">//...</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">static</span> Bar mem1<span class="token punctuation">;</span><span class="token comment">//正确，静态成员可以是不完全类型</span>
    Bar <span class="token operator">*</span>mem2<span class="token punctuation">;</span><span class="token comment">//正确，指针成员可以是不完全类型</span>
    Bar mem3<span class="token punctuation">;</span><span class="token comment">//错误，数据成员必须是完整类型</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>可使用静态成员作为默认实参。非静态成员因为本身就是对象的一部分，因此不能作为默认实参</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Screen</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">//background表示一个再类中稍后定义的静态成员</span>
    Screen <span class="token operator">&amp;</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">=</span> background<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">char</span> background<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li></ul> <h2 id="_2023-08-03"><a href="#_2023-08-03" class="header-anchor">#</a> 2023/08/03</h2> <ul><li><p>IO库类型和头文件</p> <table><thead><tr><th>头文件</th> <th>类型</th></tr></thead> <tbody><tr><td>iostream</td> <td>istream，wistream：从流读取<br>ostream，wostream：写入到流<br>iostream，wiostream：读写流</td></tr> <tr><td>fstream</td> <td>ifstream，wifstream：从文件读<br>ofstream，wofstream：写到文件<br>fstream，wfstream：读写文件</td></tr> <tr><td>sstream</td> <td>istringstream，wistringstream：从string读<br>ostringstream，wostringstream：写到string<br>stringstream，wstringstream：读写string</td></tr></tbody></table></li> <li><p>IO对象无拷贝或赋值：不能拷贝或对IO对象赋值</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>ofstream out1<span class="token punctuation">,</span>out2<span class="token punctuation">;</span>
out1<span class="token operator">=</span>out2<span class="token punctuation">;</span><span class="token comment">//错误，不能对流对象赋值</span>
ofstream <span class="token function">print</span><span class="token punctuation">(</span>ofstream<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//错误，不能初始化ofstream参数</span>
out2<span class="token operator">=</span><span class="token function">print</span><span class="token punctuation">(</span>out2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//错误，不能拷贝流对象</span>
</code></pre></div></li> <li><p>因为不能拷贝IO对象，因此不能将形参会返回参数类型设为流类型，进行IO操作的函数通常以引用方式传递和返回流。读写IO对象会改变状态，因此传递和返回都不能为const</p></li> <li><p>IO操作具有条件状态，如下所示：</p> <table><thead><tr><th>状态</th> <th>描述</th></tr></thead> <tbody><tr><td>strm::iostate</td> <td>strm是一种IO类型，参见上一个表格；iostate是一种机器相关的类型，提供了表达条件状态的完整功能</td></tr> <tr><td>strm::badbit</td> <td>表示流已经奔溃</td></tr> <tr><td>strm::eofbit</td> <td>表示一个IO操作失败</td></tr> <tr><td>strm::goodbit</td> <td>表示流未处于错误状态，此值保证为 0</td></tr> <tr><td>s.eof()</td> <td>若流s的eofbit置位，则返回true</td></tr> <tr><td>s.fail()</td> <td>若流s的failbit置位，则返回true</td></tr> <tr><td>s.bad()</td> <td>若流s的badbit置位，则返回true</td></tr> <tr><td>s.good()</td> <td>若流s处于有效状态，则返回true</td></tr> <tr><td>s.clear()</td> <td>清除所有条件状态位（复位）将流置为有效状态</td></tr> <tr><td>s.clear(flags)</td> <td>根据给定flags将指定状态位复位，flags类型为strm::iostate</td></tr> <tr><td>s.setstate(flags)</td> <td>根据给定flags将s中指定状态位置位，flags类型位strm::iostate</td></tr> <tr><td>s.rdstate()</td> <td>返回流s当前条件状态，返回类型为strm::iostate</td></tr></tbody></table></li> <li><p>可以把流作为条件使用，判断其是否处于可用状态</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">while</span><span class="token punctuation">(</span>cin<span class="token operator">&gt;&gt;</span>word<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="_2023-08-08"><a href="#_2023-08-08" class="header-anchor">#</a> 2023/08/08</h2> <ul><li><p>IO库定义了一个与机器无关的<code>iostate</code>类型，其提供了表达流状态的完整功能，库定义了 4 个<code>iostate</code>类型的<code>constexpr</code>值</p> <ul><li><code>badbit</code>表示系统级错误，如不可恢复的读写错误，通常一旦置位则流无法再用</li> <li><code>failbit</code>在发生可恢复错误后置位，如期望读取数值却读到字符，此类问题通常可修正，流还可继续使用</li> <li><code>eofbit</code>在文件结束时置位，到达文件尾还会将<code>failbit</code>置位</li> <li><code>goodbit</code>值为 0 ，表示流未发生错误</li></ul></li> <li><p><code>badbit</code>、<code>failbit</code>、<code>eofbit</code>任一个置位，则检测流状态的条件会失败</p></li> <li><p>用流对象当条件使用的代码等价于<code>!fail()</code></p></li> <li><p>导致流缓冲刷新的的原因很多：</p> <ul><li>程序正常结束</li> <li>缓冲区满</li> <li>使用<code>endl</code>（加换行后刷新）、<code>flush</code>（不加任何字符刷新）、<code>ends</code>（加空字符后刷新）等操作符</li> <li>每个输出操作后，可使用操作符<code>unitbuf</code>设置流的内部状态来清空缓冲区。默认对<code>cerr</code>是设置了的，因此写到<code>cerr</code>的内容都是立即刷新的</li> <li>一个输出可能关联到另一个流，当读写被关联流时，关联到的流缓冲区会被刷新。默认<code>cin</code>和<code>cerr</code>都关联到<code>cout</code>，因此读<code>cin</code>或写<code>cerr</code>都会导致<code>cout</code>刷新</li></ul></li> <li><p>若想每次操作后都刷新则可使用<code>unitbuf</code>，<code>nounitbuf</code>则重置流，使其恢复正常的缓冲刷新机制</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>cout <span class="token operator">&lt;&lt;</span> unitbuf<span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> nounitbuf<span class="token punctuation">;</span>
</code></pre></div></li> <li><p>关联输入和输出流后任何试图从输入流读都会刷新输出流，交互式系统应该关联这两个流</p></li> <li><p><code>tie</code>函数有两个重载版本</p> <ul><li>不带参数，返回指向输出流的指针。若当前对象关联到一个输出流，则返回的就是指向这个流的指针，若未关联流，则返回空指针</li> <li>接收一个指向<code>ostream</code>的指针，将自己关联到此<code>ostream</code>，即<code>x.tie(&amp;o)</code>为将流x关联到输出流o</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//cin关联到cout</span>
cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cout<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//old_tie为当前关联到cin的流</span>
ostream <span class="token operator">&amp;</span>old_tie <span class="token operator">=</span> cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//cin关联到cerr</span>
cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cerr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>除了继承自<code>iostream</code>，<code>fstream</code>中还增加了新成员来管理与流关联的文件</p> <table><thead><tr><th>操作</th> <th>描述</th></tr></thead> <tbody><tr><td><em>fstream</em> fstrm;</td> <td>创建一个未绑定的文件流，<em>fstream</em>时头文件fstream中定义的一个类型</td></tr> <tr><td><em>fstream</em> fstrm(s);</td> <td>创建一个<em>fstream</em>，并打开名为s的文件</td></tr> <tr><td><em>fstream</em> fstrm(s,mode)</td> <td>按指定mode打开文件</td></tr> <tr><td>fstrm.open(s)</td> <td>打开名为s的文件</td></tr> <tr><td>fstrm.close()</td> <td>关闭与fstrm绑定的文件</td></tr> <tr><td>fstrm.is_open()</td> <td>判断关联文件是否成功打开且尚未关闭</td></tr></tbody></table></li> <li><p>示例</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//打开文件ifile关联到流in</span>
ifstream <span class="token function">in</span><span class="token punctuation">(</span>ifile<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//输出流未关联任何内容</span>
ofstream out<span class="token punctuation">;</span>
</code></pre></div></li> <li><p>文件模式（mode）</p> <table><thead><tr><th>模式</th> <th>描述</th></tr></thead> <tbody><tr><td>in</td> <td>打开读</td></tr> <tr><td>out</td> <td>打开写</td></tr> <tr><td>app</td> <td>追加</td></tr> <tr><td>ate</td> <td>打开后定位到文件尾</td></tr> <tr><td>trunc</td> <td>截断</td></tr> <tr><td>binary</td> <td>二进制方式进行IO</td></tr></tbody></table></li> <li><p>默认以<code>out</code>打开的文件会被截断，若不想被截断需要同时指定<code>app</code></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//未指定打开模式</span>
ofstream out<span class="token punctuation">;</span>
<span class="token comment">//默认为输出和截断</span>
out<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">&quot;test&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
out<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//输出和追加</span>
out<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">&quot;test2&quot;</span><span class="token punctuation">,</span>ofstream<span class="token double-colon punctuation">::</span>app<span class="token punctuation">)</span><span class="token punctuation">;</span>
out<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p><code>stringstream</code>支持内存IO，可用于向string读写数据</p></li> <li><p><code>stringstream</code>特有操作</p> <table><thead><tr><th>操作</th> <th>描述</th></tr></thead> <tbody><tr><td><em>sstream</em> strm;</td> <td>strm是未绑定的stringstream对象，<em>sstream</em>是头文件sstream中定义的一个类型</td></tr> <tr><td><em>sstream</em> strm(s);</td> <td>构造string流，保存s的一个拷贝</td></tr> <tr><td>strm.str()</td> <td>返回strm所保存的string的拷贝</td></tr> <tr><td>strm.str(s)</td> <td>将s拷贝到strm中</td></tr></tbody></table></li></ul> <h2 id="_2023-08-10"><a href="#_2023-08-10" class="header-anchor">#</a> 2023/08/10</h2> <ul><li><p>C++ 11中的顺序容器包括</p> <ul><li>vector：可变大小数组，支持快速随机访问</li> <li>deque：双端队列，支持快速随机访问，头尾插入快</li> <li>list：双向链表，只支持双向顺序访问</li> <li>forward_list：单向链表，只支持单向顺序访问</li> <li>array：固定大小数组，支持快速随机访问</li> <li>string：类似vector，但专门用于保存字符</li></ul></li> <li><p>容器通用操作</p> <table><thead><tr><th>项目</th> <th>描述</th></tr></thead> <tbody><tr><td><strong>类型别名</strong></td> <td></td></tr> <tr><td>iterator</td> <td>此容器类型的迭代器类型。如<code>vector&lt;int&gt;::iterator</code></td></tr> <tr><td>const_iterator</td> <td>可读取但不能写的迭代器类型</td></tr> <tr><td>size_type</td> <td>无符号整数类型，表示大小</td></tr> <tr><td>difference_type</td> <td>带符号整数类型，足够保存两个迭代器之间的距离</td></tr> <tr><td>value_type</td> <td>元素类型</td></tr> <tr><td>reference</td> <td>元素的左值类型，与value_type&amp;相同</td></tr> <tr><td>const_reference</td> <td>元素的const左值类型，即const value_type&amp;</td></tr> <tr><td><strong>构造函数</strong></td> <td></td></tr> <tr><td>C c;</td> <td>默认构造，构造空容器</td></tr> <tr><td>C c1(c2);</td> <td>构造s2的拷贝s1</td></tr> <tr><td>C c(b,e);</td> <td>构造c，将迭代器b和e指定的范围内元素拷贝到c</td></tr> <tr><td>C c{a,b,c,...}</td> <td>列表初始化c</td></tr> <tr><td><strong>赋值与swap</strong></td> <td></td></tr> <tr><td>c1 = c2</td> <td>将c1中的元素替换为c2中的元素</td></tr> <tr><td>c1 = {a,b,c,...}</td> <td>将c2中的元素替换为列表中的元素</td></tr> <tr><td>a.swap(b)</td> <td>交换a和b的元素</td></tr> <tr><td>swap(a,b)</td> <td>与a.swap(b)一样。如<code>vector&lt;int&gt;::swap(a,b)</code></td></tr> <tr><td><strong>大小</strong></td> <td></td></tr> <tr><td>c.size()</td> <td>c中元素数量</td></tr> <tr><td>c.max_size()</td> <td>c可保存最大元素个数</td></tr> <tr><td>c.empty()</td> <td>判断c是否为空</td></tr> <tr><td><strong>添加/删除元素（不适用于array）</strong></td> <td></td></tr> <tr><td>c.insert(args)</td> <td>将args中的元素拷贝进c</td></tr> <tr><td>c.emplace(inits)</td> <td>使用inits构造c中的一个元素</td></tr> <tr><td>c.erase(args)</td> <td>删除args指定的元素</td></tr> <tr><td>c.clear()</td> <td>删除c中所有元素</td></tr> <tr><td><strong>关系运算符</strong></td> <td></td></tr> <tr><td>==、!=</td> <td>判断容器是否相等、不等</td></tr> <tr><td>&lt;、&lt;=、&gt;、&gt;=</td> <td>关系运算符。逐个元素比较</td></tr> <tr><td><strong>获取迭代器</strong></td> <td></td></tr> <tr><td>c.begin(),c.end()</td> <td>指定c首尾的的迭代器</td></tr> <tr><td>c.cbegin(),c.cend()</td> <td>指向首位的const迭代器</td></tr> <tr><td><strong>反向容器额外成员（不支持forward_list）</strong></td> <td></td></tr> <tr><td>reverse_iterator</td> <td>按逆序寻址元素的迭代器。如<code>vector&lt;int&gt;::reverse_iterator</code></td></tr> <tr><td>const_reverse_iterator</td> <td>const逆序迭代器</td></tr> <tr><td>c.rbegin(),c.rend()</td> <td>返回指向c的逆向迭代器</td></tr> <tr><td>c.crbegin,c.crend()</td> <td>返回指向c的const逆向迭代器</td></tr></tbody></table></li> <li><p><code>array</code>类型具有固定大小</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token number">42</span><span class="token operator">&gt;</span> a<span class="token punctuation">;</span>
array<span class="token operator">&lt;</span>string<span class="token punctuation">,</span><span class="token number">10</span><span class="token operator">&gt;</span> b<span class="token punctuation">;</span>
<span class="token comment">//大小类型</span>
array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>size_type i<span class="token punctuation">;</span>
array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>size_type j<span class="token punctuation">;</span><span class="token comment">//错误，array&lt;int&gt;不算一个类型</span>
</code></pre></div></li> <li><p>内置数组不支持拷贝或对象赋值，但array可以</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> digs<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> cpy<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> digs<span class="token punctuation">;</span><span class="token comment">//错误</span>

array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token operator">&gt;</span> digits <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token operator">&gt;</span> copy <span class="token operator">=</span> digits<span class="token punctuation">;</span><span class="token comment">//正确</span>
</code></pre></div></li> <li><p>数字与string的转换</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
string s <span class="token operator">=</span> <span class="token function">to_string</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//数字转string</span>

<span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token function">stod</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//string转double。类似的还有stol、stoi等</span>
</code></pre></div></li> <li><p>容器适配器：一个容器适配器接受一种已有的容器，并使得其行为看起来像一种不同的类型。如stack适配器可接受一个顺序容器（除array和forward_list），并使其操作像一个stack</p></li> <li><p>标准库定义了三个顺序容器适配器：stack、queue和priority_queue</p></li> <li><p>容器适配器支持的操作</p> <table><thead><tr><th>类型/操作</th> <th>描述</th></tr></thead> <tbody><tr><td>size_type</td> <td></td></tr> <tr><td>value_type</td> <td></td></tr> <tr><td>container_type</td> <td>实现适配器底层的容器类型</td></tr> <tr><td>A a;</td> <td></td></tr> <tr><td>A a(c);</td> <td></td></tr> <tr><td>关系运算符</td> <td>都支持</td></tr> <tr><td>a.empty()</td> <td></td></tr> <tr><td>a.size()</td> <td></td></tr> <tr><td>swap(a,b)</td> <td></td></tr> <tr><td>a.swap(b)</td> <td></td></tr></tbody></table></li> <li><p>假设deq为<code>deque&lt;int&gt;</code></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">stk</span><span class="token punctuation">(</span>deq<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>默认情况下stack和queue基于<code>deque</code>实现。priority_queue基于vector实现。可在创建适配器时将一个命名顺序容器作为第二个类型参数来重载默认容器类型</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//vector上实现的空栈</span>
stack<span class="token operator">&lt;</span>string<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;&gt;</span> str_stk<span class="token punctuation">;</span>
<span class="token comment">//vector上实现的栈，初始化时保存svec的拷贝</span>
stack<span class="token operator">&lt;</span>string<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;&gt;</span> <span class="token function">str_stk2</span><span class="token punctuation">(</span>svec<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul> <h2 id="_2023-08-14"><a href="#_2023-08-14" class="header-anchor">#</a> 2023/08/14</h2> <ul><li><p>多数容器相关的算法都定义在<code>algorithm</code>中，标准库还在<code>numeric</code>中定义了一组数值泛型算法</p></li> <li><p>通常这些泛型算法不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作</p></li> <li><p>常用算法</p> <ul><li><p><code>find</code></p></li> <li><p><code>accumulate</code></p></li> <li><p><code>equal</code></p></li> <li><p><code>fill</code></p></li> <li><p><code>fill_n</code></p></li> <li><p><code>copy</code></p></li> <li><p><code>replace</code></p></li> <li><p><code>replace_copy</code>：replace的拷贝版本，不会影响replace原来的数据</p></li> <li><p><code>sort</code></p></li> <li><p><code>unique</code></p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">//排序</span>
<span class="token function">sort</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//返回指向不重复区域之后一个位置的迭代器</span>
<span class="token keyword">auto</span> end_unique <span class="token operator">=</span> <span class="token function">unique</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//使用erease完成真正的删除操作</span>
words<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>end_unique<span class="token punctuation">,</span>words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p><code>for_each</code>：接受一个lambda表达式操作对象</p></li></ul></li> <li><p>可调用对象（callable object）：可对其使用调用运算符<code>()</code>的。主要有</p> <ul><li>函数</li> <li>函数指针</li> <li>重载了函数调用运算符的类</li> <li>lambda表达式</li></ul></li> <li><p>lambda表达式形式</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token punctuation">[</span>capture list<span class="token punctuation">]</span> <span class="token punctuation">(</span>paramter list<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">return</span> type <span class="token punctuation">{</span>function body<span class="token punctuation">}</span>
</code></pre></div><ul><li>capture list：lambda所在函数中定义的局部变量的列表</li></ul></li> <li><p>可忽略参数列表和返回类型，但必须永远包含捕获列表和函数体</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>lambda表达式不能有默认参数</p></li> <li><p>参数捕获示例</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> y <span class="token operator">=</span> <span class="token number">5.0</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> printx <span class="token operator">=</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span>x<span class="token operator">&lt;&lt;</span><span class="token string">&quot; : &quot;</span><span class="token operator">&lt;&lt;</span>y<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">printx</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>捕获列表仅用于局部非static变量。lambda表达式中可以直接使用局部static变量和所在函数之外声明的所有变量</p></li> <li><p>lambda表达式的参数捕获可以是值，也可以值引用</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">auto</span> valuef <span class="token operator">=</span> <span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> reff <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>x<span class="token punctuation">]</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>隐式捕获：除了显式列出我们希望使用哪些函数变量，还可以让编译器根据lambda体中的代码来推断我们使用哪些变量。为了指示编译器推断捕获列表，应在捕获列表中写一个<code>&amp;</code>（引用捕获）或<code>=</code>（值捕获）</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">auto</span> f1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> f2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>可以混合使用显式捕获和隐式捕获，但隐式捕获必须放在前边</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//c按值捕获，其他按引用捕获</span>
<span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">,</span>c<span class="token punctuation">]</span> <span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span>x<span class="token operator">&lt;&lt;</span>c<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>可变lambda：默认情况下，对于一个值拷贝的变量，lambda不会改变其值，如果希望能改变一个被捕获的变量的值，则必须在参数列表首加上关键字<code>mutable</code>（不会影响原值，只影响捕获的值）</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">mutable</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">++</span>x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;x: &quot;</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; y: &quot;</span> <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

<span class="token comment">//x=3 , y=4</span>
</code></pre></div></li> <li><p>一般重复的且需要多语句才能完成的功能应该使用函数而不是lambda表达式。但对于某些捕获局部变量的lambda表达式来说，并不好将其换为函数，如</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token function">find_if</span><span class="token punctuation">(</span>vbegin<span class="token punctuation">,</span>vend<span class="token punctuation">,</span><span class="token punctuation">[</span>sz<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> s<span class="token punctuation">.</span>size <span class="token operator">&gt;=</span> sz<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>如果使用下述函数代替，将会面临如何传递sz参数的问题</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">bool</span> <span class="token function">check_size</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s<span class="token punctuation">,</span>string<span class="token double-colon punctuation">::</span>size_type sz<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> sz<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>可使用标准库的<code>bind</code>函数解决上述问题，<code>bind</code>定义在<code>functional</code>头文件中，可以将<code>bind</code>看作一个通用的函数适配器，其接受一个可调用对象，生成一个新的可调用对象来适配原对象的参数列表</p></li> <li><p>调用<code>bind</code>一般形式为</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">auto</span> newcallable <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span>callable<span class="token punctuation">,</span> arg_list<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>arg_list中的参数可能包含形如<code>_n</code>的名字，其中n是一个整数，这些参数是占位符，表示newcallable的参数。值n表示生成的可调用对象中参数的位置，如<code>_1</code>表示第一个参数</p></li> <li><p>可使用<code>bind</code>绑定<code>check_size</code>的<code>sz</code>参数</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//check6的第一个参数（_1）将作为check_size的第一个参数</span>
<span class="token keyword">auto</span> check6 <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span>check_size<span class="token punctuation">,</span>_1<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>此bind调用有一个占位符，此占位符表示对应于<code>check_size</code>的第一个参数，是一个<code>const string &amp;</code>，调用<code>check6</code>必须传一个此参数</p></li> <li><p>名称<code>_n</code>都定义在名为<code>placeholder</code>的命名空间中，而此名空间本身定义在<code>std</code>中</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">fx</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>
    cout<span class="token operator">&lt;&lt;</span>x<span class="token operator">&lt;&lt;</span><span class="token string">&quot; : &quot;</span><span class="token operator">&lt;&lt;</span>y<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">auto</span> f2 <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span>fx<span class="token punctuation">,</span>placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">f2</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>用<code>bind</code>可重排参数顺序</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token double-colon punctuation">::</span>placeholders<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">fx</span><span class="token punctuation">(</span><span class="token keyword">int</span> p1<span class="token punctuation">,</span> <span class="token keyword">int</span> p2<span class="token punctuation">,</span> <span class="token keyword">int</span> p3<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> p1 <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;-&gt;&quot;</span> <span class="token operator">&lt;&lt;</span> p2 <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;-&gt;&quot;</span> <span class="token operator">&lt;&lt;</span> p3 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">auto</span> fx2 <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span>fx<span class="token punctuation">,</span> _3<span class="token punctuation">,</span> _2<span class="token punctuation">,</span> _1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fx</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//1-&gt;2-&gt;3</span>
    <span class="token function">fx2</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//3-&gt;2-&gt;1</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>如果希望传递给<code>bind</code>一个对象但不拷贝它（传递引用），则需要使用标准库的<code>ref()</code>函数</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token function">for_each</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">bind</span><span class="token punctuation">(</span>print<span class="token punctuation">,</span><span class="token function">ref</span><span class="token punctuation">(</span>os<span class="token punctuation">)</span><span class="token punctuation">,</span>_1<span class="token punctuation">,</span><span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>函数<code>ref</code>返回一个对象，其包含给定的引用。此对象是可拷贝的，还有一个<code>cref</code>，生成一个保存const引用的类</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> xx <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> yy <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span>xx<span class="token punctuation">)</span><span class="token punctuation">;</span>
yy <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>
cout<span class="token operator">&lt;&lt;</span>xx<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment">//2</span>

<span class="token keyword">int</span> <span class="token operator">&amp;</span>yyy <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span>xx<span class="token punctuation">)</span><span class="token punctuation">;</span>
yyy<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">;</span>
cout<span class="token operator">&lt;</span>xx<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment">//9</span>
</code></pre></div></li></ul> <h2 id="_2023-08-16"><a href="#_2023-08-16" class="header-anchor">#</a> 2023/08/16</h2> <ul><li><p>除了为每个容器定义的迭代器外，标准库在头文件<code>iterator</code>中还定义了额外几种迭代器，包括：</p> <ul><li>插入迭代器：绑定到一个容器上，可用来向容器插入元素</li> <li>流迭代器：绑定到输入或输出流上，可用来遍历所关联的IO流</li> <li>反向迭代器：向后移动而不是向前移动，forward_list不支持</li> <li>移动迭代器：不用于拷贝元素，用于移动元素</li></ul></li> <li><p>插入迭代器的三种类型</p> <ul><li><code>back_inserter</code>：创建使用push_back的迭代器</li> <li><code>front_inserter</code>：创建使用push_front的迭代器</li> <li><code>inserter</code>：创建使用insert的迭代器</li></ul></li> <li><p>调用<code>inserter(c,iter)</code>时（c表示容器），得到一个迭代器，接下来使用时，会将元素插入到<code>iter</code>原来所指向元素之前的位置。下面代码效果是一样的</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token operator">*</span>it <span class="token operator">=</span> val<span class="token punctuation">;</span>
</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//it指向新元素</span>
it <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//递增使其指向原来的元素</span>
<span class="token operator">++</span>it<span class="token punctuation">;</span>
</code></pre></div></li> <li><p><code>front_inserter</code>总是在最前插入</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> list1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> list2<span class="token punctuation">;</span>
list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> list3<span class="token punctuation">;</span>

<span class="token comment">//list2 = 4,3,2,1</span>
<span class="token function">copy</span><span class="token punctuation">(</span>list1<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> list1<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">front_inserter</span><span class="token punctuation">(</span>list2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//list3 = 1,2,3,4</span>
<span class="token function">copy</span><span class="token punctuation">(</span>list1<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> list1<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">inserter</span><span class="token punctuation">(</span>list3<span class="token punctuation">,</span> list3<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>虽然<code>iostream</code>类型并非容器，但是标准库定义了用于这些IO类型对象的迭代器。<code>istream_iterator</code>读取输入流，<code>ostream_iterator</code>向一个输出流写数据，使用迭代器，就可以用泛型算法来从流对象读取数据以及向其写入数据</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//从cin读取int</span>
istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">int_it</span><span class="token punctuation">(</span>cin<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//以默认初始化迭代器，此迭代器可当作尾后迭代器</span>
istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> int_eof<span class="token punctuation">;</span>
ifstream <span class="token function">in</span><span class="token punctuation">(</span><span class="token string">&quot;afile&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//从 afile 读取字符串</span>
istream_iterator<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">str_it</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code>istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">int_iter</span><span class="token punctuation">(</span>cin<span class="token punctuation">)</span><span class="token punctuation">;</span>
istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> eof<span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>in_iter <span class="token operator">!=</span> eof<span class="token punctuation">)</span>
    vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token operator">*</span>in_iter<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//上述代码等价于</span>
istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">in_iter</span><span class="token punctuation">(</span>cin<span class="token punctuation">)</span><span class="token punctuation">,</span>eof<span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">vec</span><span class="token punctuation">(</span>in_iter<span class="token punctuation">,</span>eof<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//从迭代范围构造vec</span>
</code></pre></div></li> <li><p><code>ostream_iterator</code></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//第二参数可选，每次输出一个元素时都输出第二参数指定C风格字符串</span>
ostream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">out_iter</span><span class="token punctuation">(</span>cout<span class="token punctuation">,</span><span class="token string">&quot;c&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>item<span class="token operator">:</span> list1<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//可以不用解引用和递增运算（*out_iter++ = item）</span>
    out_iter<span class="token operator">=</span>item<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>通过copy打印元素</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token function">copy</span><span class="token punctuation">(</span>list1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>list1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>out_iter<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul> <h2 id="_2023-08-21"><a href="#_2023-08-21" class="header-anchor">#</a> 2023/08/21</h2> <ul><li><p>标准库提供8个关联容器，以<code>multi</code>开头的表示允许重复的关键字；以<code>unordered</code>开头的表示不按顺序存储关键字</p></li> <li><p>map和multimap定义在map头文件中；set和multiset定义在set头文件中；无序容器定义在unordered_map和unordered_set中</p> <table><thead><tr><th>容器</th> <th>描述</th></tr></thead> <tbody><tr><td>按关键字有序保存元素</td> <td></td></tr> <tr><td>map</td> <td>关联数组，保存键值对</td></tr> <tr><td>set</td> <td>只保存关键字</td></tr> <tr><td>multimap</td> <td>关键字可重复出现的map</td></tr> <tr><td>multiset</td> <td>关键字可重复出现的set</td></tr> <tr><td>无序集合</td> <td></td></tr> <tr><td>unordered_map</td> <td>用hash函数组织的map</td></tr> <tr><td>unordered_set</td> <td>用hash函数组织的set</td></tr> <tr><td>unordered_multimap</td> <td>hash组织的map，关键字可重复出现</td></tr> <tr><td>unorderad_multiset</td> <td>hash组织的set，关键字可重复出现</td></tr></tbody></table></li> <li><p>map使用</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span>size_t<span class="token operator">&gt;</span> count_map<span class="token punctuation">;</span>
string word<span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>cin<span class="token operator">&gt;&gt;</span>word<span class="token punctuation">)</span>
    <span class="token operator">++</span>count_map<span class="token punctuation">[</span>word<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>item<span class="token operator">:</span> count_map<span class="token punctuation">)</span>
    cout<span class="token operator">&lt;&lt;</span>item<span class="token punctuation">.</span>first<span class="token operator">&lt;&lt;</span><span class="token string">&quot; occurs &quot;</span><span class="token operator">&lt;&lt;</span>item<span class="token punctuation">.</span>second<span class="token operator">&lt;&lt;</span><span class="token string">&quot; time(s)&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
</code></pre></div></li> <li><p>map和set的<code>find</code>函数用于查找其中的元素，若有则返回该元素位置的迭代器，否则返回尾后迭代器，即<code>map.end()/set.end()</code></p></li> <li><p>map和set的初始化</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> string<span class="token operator">&gt;</span> test_map <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">&quot;k1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;v1&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
                                <span class="token punctuation">{</span><span class="token string">&quot;k2&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;v2&quot;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

set<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> test_set <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;c&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>map和set的关键字类型必须定义行为正常的<code>&lt;</code>运算符</p></li> <li><p>若自定义类型中没有定义<code>&lt;</code>运算符，则可在定义容器时指定比较操作类型（函数指针类型，指向一个比较函数）</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">MyType</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> field1<span class="token punctuation">;</span>
    <span class="token keyword">int</span> field2<span class="token punctuation">;</span>

    <span class="token function">MyType</span><span class="token punctuation">(</span><span class="token keyword">int</span> field1<span class="token punctuation">,</span> <span class="token keyword">int</span> field2<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">field1</span><span class="token punctuation">(</span>field1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">field2</span><span class="token punctuation">(</span>field2<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">print_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> field1 <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;:&quot;</span> <span class="token operator">&lt;&lt;</span> field2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//定义了 &lt; 操作，因此可以用于set&lt;&gt;的关键字类型</span>
    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyType <span class="token operator">&amp;</span>other<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-&gt;</span>field1 <span class="token operator">&lt;</span> other<span class="token punctuation">.</span>field1<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    MyType <span class="token function">m1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    MyType <span class="token function">m2</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    set<span class="token operator">&lt;</span>MyType<span class="token operator">&gt;</span> my_type_set <span class="token operator">=</span> <span class="token punctuation">{</span>m1<span class="token punctuation">,</span> m2<span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>item<span class="token operator">:</span> my_type_set<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        item<span class="token punctuation">.</span><span class="token function">print_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">MyType</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> field1<span class="token punctuation">;</span>
    <span class="token keyword">int</span> field2<span class="token punctuation">;</span>

    <span class="token function">MyType</span><span class="token punctuation">(</span><span class="token keyword">int</span> field1<span class="token punctuation">,</span> <span class="token keyword">int</span> field2<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">field1</span><span class="token punctuation">(</span>field1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">field2</span><span class="token punctuation">(</span>field2<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">print_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> field1 <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;:&quot;</span> <span class="token operator">&lt;&lt;</span> field2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//类中未定义 &lt; 操作符，需要有比较函数</span>
<span class="token keyword">bool</span> <span class="token function">my_type_comparator</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyType <span class="token operator">&amp;</span>m1<span class="token punctuation">,</span> <span class="token keyword">const</span> MyType <span class="token operator">&amp;</span>m2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> m1<span class="token punctuation">.</span>field1 <span class="token operator">&lt;</span> m2<span class="token punctuation">.</span>field1<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    MyType <span class="token function">m1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    MyType <span class="token function">m2</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//需要多指定比较操作类型——一种函数指针类型</span>
    set<span class="token operator">&lt;</span>MyType<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>my_type_comparator<span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">&gt;</span> my_type_set <span class="token operator">=</span> <span class="token punctuation">{</span>m1<span class="token punctuation">,</span> m2<span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>item<span class="token operator">:</span> my_type_set<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        item<span class="token punctuation">.</span><span class="token function">print_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="_2023-08-24"><a href="#_2023-08-24" class="header-anchor">#</a> 2023/08/24</h2> <ul><li><p><code>pair</code>类型是标准库的类型，定义在头文件<code>utility</code>中，一个<code>pair</code>保存两个数据成员。两个成员都是public的，分别为<code>first</code>和<code>second</code></p></li> <li><p><code>pair</code>上的操作包括</p> <table><thead><tr><th>操作</th> <th>描述</th></tr></thead> <tbody><tr><td>pair&lt;T1,T2&gt; p;</td> <td></td></tr> <tr><td>pair&lt;T1,T2&gt; (v1,v2);</td> <td></td></tr> <tr><td>pair&lt;T1,T2&gt; {v1,v2};</td> <td>等价于上一种</td></tr> <tr><td>make_pair(v1,v2)</td> <td>用值v1，v2构建一个pair，类型由推断得出</td></tr> <tr><td>p.first</td> <td></td></tr> <tr><td>p.second</td> <td></td></tr> <tr><td>p1 relop p2</td> <td>关系运算。p1.first &lt; p2.first 或 !(p2.first &lt; p1.first) &amp;&amp; p1.second &lt; p2.second时为true</td></tr> <tr><td>p1==p2</td> <td></td></tr> <tr><td>p1 != p2</td> <td></td></tr></tbody></table></li> <li><p>关联容器中额外定义的类型</p> <table><thead><tr><th>类型</th> <th>描述</th></tr></thead> <tbody><tr><td>key_type</td> <td>关键字key类型</td></tr> <tr><td>mapped_type</td> <td>每个关键字关联的类型，只适用于map</td></tr> <tr><td>value_type</td> <td>对于set，与key_type相同；对于map，为pair&lt;const key_type,mapped_type&gt;</td></tr></tbody></table> <div class="language-cpp extra-class"><pre class="language-cpp"><code>set<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value_type v1<span class="token punctuation">;</span><span class="token comment">//string</span>
set<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>key_type v2<span class="token punctuation">;</span><span class="token comment">//string</span>
<span class="token comment">//key不能改变，因此为const</span>
map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value_type v3<span class="token punctuation">;</span><span class="token comment">//pair&lt;const string,int&gt;</span>
map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>key_type v4<span class="token punctuation">;</span><span class="token comment">//string</span>
map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>mapped_type v5<span class="token punctuation">;</span><span class="token comment">//int</span>
</code></pre></div></li> <li><p>map中存的是<code>pair</code>，可改变其中<code>pair</code>的值，但不能改变<code>pair</code>的键</p></li> <li><p>set类型的迭代器都不能改变其中元素的值，可用set读取元素但不能修改元素</p></li> <li><p>map和set使用<code>insert</code>成员函数来插入元素，插入已存在的元素对容器没有任何影响</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span>string<span class="token operator">&gt;</span> s_map<span class="token punctuation">;</span>
s_map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">&quot;k1&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;v1&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
s_map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">&quot;k1&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;v3&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//无影响，不会将v1替换为v3</span>
</code></pre></div></li> <li><p>关联容器的insert操作</p> <table><thead><tr><th>操作</th> <th>描述</th></tr></thead> <tbody><tr><td>c.insert(v)<br>c.emplace(args)</td> <td>v为value_type类型对象，args用来构造一个元素。对于map和set，只有当元素key不在c中时才插入，函数返回一个pair，包含一个迭代器，指向具有指定关键字的元素（first），和一个表示插入是否成功的bool值（second）</td></tr> <tr><td>c.insert(b,e)<br>c.insert(il)</td> <td>b和e为迭代器，表示value_type的类型的值范围；il是这种值的初始化列表，函数返回void</td></tr> <tr><td>c.insert(p,v)<br>c.emplace(p,args)</td> <td>类似insert(v)，但将迭代器p作为一个提示，指出从哪里开始搜索新元素应该存储的位置，返回一个迭代器，指向具有给定关键字的元素</td></tr></tbody></table></li></ul> <h2 id="_2023-08-30"><a href="#_2023-08-30" class="header-anchor">#</a> 2023/08/30</h2> <ul><li><p>map和unordered_map容器提供了下标运算符和一个对应的<code>at</code>函数，不能对<code>multimap</code>或<code>unordered_multimap</code>进行下标操作，因为这些容器中有多个值与键关联</p></li> <li><p>map进行下标运算时，如果key不在map中，则会向map中插入，value会进行初始化</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&gt;</span> m<span class="token punctuation">;</span>
<span class="token comment">//word不存在，会插入一个新的，这里值初始化为 0</span>
m<span class="token punctuation">[</span><span class="token string">&quot;word&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">//输出 0</span>
cout<span class="token operator">&lt;&lt;</span>m<span class="token punctuation">[</span><span class="token string">&quot;word&quot;</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>

map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span>size_t<span class="token operator">&gt;</span> word_count<span class="token punctuation">;</span>
<span class="token comment">//插入一个关键字为word的元素，关联值会进行初始化，然后将 1 赋值给它</span>
word_count<span class="token punctuation">[</span><span class="token string">&quot;word&quot;</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>下标操作对比</p> <ul><li><code>c[k]</code>：返回key为k的元素，若k不在c中，则会添加一个关键字为k的元素，值进行初始化</li> <li><code>c.at(k)</code>：访问关键字为k的元素，带参数检查，若k不在c中则抛出一个<code>out_of_range</code>异常</li></ul></li> <li><p>通常解引用一个迭代器所返回的类型与下标运算符返回的类型一样，但是对map则不然，当对一个map进行下标操作时，会获得一个<code>mapped_type</code>对象，当解引用一个map的迭代器时，会得到一个<code>value_type</code>对象</p></li> <li><p>map下标操作返回的是左值，因此可读也可写</p></li> <li><p>在允许重复关键字的容器中，如multimap或multiset，若有多个给定关键字，则这些元素在容器中会相邻存储，如查找所有某个键的值</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>string <span class="token function">search_item</span><span class="token punctuation">(</span><span class="token string">&quot;item&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> entries <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>search_item<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> iter <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>search_item<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>entries<span class="token punctuation">)</span><span class="token punctuation">{</span>
    cout<span class="token operator">&lt;&lt;</span>iter<span class="token operator">-&gt;</span>second<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token comment">//同key的值都是相邻存储的</span>
    <span class="token operator">++</span>iter<span class="token punctuation">;</span>
    <span class="token operator">--</span>entries<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>也可使用<code>lower_bound</code>和<code>upper_bound</code>改写上述程序</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>string <span class="token function">search_item</span><span class="token punctuation">(</span><span class="token string">&quot;item&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> beg <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">lower_bound</span><span class="token punctuation">(</span>search_item<span class="token punctuation">)</span><span class="token punctuation">,</span> end <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">upper_bound</span><span class="token punctuation">(</span>search_item<span class="token punctuation">)</span><span class="token punctuation">;</span> beg <span class="token operator">!=</span> end<span class="token punctuation">;</span> <span class="token operator">++</span>beg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> beg<span class="token operator">-&gt;</span>second <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>此外还可以使用<code>equal_range()</code>函数，其接收一个关键字，返回一个<code>pair</code>，关键字存在则第一个迭代器指向第一个与关键字匹配的元素；第二个迭代器指向最后一个匹配的元素之后的位置。若未找到，两个迭代器都指向可以插入该关键字的位置</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> pos <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">equal_range</span><span class="token punctuation">(</span>search_item<span class="token punctuation">)</span><span class="token punctuation">;</span> pos<span class="token punctuation">.</span>first <span class="token operator">!=</span> pos<span class="token punctuation">.</span>second<span class="token punctuation">;</span> <span class="token operator">++</span>pos<span class="token punctuation">.</span>first<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> pos<span class="token punctuation">.</span>first<span class="token operator">-&gt;</span>second <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>标准库定义了4个无序关联容器，这些容器不是使用比较运算符组织，而是使用一个hash函数和关键字类型的==运算符组织</p></li> <li><p>某些应用中，维护元素序代价可能比较高昂，此时无序容器通常有更好性能</p></li> <li><p>无序容器在存储上组织为一组“桶”，每个桶保存零个或多个元素</p></li> <li><p>无序容器提供了一组管理桶的函数，可以用于查询容器的状态以及必要时强制容器进行重组</p> <table><thead><tr><th>函数</th> <th>描述</th></tr></thead> <tbody><tr><td>桶接口</td> <td></td></tr> <tr><td>c.bucket_count()</td> <td>正在使用的桶数目</td></tr> <tr><td>c.max_bucket_count()</td> <td>容器最大能容纳桶数量</td></tr> <tr><td>c.bucket_size(n)</td> <td>第n个桶有多少个元素</td></tr> <tr><td>c.bucket(k)</td> <td>关键字为 k 的元素在哪个桶中</td></tr> <tr><td>桶迭代</td> <td></td></tr> <tr><td>local_iterator</td> <td>用于访问桶中元素的迭代器</td></tr> <tr><td>const_local_iterator</td> <td>const版本</td></tr> <tr><td>c.begin(n)，c.end(n)</td> <td>桶 n 的首元素迭代器和尾后迭代器</td></tr> <tr><td>c.cbegin(n)，c.cend(n)</td> <td>...</td></tr> <tr><td>哈希策略</td> <td></td></tr> <tr><td>c.load_factor()</td> <td>每个桶的平均元素数量，返回float值</td></tr> <tr><td>c.max_load_factor()</td> <td>c试图维护的平均桶大小，返回float，c会在需要时添加新桶使得load_factor &lt;=max_load_factor</td></tr> <tr><td>c.rehash(n)</td> <td>重组存储，使得bucket_count &gt;= n且bucket_count &gt; size / max_load_factor</td></tr> <tr><td>c.reserve(n)</td> <td>重组存储，使得 c 可以保存 n 个元素且不必rehash</td></tr></tbody></table></li> <li><p>无序容器要求关键字类型有<code>==</code>运算符，或手动指定比较函数，还使用一个<code>hash&lt;key_type&gt;</code>类型的对象来生成每个元素hash值</p></li> <li><p>不能直接定义关键字类型为自定义类型的无序容器，需要提供自己的hash模板。也可以提供函数替代==和哈希计算函数</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">MyType</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> field1<span class="token punctuation">;</span>
    <span class="token keyword">int</span> field2<span class="token punctuation">;</span>

    <span class="token function">MyType</span><span class="token punctuation">(</span><span class="token keyword">int</span> field1<span class="token punctuation">,</span> <span class="token keyword">int</span> field2<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">field1</span><span class="token punctuation">(</span>field1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">field2</span><span class="token punctuation">(</span>field2<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//hash计算函数</span>
size_t <span class="token function">hasher</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyType <span class="token operator">&amp;</span>myType<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">hash</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>myType<span class="token punctuation">.</span>field1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//比较函数(若类中定义了 == 运算符，则可不需要此函数)</span>
<span class="token keyword">bool</span> <span class="token function">eqOp</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyType <span class="token operator">&amp;</span>m1<span class="token punctuation">,</span> <span class="token keyword">const</span> MyType <span class="token operator">&amp;</span>m2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> m1<span class="token punctuation">.</span>field1 <span class="token operator">==</span> m2<span class="token punctuation">.</span>field1 <span class="token operator">&amp;&amp;</span> m1<span class="token punctuation">.</span>field2 <span class="token operator">==</span> m2<span class="token punctuation">.</span>field2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//&lt;&gt;中需要指定hash和比较函数类型指针</span>
<span class="token keyword">using</span> my_type_set <span class="token operator">=</span> unordered_set<span class="token operator">&lt;</span>MyType<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>hasher<span class="token punctuation">)</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>eqOp<span class="token punctuation">)</span> <span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//参数为桶大小、哈希函数指针和比较相等的指针</span>
    my_type_set <span class="token function">mset</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">,</span> hasher<span class="token punctuation">,</span> eqOp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="_2023-08-31"><a href="#_2023-08-31" class="header-anchor">#</a> 2023/08/31</h2> <ul><li><p>C++11标准库提供的两种智能指针区别在于管理底层指针的方式：</p> <ul><li><code>shared_ptr</code>允许多个指针指向同一个对象</li> <li><code>unique_ptr</code>独占所指向的对象</li></ul></li> <li><p>标准库还定义了名为<code>weak_ptr</code>的伴随类，这是一种弱引用，指向<code>shared_ptr</code>所管理的对象。这些类型定义在<code>memory</code>头文件中</p></li> <li><p>智能指针也是模板，模板参数指定指针指向的数据类型</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>shared_ptr<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> p1<span class="token punctuation">;</span>
shared_ptr<span class="token operator">&lt;</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> p2<span class="token punctuation">;</span>
</code></pre></div></li> <li><p>默认初始化的智能指针中保存着一个空指针</p></li> <li><p>shared_ptr和unique_ptr都支持的操作</p> <table><thead><tr><th>操作</th> <th>描述</th></tr></thead> <tbody><tr><td>shared_ptr&lt;T&gt; sp<br>unique_ptr&lt;T&gt; up</td> <td>空智能指针，指向T类型对象</td></tr> <tr><td>p</td> <td>将p用作条件判断，若p指向一个对象，则为true</td></tr> <tr><td>*p</td> <td>解引用p，获取指向对象</td></tr> <tr><td>p-&gt;mem</td> <td>等价于<code>(*p).mem</code></td></tr> <tr><td>p.get()</td> <td>获取p中保存的指针</td></tr> <tr><td>swap(p,q)</td> <td>交换p和q中的指针</td></tr> <tr><td>p.swap(q)</td> <td></td></tr></tbody></table></li> <li><p>shared_ptr独有操作</p> <table><thead><tr><th>操作</th> <th>描述</th></tr></thead> <tbody><tr><td>make_shared&lt;T&gt;(args)</td> <td>返回一个shared_ptr，指向一个动态分配的类型为T的对象，使用args初始化此对象</td></tr> <tr><td>shared_ptr&lt;T&gt;p(q)</td> <td>p是shared_ptr q的拷贝，此操作会递增q中的计数器，q中的指针必须能转换为 T*</td></tr> <tr><td>p = q</td> <td>p和q都是shared_ptr，所保存的指针必须能相互转换，此操作会递减p的引用计数，递增q的引用计数。若p计数变为0则内存将被释放</td></tr> <tr><td>p.unique()</td> <td>若p.use_count()为1，返回true，否则返回false</td></tr> <tr><td>p.use_count()</td> <td>返回与p共享对象的智能指针数量，可能会很慢，主要用于测试</td></tr></tbody></table></li> <li><p>最安全的分配和使用动态内存的方法是调用<code>make_shared</code>函数，此函数在动态内存中分配一个对象并初始化它，返回指向此对象的<code>shared_ptr</code></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>shared_ptr<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> s <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>s <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
</code></pre></div></li></ul> <h2 id="_2023-09-03"><a href="#_2023-09-03" class="header-anchor">#</a> 2023/09/03</h2> <ul><li><p>默认动态分配的对象是默认初始化的，内置类型或组合类型的对象值将会是未定义的；而类对象将使用默认构造函数进行初始化</p></li> <li><p>对于类类型，值初始化和默认初始化没啥区别，但对于内置类型，值初始化和默认初始化差别很大，值初始化的内置类型有良好定义的值</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>string <span class="token operator">*</span>ps1 <span class="token operator">=</span> <span class="token keyword">new</span> string<span class="token punctuation">;</span><span class="token comment">//默认初始化为空字符串</span>
string <span class="token operator">*</span>ps2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//值初始化为空字符串</span>

<span class="token keyword">int</span> <span class="token operator">*</span>pi1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span><span class="token comment">//默认初始化，*pi1是未定义的</span>
<span class="token keyword">int</span> <span class="token operator">*</span>pi2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//值初始化为 0  </span>
</code></pre></div></li> <li><p>若提供了一个括号包围的初始化器，就可使用<code>auto</code>，从此初始化器来推断我们想要分配的对象类型</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//p1指向一个与obj同类型的对象，该对象使用obj进行初始化</span>
<span class="token keyword">auto</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">auto</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//错误，括号中只能有单个初始化器</span>
<span class="token keyword">auto</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">auto</span><span class="token punctuation">{</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>若内存耗尽，<code>new</code>就会失败，默认情况下会抛出<code>bad_alloc</code>类型的异常，可改变<code>new</code>的使用方式阻止抛出异常</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span><span class="token comment">//分配失败时new抛出 std::bad_alloc</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token punctuation">(</span>nothrow<span class="token punctuation">)</span> <span class="token keyword">int</span><span class="token punctuation">;</span><span class="token comment">//分配失败时返回一个空指针</span>
</code></pre></div></li> <li><p>传递给<code>delete</code>的必须是<code>new</code>分配的内存或一个空指针；释放已经释放的内存行为是未定义的</p></li> <li><p><code>delete</code>之后，一个指针就变成所谓<strong>空悬指针（ddangling pointer）</strong></p></li> <li><p>可使用<code>new</code>返回的指针来初始化智能指针</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>接收指针参数的智能指针构造函数是<code>explicit</code>的，因此不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化形式初始化智能指针</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//错误，必须使用直接初始化形式</span>
shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//正确，使用直接初始化形式</span>
shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>智能指针默认使用<code>delete</code>释放内存，但可以该变这个行为，定义和改变<code>shared_ptr</code>的方法</p> <table><thead><tr><th>语法</th> <th>描述</th></tr></thead> <tbody><tr><td>shared_ptr&lt;T&gt; p(q)</td> <td>p管理内置指针q所指向的对象，q必须指向new分配的内存，且能转换为T*</td></tr> <tr><td>shared_ptr&lt;T&gt; p(u)</td> <td>p从unique_ptr  u处接管对象所有权，将u置为空</td></tr> <tr><td>shared_ptr&lt;T&gt; p(q,d)</td> <td>p接管内置指针q所指向对象所有权，q必须能转换为T*类型。p将使用可调用对象d来代替delete</td></tr> <tr><td>shared_ptr&lt;T&gt; p(p2,d)</td> <td>p是shared_ptr  p2的拷贝，p将用可调用对象d替代delete</td></tr> <tr><td>p.reset()<br>p.reset(q)<br>p.reset(q,d)</td> <td>若p是唯一指向其对象的shared_ptr，reset会释放此对象。若传递了可选的参数内置指针q，会令p指向q，否则会将p置为空；若还传递了d，则调用d来释放q而不是delete</td></tr></tbody></table></li> <li><p>默认<code>shared_ptr</code>假定其管理的是动态内存，当一个<code>shared_ptr</code>被销毁时，会对管理对象执行<code>delete</code>操作</p></li> <li><p>可用<code>shared_ptr</code>来管理一个连接，指定自定义删除器传递给<code>shared_ptr</code>即可，删除器可以是释放连接操作</p></li> <li><p>一个<code>unique_ptr</code>拥有其指向的对象，与<code>shared_ptr</code>不同，某时刻只能有一个<code>unique_ptr</code>指向一个给定对象</p></li> <li><p>定义一个<code>unique_ptr</code>时需要将其绑定到一个<code>new</code>返回的指针上，初始化必须采用直接初始化形式</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>unique<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> p1<span class="token punctuation">;</span><span class="token comment">//可指向double的unique_ptr</span>
unique<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//直接初始化</span>
</code></pre></div></li> <li><p><code>unique_ptr</code>不支持普通的拷贝或赋值操作</p></li> <li><p>不能拷贝或赋值<code>unique_ptr</code>，但能通过<code>release</code>或<code>reset</code>将指针所有权从一个非const的<code>unique_ptr</code>转移给另一个</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//所有权从p1转移到p2，置p1为空</span>
unique_ptr<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">p2</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
unique_ptr<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">p3</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">&quot;test&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//所有权从p3转移到p2，释放原来p2指向内存</span>
p2<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>p3<span class="token punctuation">.</span><span class="token function">releasse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>不能拷贝<code>unique_ptr</code>的规则有一个例外：可以拷贝或赋值一个将要被销毁的<code>unique_ptr</code>，如需要从函数返回一个<code>unique_ptr</code></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">unique_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p><code>weak_ptr</code>是一种不控制所指向对象生存周期的智能指针，它指向由一个<code>shared_ptr</code>管理的对象，将<code>weak_ptr</code>绑定到一个<code>shared_ptr</code>不会影响<code>shared_ptr</code>的引用计数</p> <table><thead><tr><th>语法</th> <th>描述</th></tr></thead> <tbody><tr><td>weak_ptr&lt;T&gt; w</td> <td>空weak_ptr</td></tr> <tr><td>weak_ptr&lt;T&gt; w(sp)</td> <td>与shared_ptr sp指向相同对象的weak_ptr</td></tr> <tr><td>w = p</td> <td>p可以是一个shared_ptr或weak_ptr</td></tr> <tr><td>w.reset()</td> <td>将w置空</td></tr> <tr><td>w.use_count()</td> <td>与w共享对象的shared_ptr数量</td></tr> <tr><td>w.expired()</td> <td>若w.use_count()为 0 ，返回true，否则false</td></tr> <tr><td>w.lock()</td> <td>若expired为true，返回空shared_ptr，否则返回指向w的对象的shared_ptr</td></tr></tbody></table></li> <li><p>不能通过<code>weak_ptr</code>直接访问对象，需要使用<code>lock</code>判断</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">if</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> np <span class="token operator">=</span> wp<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//使用sp访问对象</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>C++语言和标准库提供了两种一次分配一个对象数组的方法，C++语言定义了一种<code>new</code>表达式语法；而标准库包含一个名为<code>allocator</code>的类，允许我们将分配和初始化分离</p></li> <li><p>动态分配数组和初始化</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token operator">*</span>pia <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//10个未初始化int</span>
<span class="token keyword">int</span> <span class="token operator">*</span>pia2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//10个初始化为0的int</span>
<span class="token keyword">int</span> <span class="token operator">*</span>pia3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//列表初始化</span>
string <span class="token operator">*</span>spa <span class="token operator">=</span> <span class="token keyword">new</span> string<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//10个空string</span>
string <span class="token operator">*</span>spa2 <span class="token operator">=</span> <span class="token keyword">new</span> string<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//10个空string</span>
string <span class="token operator">*</span>spa3 <span class="token operator">=</span> <span class="token keyword">new</span> string<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token char">'x'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//初始化前3个，后边默认初始化</span>
</code></pre></div></li></ul> <h2 id="_2023-09-05"><a href="#_2023-09-05" class="header-anchor">#</a> 2023/09/05</h2> <ul><li><p>智能指针和数组</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//自动使用delete[]销毁</span>
up<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p><code>unique_ptr</code>用于数组时支持下标运算</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">for</span><span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    up<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
</code></pre></div></li> <li><p><code>new</code>将内存分配和对象构造组合在了一起；<code>delete</code>将对象析构和内存释放组合在了一起。若想要分配多个对象（数组）时，这种默认把对象构造好的行为可能是不必要的，因为后续的初始化数组的操作可能才是构建对象的时间</p></li> <li><p>标准库<code>allocator</code>类定义在<code>memory</code>头文件中，其将对象内存分配和对象构造分离开，其分配的内存是原始的、未构造的</p> <table><thead><tr><th>操作</th> <th>描述</th></tr></thead> <tbody><tr><td>allocator&lt;T&gt; a</td> <td>定义名为a的allocator对象，其可以为类型T对象分配内存</td></tr> <tr><td>a.allocate(n)</td> <td>分配一段原始的未构造的内存，保存n个类型为T的对象</td></tr> <tr><td>a.deallocate(p,n)</td> <td>释放指针p地址开始的内存，这块内存保存了n个类型为T的对象。调用deallocate前必须为每个对象调用destory</td></tr> <tr><td>a.construct(p,args)</td> <td>p为T*类型，指向一块原始内存，args传递给类型为T的构造函数，用来构造一个对象放到p处</td></tr> <tr><td>a.destroy(p)</td> <td>对p指向的对象执行析构函数</td></tr></tbody></table> <div class="language-cpp extra-class"><pre class="language-cpp"><code>allocator<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> allocator<span class="token punctuation">;</span>
string<span class="token operator">*</span> s <span class="token operator">=</span> allocator<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
allocator<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
allocator<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>s<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
allocator<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>s<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">&quot;c&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">++</span><span class="token operator">&lt;</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>s<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    s<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>标准库为<code>allocator</code>类定义了两个伴随算法，可以在未初始化内存中创建对象</p> <table><thead><tr><th>函数</th> <th>描述</th></tr></thead> <tbody><tr><td>uninitialized_copy(b,e,b2)</td> <td>迭代器b和e指定范围拷贝到迭代器b2指定的未构造内存开始处</td></tr> <tr><td>uninitialized_copy_n(b,n,b2)</td> <td>从迭代器b开始拷贝n个元素到b2开始内存中</td></tr> <tr><td>uninitialized_fill(b,e,t)</td> <td>迭代器b和e指定原始内存范围，全部填充为对象t的拷贝</td></tr> <tr><td>uninitialized_fill_n(b,n,t)</td> <td>迭代器b开始的未初始化内存创建n个t对象</td></tr></tbody></table></li> <li><p>一个类定义时，通过显式或隐式定义五种特殊成员函数来指定在此类型对象拷贝、移动、赋值和销毁时做什么，分别是</p> <ul><li>拷贝构造函数</li> <li>拷贝赋值运算符</li> <li>移动构造函数</li> <li>移动赋值运算符</li> <li>析构函数</li></ul></li> <li><p>一个构造函数的第一个参数时自身类型的引用，且任何额外参数都有默认值时，此构造函数时拷贝构造函数。拷贝构造函数在多种情况下会被引用，因此通常不是<code>explicit</code>的</p></li> <li><p>直接初始化和拷贝初始化的区别</p> <ul><li>直接初始化时起始要求编译器使用普通函数匹配来选择与我们提供参数最匹配的构造函数</li> <li>拷贝初始化时，要求编译器将右侧运算的对象拷贝到正在创建的对象中，若有需要还要做类型转换。通常用拷贝构造函数完成</li></ul></li> <li><p>拷贝初始化发生的一些情况</p> <ul><li>给函数传递非引用形参</li> <li>函数返回一个非引用对象</li> <li>用花括号初始化一个数组中的元素或一个聚合类的成员</li> <li>使用 <code>=</code> 定义变量</li></ul></li> <li><p>拷贝构造函数用于初始化非引用类型的参数，因此拷贝构造函数本身参数必须是引用类型的，不然就死循环了</p></li> <li><p>拷贝赋值运算符为<code>=</code>，控制对象如何赋值时可重载此运算符</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">MyType</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">//拷贝构造</span>
    <span class="token function">MyType</span><span class="token punctuation">(</span>MyType <span class="token operator">&amp;</span>myType<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token operator">-&gt;</span>i <span class="token operator">=</span> myType<span class="token punctuation">.</span>i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//拷贝赋值</span>
    MyType <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyType <span class="token operator">&amp;</span>myType<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token operator">-&gt;</span>i <span class="token operator">=</span> myType<span class="token punctuation">.</span>i<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//析构函数</span>
    <span class="token operator">~</span><span class="token function">MyType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>析构函数不接受参数，不能被重载</p></li> <li><p>可以通过将拷贝控制成员函数定义为<code>=default</code>来显示要求编译器生成合成版本</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">MyType</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">//默认构造</span>
    <span class="token function">MyType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>

    <span class="token comment">//默认拷贝构造</span>
    <span class="token function">MyType</span><span class="token punctuation">(</span>MyType <span class="token operator">&amp;</span>other<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>

    <span class="token comment">//默认拷贝赋值</span>
    MyType <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyType <span class="token operator">&amp;</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//默认析构</span>
    <span class="token operator">~</span><span class="token function">MyType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
    
<span class="token punctuation">}</span><span class="token punctuation">;</span>

MyType <span class="token operator">&amp;</span>MyType<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyType <span class="token operator">&amp;</span>other<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>对某些类，拷贝构造和赋值是没有意义的，比如iostream类不允许拷贝。可通过<code>=delete</code>来控制这种“不允许”行为</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">NoCopy</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">//不允许拷贝构造</span>
    <span class="token function">NoCopy</span><span class="token punctuation">(</span>NoCopy<span class="token operator">&amp;</span> other<span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">delete</span><span class="token punctuation">;</span>
    <span class="token comment">//不允许赋值运算</span>
    NoCopy<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> NoCopy<span class="token operator">&amp;</span>other<span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">delete</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>与<code>=default</code>不同，<code>=delete</code>可以对任何函数指定，其能起到引导函数匹配的作用</p></li> <li><p>在新标准之前，类是通过将拷贝构造函数和拷贝赋值运算符声明为<code>private</code>来阻止拷贝的</p></li></ul> <h2 id="_2023-09-06"><a href="#_2023-09-06" class="header-anchor">#</a> 2023/09/06</h2> <ul><li><p>为支持移动操作，新标准引入了一种新引用类型——<strong>右值引用（rvalue reference）</strong>，右值引用就是必须绑定到右值的引用，通过<code>&amp;&amp;</code>而不是<code>&amp;</code>来获得右值引用</p></li> <li><p>右值引用有一个重要性质，即智能绑定到一个将要销毁的对象，因此可以自由地将一个右值引用的资源移动到另一个对象中</p></li> <li><p>一般一个左值表达式表示对象的身份，而右值表达式表示对象的值</p></li> <li><p>类似任何引用，右值引用也是一个对象的另一个名字，对于常规引用（左值引用），不能将其绑定到要求转换的表达式、字面常量或返回右值的表达式；右值引用则完全相反</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token comment">//正确，r引用i</span>
<span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>rr <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token comment">//错误，右值引用不能绑定到左值</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>r2 <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">18</span><span class="token punctuation">;</span><span class="token comment">//错误，i * 18 为右值</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r3 <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token comment">//正确，可将一个const的引用绑定到一个右值上</span>
<span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>rr2 <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token comment">//正确，将rr2绑定到乘法结果上</span>
</code></pre></div></li> <li><p>返回左值引用的函数、连同赋值、下标、解引用和前置递增、减运算符，都是返回左值表达式的例子，可将其返回结果绑定到左值引用上</p></li> <li><p>返回非引用类型的函数，连同算术、关系、位以及后置递增、减运算符都生成右值，可绑定到右值引用上</p></li> <li><p>不能直接将一个右值引用绑定到右值引用类型的变量上，因为变量算是左值</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>rr1 <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>rr2 <span class="token operator">=</span> rr1<span class="token punctuation">;</span><span class="token comment">//错误，表达式rr1为左值</span>
</code></pre></div></li> <li><p>可通过调用名为<code>move</code>的标准库函数来获得绑定到左值上的右值引用，此函数定义在<code>utility</code>中</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>rr3 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>rr1<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>调用<code>move</code>意味着承诺：除了对rr1赋值或销毁它外，我们将不再使用它</p></li> <li><p>可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移动后的对象的值</p></li> <li><p>使用move时应该用<code>std::move</code>，避免命名冲突</p></li> <li><p>类似<code>string</code>等标准库类，自定义类也可以定义移动构造函数和移动赋值运算符</p></li> <li><p>类似拷贝构造，移动构造函数第一个参数时该类类型的一个引用，但是此参数是一个右值引用，任何额外参数都需要有默认值</p></li> <li><p>除了完成资源移动，移动构造函数还必须确保移后源对象处于这样的状态——销毁它是无害的，特别是，在完成移动后，源对象必须不再指向被移动的资源</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token class-name">StrVec</span><span class="token double-colon punctuation">::</span><span class="token function">StrVec</span><span class="token punctuation">(</span>StrVec <span class="token operator">&amp;&amp;</span>s<span class="token punctuation">)</span><span class="token keyword">noexcept</span><span class="token comment">//移动操作不应该抛出任何异常</span>
    <span class="token operator">:</span><span class="token function">elements</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>elements<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">first_free</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>first_free<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">cap</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>cap<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//移动完后源对象元素置空，保证对其运行析构函数是安全的</span>
        s<span class="token punctuation">.</span>elements <span class="token operator">=</span> s<span class="token punctuation">.</span>first_free <span class="token operator">=</span> s<span class="token punctuation">.</span>cap <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div></li> <li><p>移动操作通常不会分配任何资源，因此通常不会抛出任何异常。当编写一个不抛出异常的移动操作时，应该通过<code>noexcept</code>通知标准库，避免为了处理可能存在的异常做一些额外的工作</p> <blockquote><p>为何需要noexcept ？</p> <p>以vector为例，调用push_back时，可能要求为vector重新分配内存空间，当重新分配时，vector将元素从旧空间移动到新内存</p> <p>而移动一个对象通常会改变其值，若重新分配过程中使用了移动构造函数且在移动部分元素之后产生了异常，就会出现问题，此时vector无法保证在push_back发生异常时保证自身不变</p> <p>若vector使用拷贝构造，则即使发生了异常，也可以很容易恢复。在新内存构造对象时，旧对象并不受影响</p> <p>为避免这种潜在问题，vector必须知道元素类型的移动构造函数不会抛出异常，否则其只能使用拷贝构造函数而不是移动构造函数</p> <p>若希望vector重新分配内存时进行移动而不是拷贝，就要指明noexcept</p></blockquote></li> <li><p>移动赋值运算符执行和析构函数以及移动构造函数相同的工作</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>StrVec <span class="token operator">&amp;</span>StrVec<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>StrVec <span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span><span class="token keyword">noexcept</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>other<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">free</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放已有元素</span>
        <span class="token comment">//...和移动构造相同逻辑</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>若一个类没有移动构造函数，根据函数匹配，类会选择对应的拷贝操作代替移动操作</p></li> <li><p>当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可移动时，编译器才会自动生成合成移动构造函数或移动赋值运算符</p></li> <li><p>定义移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作，否则这些类成员默认地被定义为删除的</p></li> <li><p>一个类既有移动构造函数，又有拷贝构造函数时，编译器使用普通函数匹配规则来确定调用哪个构造函数</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>StrVec v1<span class="token punctuation">,</span>v2<span class="token punctuation">;</span>
v1 <span class="token operator">=</span> v2<span class="token punctuation">;</span><span class="token comment">//v2为左值，使用拷贝赋值</span>
StrVec <span class="token function">getVec</span><span class="token punctuation">(</span>istream <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
v2 <span class="token operator">=</span> <span class="token function">getVec</span><span class="token punctuation">(</span>cin<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//getVec返回右值，使用移动赋值。此时按函数匹配也可调用拷贝赋值，但需要进行一次到const的转换，而StrVec&amp;&amp;则是精确匹配，因此会使用移动赋值</span>
</code></pre></div></li> <li><p>若一个类只有拷贝构造而没有移动构造，则编译器不会合成移动构造函数，此时函数匹配规则保证该类型的对象只会拷贝，即使试图调用<code>move</code>来移动</p></li> <li><p>三五法则：所有五个拷贝控制成员应该看作一个整体，一般而言，一个类定义了任何一个拷贝操作，就应该定义所有五个操作</p></li></ul> <h2 id="_2023-09-12"><a href="#_2023-09-12" class="header-anchor">#</a> 2023/09/12</h2> <ul><li><p>标准库定义了一种移动迭代器适配器。一个移动迭代器通过改变给定迭代器的解引用运算符行为来适配迭代器。通常一个迭代器的解引用返回一个指向元素的左值，而移动迭代器解引用生成一个右值引用</p></li> <li><p>可通过<code>make_move_iterator</code>将一个普通迭代器转换为一个移动迭代器，而将移动迭代器传递给<code>uninitialized_copy</code>则可进行移动初始化</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token class-name">StrVec</span><span class="token double-colon punctuation">::</span><span class="token function">reallocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">auto</span> newcapacity <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> last <span class="token operator">=</span> <span class="token function">uninitialized_copy</span><span class="token punctuation">(</span><span class="token function">make_move_iterator</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                   <span class="token function">make_move_iterator</span><span class="token punctuation">(</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                   first<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">free</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
elements <span class="token operator">=</span> first<span class="token punctuation">;</span>
first_free <span class="token operator">=</span> last<span class="token punctuation">;</span>
cap <span class="token operator">=</span> elements <span class="token operator">+</span> newcapacity<span class="token punctuation">;</span>
</code></pre></div></li> <li><p>除了构造函数和赋值运算符外，若一个成员函数同时提供拷贝和移动版本，其也会从中受益。这种允许移动的成员函数通常使用与拷贝/移动构造函数和赋值运算符相同的参数模式——一个版本接受指向const的左值引用，另一个版本接受一个指向非const的右值引用</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">const</span> X<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//拷贝</span>
<span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span>X<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span><span class="token comment">//移动</span>
</code></pre></div></li> <li><p>C++中允许对右值进行赋值，但不会改变原值</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>string s1 <span class="token operator">=</span> <span class="token string">&quot;a value&quot;</span><span class="token punctuation">,</span> s2 <span class="token operator">=</span> <span class="token string">&quot;another&quot;</span><span class="token punctuation">;</span>
s1 <span class="token operator">+</span> s2 <span class="token operator">=</span> <span class="token string">&quot;new value&quot;</span><span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> s1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//a value</span>
cout <span class="token operator">&lt;&lt;</span> s2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//another</span>
</code></pre></div></li> <li><p>若要在自己的类中禁止这种赋值，可以强制左侧运算对象（即this指向的对象）是一个左值</p></li> <li><p>定义this的左值/右值属性的方式与定义const成员函数一样，在参数列表后放置一个引用限定符（reference qualifier）即可</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    Foo <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Foo <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Foo <span class="token operator">&amp;</span>Foo<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Foo <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div></li> <li><p>引用限定符可以是<code>&amp;</code>或<code>&amp;&amp;</code>，分别指出this可以指向一个左值或右值，类似const，引用限定符只能用于非static成员函数，且必须同时出现在声明和定义中</p></li> <li><p>同时使用const和引用限定时，const在前</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    Foo <span class="token function">somefunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token operator">&amp;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>成员函数可以根据是否有const来区分重载版本，引用限定符也可以区分重载版本</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    Foo <span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span><span class="token punctuation">;</span><span class="token comment">//可用于可改变的右值</span>
    Foo <span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">&amp;</span><span class="token punctuation">;</span><span class="token comment">//可用于任何类型的Foo</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> data<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//this为右值，因此可以安全地进行原址排序</span>
Foo <span class="token class-name">Foo</span><span class="token double-colon punctuation">::</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span><span class="token punctuation">{</span>
    <span class="token function">sort</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> data<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//this为const或左值，不能进行原址排序，可能有其他用户在用</span>
Foo <span class="token class-name">Foo</span><span class="token double-colon punctuation">::</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">&amp;</span><span class="token punctuation">{</span>
    Foo <span class="token function">ret</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sort</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ret<span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>重载运算符函数的参数数量与运算符作用运算对象数量一样多，一元有一个，二元有两个。对于二元运算符，左侧运算对象传递给第一个参数，右侧对象传递给第二个参数</p></li> <li><p>除了重载函数调用运算符<code>operator()</code>外，其他重载运算符不能有默认实参</p></li> <li><p>若一个运算符函数是成员函数，则它的第一个（左侧）运算对象隐式绑定到this指针上</p></li> <li><p>无法改变内置类型的运算符</p></li> <li><p>可被重载的运算符</p> <table><thead><tr><th>可被重载</th> <th></th> <th></th> <th></th> <th></th> <th></th></tr></thead> <tbody><tr><td>+</td> <td>-</td> <td>*</td> <td>/</td> <td>%</td> <td>^</td></tr> <tr><td>&amp;</td> <td>|</td> <td>~</td> <td>!</td> <td>,</td> <td>=</td></tr> <tr><td>&lt;</td> <td>&gt;</td> <td>&lt;=</td> <td>&gt;=</td> <td>++</td> <td>--</td></tr> <tr><td>&lt;&lt;</td> <td>&gt;&gt;</td> <td>==</td> <td>!=</td> <td>&amp;&amp;</td> <td>||</td></tr> <tr><td>+=</td> <td>-=</td> <td>/=</td> <td>%=</td> <td>^=</td> <td>&amp;=</td></tr> <tr><td>|=</td> <td>*=</td> <td>&lt;&lt;=</td> <td>&gt;&gt;=</td> <td>[]</td> <td>()</td></tr> <tr><td>-&gt;</td> <td>-&gt;*</td> <td>new</td> <td>new[]</td> <td>delete</td> <td>delete[]</td></tr> <tr><td>不能重载</td> <td></td> <td></td> <td></td> <td></td> <td></td></tr> <tr><td>::</td> <td>.*</td> <td>.</td> <td>?:</td> <td></td> <td></td></tr></tbody></table></li> <li><p>重载运算符可定义为成员或非成员函数，通常</p> <ul><li>赋值（=）、下标（[]）、调用( () )和成员访问（-&gt;）运算符必须是成员</li> <li>符合赋值运算符一般应该是成员，但非必须</li> <li>改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用等通常应该是成员函数</li> <li>具有对称性的运算符可以转换任意一端的运算对象，如算术、相等性、关系和位运算等，通常应该是普通非成员函数</li></ul></li> <li><p>有时希望能在含有混合类型的表达式中使用对称性运算符，如求int和double的和，因为它们任意一个都可以是左侧或右侧运算对象，所以加法是对称的，此时运算符必须定义为非成员函数</p></li> <li><p>运算符定义为成员函数时，左侧运算对象必须是运算符所属类的一个对象</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>string s <span class="token operator">=</span> <span class="token string">&quot;world&quot;</span><span class="token punctuation">;</span>
string t <span class="token operator">=</span> s <span class="token operator">+</span> <span class="token string">&quot;!&quot;</span><span class="token punctuation">;</span><span class="token comment">//正确，吧const char*加到一个string中</span>
string u <span class="token operator">=</span> <span class="token string">&quot;hi&quot;</span> <span class="token operator">+</span> s<span class="token punctuation">;</span><span class="token comment">//若 + 运算符为string的成员，则产生错误</span>
</code></pre></div></li> <li><p><code>operator+</code>若是string成员，则第一个加法等价于<code>s.operator+(&quot;!&quot;)</code>，第二个类似的，就是<code>&quot;hi&quot;.operator+(s)</code>，后者<code>&quot;hi&quot;</code>为const char*，这是内置类型，根本没有成员函数</p></li> <li><p>string将+定义为普通非成员函数，所以<code>&quot;hi&quot;+s</code>等价于<code>operator+(&quot;hi&quot;,s)</code>，和其他函数调用一样，每个实参都能转换为形参类型，两个都能转为string，因此不会出错</p></li></ul> <h2 id="_2023-09-16"><a href="#_2023-09-16" class="header-anchor">#</a> 2023/09/16</h2> <ul><li><p>输入/输出运算符重载</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">MyType</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    MyType <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span>MyType <span class="token operator">&amp;</span>other<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token operator">-&gt;</span>i <span class="token operator">+=</span> other<span class="token punctuation">.</span>i<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">friend</span> ostream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> MyType <span class="token operator">&amp;</span>mt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token generic-function"><span class="token function">os</span> <span class="token generic class-name"><span class="token operator">&lt;&lt;</span> mt<span class="token punctuation">.</span>i<span class="token punctuation">;</span>
        <span class="token keyword">return</span> os<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">friend</span> istream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">&gt;&gt;</span></span></span><span class="token punctuation">(</span>istream <span class="token operator">&amp;</span>is<span class="token punctuation">,</span> MyType <span class="token operator">&amp;</span>mt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        is <span class="token operator">&gt;&gt;</span> mt<span class="token punctuation">.</span>i<span class="token punctuation">;</span>
        <span class="token keyword">return</span> is<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>上述代码需要注意一下几点：</p> <ul><li>输入输出运算符的重载必须不应该是成员函数，如果是成员函数则可能会出现以下比较奇怪的操作</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code>MyType mt<span class="token punctuation">;</span>
mt<span class="token operator">&lt;&lt;</span>cout<span class="token punctuation">;</span> <span class="token comment">//operator&lt;&lt;是MyType的成员时，需要这样调用（this为左侧运算对象），不符合 cout&lt;&lt;mt 这种语法习惯</span>
</code></pre></div><ul><li>使用<code>friend</code>友元声明，就不是类成员函数，但是可以方便地访问私有字段，因此比较合适</li></ul></li> <li><p>算术运算符和关系运算符应该被定义为非成员函数以允许对左侧或右侧的运算对象进行调换。通常这些函数都不需要改变对象状态，因此一般形参为const</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">MyType</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">friend</span> MyType <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyType<span class="token operator">&amp;</span>m1<span class="token punctuation">,</span><span class="token keyword">const</span> MyType<span class="token operator">&amp;</span>m2<span class="token punctuation">)</span><span class="token punctuation">{</span>
        MyType result<span class="token punctuation">;</span>
        result<span class="token punctuation">.</span>i <span class="token operator">=</span> m1<span class="token punctuation">.</span>i <span class="token operator">+</span> m2<span class="token punctuation">.</span>i<span class="token punctuation">;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>递增和递减运算符有前置和后置两个版本，定义时应该同时定义这两个版本</p></li> <li><p>前置递增/递减运算符</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">MyType</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    MyType <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token operator">++</span>i<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    MyType <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token operator">--</span>i<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>为了区分前置和后置运算符，后置版本额外接受一个int型参数（不被使用）</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">MyType</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    MyType <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        MyType old <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
        <span class="token operator">++</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> old<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    MyType <span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        MyType old <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
        <span class="token operator">--</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> old<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>后置运算符一般调用前置运算符来完成工作，只是会在运算前保存一份副本用于返回</p></li></ul> <h2 id="_2023-09-17"><a href="#_2023-09-17" class="header-anchor">#</a> 2023/09/17</h2> <ul><li><p>在迭代器和只能指针类中常用到解引用运算符<code>*</code>和箭头运算符<code>-&gt;</code></p></li> <li><p>与多数运算符一样，可以令<code>operator*</code>完成任何我们指定的操作；但对于箭头运算符，其永远不能丢掉成员访问这个最基本的含义，当重载箭头时，可以改变的时箭头从哪个对象中获取成员，而箭头获取成员这一事实永远不变</p></li> <li><p>对于形如<code>point-&gt;mem</code>的表达式，<code>point</code>必须是指向类对象的指针或是一个重载了<code>operator-&gt;</code>的类对象</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token punctuation">(</span><span class="token operator">*</span>point<span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>   <span class="token comment">//point是内置指针类型</span>
point<span class="token punctuation">.</span><span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>mem  <span class="token comment">//point是类的一个对象</span>
</code></pre></div></li> <li><p>若重载了函数调用运算符，则可以像使用函数一样使用该类的对象，因为这样的类同时也能存储状态，所以比普通函数更灵活</p></li> <li><p>类定义调用运算符时，该类的对象称为函数对象</p></li> <li><p>lambda是函数对象，编译器会将其翻译一个未命名类的未命名对象。在lambda产生的类中含有一个重载的函数调用运算符</p></li> <li><p>标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。如<code>plus</code>类定义了一个函数调用运算符用于对一对运算对象执行 + 操作；<code>modulus</code>类定义了一个调用运算符执行二元的 <code>%</code>  操作，<code>equal_to</code>类似<code>==</code>等...</p></li> <li><p>标准库函数对象</p> <table><thead><tr><th>算术</th> <th>关系</th> <th>逻辑</th></tr></thead> <tbody><tr><td>plus&lt;Type&gt;</td> <td>equal_to&lt;Type&gt;</td> <td>logical_and&lt;Type&gt;</td></tr> <tr><td>minus&lt;Type&gt;</td> <td>not_equal_to&lt;Type&gt;</td> <td>logical_or&lt;Type&gt;</td></tr> <tr><td>multiplies&lt;Type&gt;</td> <td>greater&lt;Type&gt;</td> <td>logical_not&lt;Type&gt;</td></tr> <tr><td>divides&lt;Type&gt;</td> <td>greater_equal&lt;Type&gt;</td> <td></td></tr> <tr><td>modulus&lt;Type&gt;</td> <td>less&lt;Type&gt;</td> <td></td></tr> <tr><td>negate&lt;Type&gt;</td> <td>less_equal&lt;Type&gt;</td> <td></td></tr></tbody></table></li> <li><p>可在算法中使用标准库函数对象</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//传入一个临时函数对象用于执行两个string对象的 &gt; 比骄傲运算</span>
<span class="token function">sort</span><span class="token punctuation">(</span>svec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>svec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token generic-function"><span class="token function">greater</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>标准库规定其函数对象对于指针同样使用，比较两个指针将产生未定义行为，但我们可能希望通过比较指针的内存地址来sort指针的vector，直接这么做将产生未定义行为，因此可以使用标准库函数对象来实现此目的</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span>string <span class="token operator">*</span><span class="token operator">&gt;</span> strVec<span class="token punctuation">;</span>
    <span class="token comment">//错误，指针彼此间没有关系，比较符号将产生未定义行为</span>
    <span class="token function">sort</span><span class="token punctuation">(</span>strVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> strVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>string <span class="token operator">*</span>a<span class="token punctuation">,</span> string <span class="token operator">*</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> a <span class="token operator">&lt;</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//正确，标准库规定指针的less是定义良好的</span>
    <span class="token function">sort</span><span class="token punctuation">(</span>strVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> strVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">less</span><span class="token generic class-name"><span class="token operator">&lt;</span>string <span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>关联容器使用<code>less&lt;key_type&gt;</code>对元素进行排序，因此可以定义一个指针的set或在map中使用指针作为关键值而无须直接声明less</p></li> <li><p>可调用对象也有类型，不同类型的调用对象可能共享同一种调用签名（call signature），调用签名指明了调用返回的类型以及传递给调用的实参类型。一种调用形式对应一个函数类型。如</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span>
</code></pre></div><p>表示一个函数类型，接收两个int，返回一个int</p></li> <li><p><code>function</code>定义在<code>functional</code>头文件中，定义了以下操作</p> <table><thead><tr><th>操作</th> <th>描述</th></tr></thead> <tbody><tr><td>function&lt;T&gt; f;</td> <td>f是一个用来存储可调用对象的空function，这些可调用对象的调用形式应该与函数类型T相同</td></tr> <tr><td>function&lt;T&gt; f(nullptr);</td> <td>显示构造一个空function</td></tr> <tr><td>function&lt;T&gt; f(obj);</td> <td>在f中存储可调用对象obj的副本</td></tr> <tr><td>f</td> <td>将f作为条件：dangf含有一个可调用对象时为真；否则为假</td></tr> <tr><td>f(args)</td> <td>调用f中的对象，参数为args</td></tr> <tr><td>function&lt;T&gt;的成员类型</td> <td></td></tr> <tr><td>result_type</td> <td>function类型的可调用对象返回的类型</td></tr> <tr><td>argument_type</td> <td>当T有一个或两个实参时定义的类型，如果T只有一个实参，则argument_type时该类型的同义词；若有两个实参，则通过first、second区分</td></tr> <tr><td>first_argument_type</td> <td></td></tr> <tr><td>second_argument_type</td> <td></td></tr></tbody></table></li> <li><p>在尖括号中指定function类型</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> f1 <span class="token operator">=</span> add<span class="token punctuation">;</span><span class="token comment">//函数指针</span>
function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> f2 <span class="token operator">=</span> <span class="token function">divide</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//函数对象类的对象</span>
function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> f3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> i<span class="token operator">*</span>j<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//lambda</span>
</code></pre></div></li> <li><p>当函数有重载版本时，可存函数的指针而非函数名字来解决二义性，或使用lambda表达式进行封装</p></li> <li><p>通过定义类型转换运算符能定义对于类类型的类型转换，转换构造函数和类型转换运算符共同定义了类类型转换，这样的转换也被称为用户定义的类型转换</p></li> <li><p>类型转换运算符是类的特殊成员函数，负责将一个类型的值住转换为其他类型。一般形式为</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">operator</span> <span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>其中<code>type</code>表示某种类型，类型转换运算符可以面向任意类型（除void）进行定义。不允许转换为数组或函数类型，但能转换为指针或引用类型</p></li> <li><p>类型转换函数必须是类的成员函数，不能声明返回类型，形参列表也必须为空</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">SmallInt</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">//允许从int转换</span>
    <span class="token function">SmallInt</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">&gt;</span> <span class="token number">255</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> std<span class="token double-colon punctuation">::</span><span class="token function">out_of_range</span><span class="token punctuation">(</span><span class="token string">&quot;bad SmallInt value&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//也允许转换成int</span>
    <span class="token keyword">explicit</span>。 <span class="token keyword">operator</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> val<span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>size_t val<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>与显式构造函数一样，类型转换运算符应该定义为<code>explicit</code>的，来避免隐式转换可能带来错误</p></li> <li><p>cout、cin等对象之所以能作为if条件判断，是因为其重载了bool类型转换符</p></li> <li><p>下述特殊情况下，显式类型转换将被隐式进行</p> <ul><li>if、while、do语句的条件部分</li> <li>for语句头的条件表达式</li> <li>逻辑非（！）、逻辑或（||）、逻辑与（&amp;&amp;）的运算对象</li> <li>条件运算符（?:）的条件表达式</li></ul></li></ul> <h2 id="_2023-09-19"><a href="#_2023-09-19" class="header-anchor">#</a> 2023/09/19</h2> <ul><li><p>C++中，使用基类的引用（或指针）调用一个虚函数时将发生动态绑定（多态）</p></li> <li><p>基类通常应该定义一个虚析构函数，即使该函数不执行任何实际操作</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Quote</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Quote</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>若基类把某个函数声明为虚函数，则该函数在派生类中隐式地也是虚函数</p></li> <li><p>若成员函数没有被声明为虚函数，则其解析过程发生在编译时而非运行时</p></li> <li><p>派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。派生类可以访问公有成员和保护成员，而不能访问私有成员</p></li> <li><p>派生类使用派生列表明确指出它是从哪些类继承而来，每个基类前可以有<code>public/protected/private</code>修饰符之一</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">BaseA</span><span class="token punctuation">{</span>
    
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">BaseB</span><span class="token punctuation">{</span>
    
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">C</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">BaseA</span><span class="token punctuation">,</span><span class="token keyword">protected</span> <span class="token class-name">BaseB</span></span><span class="token punctuation">{</span>
    
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>若基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。通过基类或派生类都能访问到（非private静态成员）</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">BaseA</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">afunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">BaseB</span><span class="token punctuation">{</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">C</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">BaseA</span><span class="token punctuation">,</span><span class="token keyword">protected</span> <span class="token class-name">BaseB</span></span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">cfunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">BaseA</span><span class="token double-colon punctuation">::</span><span class="token function">afunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">C</span><span class="token double-colon punctuation">::</span><span class="token function">afunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>派生类的声明与其他类差别不大，声明中包含类名但不包含派生列表</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">DerivedA</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">BaseA</span></span><span class="token punctuation">;</span><span class="token comment">//错误，单独声明不能带派生列表</span>
<span class="token keyword">class</span> <span class="token class-name">DerivedA</span><span class="token punctuation">;</span><span class="token comment">//正确</span>
</code></pre></div></li> <li><p>作为基类的类必须要先定义，不能单是声明</p></li> <li><p>C++11的<code>final</code>关键字可以用于标明某个类不可继承</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//final表明不可被继承</span>
<span class="token keyword">class</span> <span class="token class-name">BaseA</span> <span class="token keyword">final</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">afunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//错误，不能继承</span>
<span class="token keyword">class</span> <span class="token class-name">C</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">BaseA</span></span><span class="token punctuation">{</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>可以使用<code>override</code>关键字指明派生类中重写的基类函数</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">BaseA</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">C</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">BaseA</span></span><span class="token punctuation">{</span>
    <span class="token comment">//void前可以加virtual也可以不加</span>
    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">{</span>
        
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>某些时候不希望对虚函数的调用进行动态绑定，而是强迫其执行某个虚函数版本，此时可使用作用域运算符实现。通常只有成员函数或友元中的代码才需要使用作用域运算符来回避虚函数机制</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">double</span> d <span class="token operator">=</span> baseP<span class="token operator">-&gt;</span><span class="token class-name">Quote</span><span class="token double-colon punctuation">::</span><span class="token function">net_price</span><span class="token punctuation">(</span><span class="token number">33</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>纯虚函数无须定义，通过在函数体位置加上<code>=0</code>可将一个虚函数声明为纯虚函数</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">BaseA</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>含有纯虚函数的类是抽象基类，抽象基类负责定义接口。抽象基类不能用于创建对象</p></li> <li><p>派生类的构造函数应该只初始化其直接基类</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">BaseA</span> <span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    <span class="token keyword">int</span> b<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">BaseA</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">a</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">b</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">BaseB</span> <span class="token operator">:</span><span class="token base-clause"><span class="token class-name">BaseA</span></span><span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> bb<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">BaseB</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">,</span><span class="token keyword">int</span> bb<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">BaseA</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">bb</span><span class="token punctuation">(</span>bb<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">BaseB</span></span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Derived</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">,</span><span class="token keyword">int</span> bb<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">BaseB</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>bb<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li></ul> <h2 id="_2023-09-21"><a href="#_2023-09-21" class="header-anchor">#</a> 2023/09/21</h2> <ul><li><p>派生类的成员或友元只能通过派生类对象来访问基类的受保护成员，派生类对于一个基类对象中受保护成员没有任何访问特权</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token keyword">int</span> protect_mem<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">friend</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>Derived <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">friend</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>Base <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>Derived <span class="token operator">&amp;</span>d<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//可以通过派生类对象访问protected成员</span>
    cout <span class="token operator">&lt;&lt;</span> d<span class="token punctuation">.</span>protect_mem <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>Base <span class="token operator">&amp;</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//错误，不能通过非派生类对象直接访问基类protected成员</span>
    <span class="token comment">//如果允许这种操作，那么就可以定义一个新类来绕过protected</span>
    <span class="token comment">//这是不允许的</span>
    cout <span class="token operator">&lt;&lt;</span> b<span class="token punctuation">.</span>protect_mem <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p><code>public/protected/private</code>继承不会影响到派生类成员对于基类的访问（只与基类成员的访问修饰符有关），但会影响到派生类对象对从基类继承下来的成员的访问</p></li> <li><p>类似友元关系不能传递，友元关系同样也不能继承。当一个类将另一个类声明为友元时，这种友元关系只对做出声明的类有效</p></li> <li><p>可通过<code>using</code>声明改变派生类继承的某个名字的访问级别</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token keyword">int</span> protect_mem<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">memfunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span>  protect_mem<span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">private</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">//私有继承时memfunc是私有的，使用using可特殊将其变为public</span>
    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>memfunc<span class="token punctuation">;</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>protect_mem<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>对于<code>class</code>，默认采用私有继承；对于<code>struct</code>，默认采用公有继承</p></li> <li><p>派生类中定义与基类同名的成员时，基类的成员将会被隐藏</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token keyword">int</span> mem<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">memfunc</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span>  i<span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token keyword">int</span> mem<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">memfunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> mem<span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Derived d<span class="token punctuation">;</span>
    d<span class="token punctuation">.</span><span class="token function">memfunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//正确</span>
    d<span class="token punctuation">.</span><span class="token function">memfunc</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//错误，因为编译器的名称查找优先于类型检查，因此基类的memfunc会在派生类作用域中隐藏掉，不能调用</span>
    d<span class="token punctuation">.</span><span class="token class-name">Base</span><span class="token double-colon punctuation">::</span><span class="token function">memfunc</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//正确</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>和其他函数一样，成员函数无论是否是虚函数都能被重载，派生类可以覆盖重载函数的0个或多个实例。若派生类希望所有的重载版本对于它都是可见的，那就必须要覆盖所有的版本，或者一个也不覆盖</p> <blockquote><p>重载函数名称都一样，按照名称查找优先于类型检查规则，若只重载部分，就会把基类中的其他重载版本隐藏掉</p></blockquote></li> <li><p>若派生类只希望重载部分函数，而又想其他基类的重载版本对其可见，则可使用<code>using</code>声明，此时只需要声明函数名即可，无需带参数列表。如<code>using Base::func</code></p></li></ul> <h2 id="_2023-10-7"><a href="#_2023-10-7" class="header-anchor">#</a> 2023/10/7</h2> <ul><li><p>继承关系中，通过在基类中将析构函数定义为虚函数来确保执行正确类型的析构函数版本</p></li> <li><p>若一个类定义了析构函数，即使它通过<code>=default</code>的形式使用了合成版本，编译器也不会为这个类合成移动操作</p></li> <li><p>当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象</p></li> <li><p>当为派生类定义拷贝或移动构造函数时，通常使用对应的基类构造函数初始化对象的基类部分</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{</span>
  <span class="token comment">/**/</span>  
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">D</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span><span class="token punctuation">{</span>
    <span class="token comment">//委托基类的拷贝构造完成基类部分拷贝</span>
    <span class="token function">D</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token operator">&amp;</span>D d<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">Base</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//这里完成派生类成员的拷贝</span>
    <span class="token punctuation">}</span>  
    <span class="token comment">//委托基类的移动构造完成基类部分的移动</span>
    <span class="token function">D</span><span class="token punctuation">(</span>D<span class="token operator">&amp;&amp;</span>d<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">Base</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//完成派生类的移动</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>类似地，派生类的赋值运算符也必须显式地为基类部分赋值</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//Base::operator=(const Base&amp;) 不会被自动调用</span>
D <span class="token operator">&amp;</span>D<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> D<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">{</span>
    Base<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//...</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>与构造函数和赋值运算符不同，派生类的析构函数只负责销毁由派生类自己分配的资源。对象销毁和创建顺序相反，派生类的析构函数会先执行</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">D</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">//Base::~Base()会被自动调用</span>
    <span class="token operator">~</span><span class="token function">D</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//....</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>派生类可以继承直接基类的构造函数，方式是提供一条基类名的<code>using</code>声明，如</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">D</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>Base<span class="token punctuation">;</span><span class="token comment">//继承Base的构造函数</span>
    <span class="token keyword">double</span> <span class="token function">dd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>通常<code>using</code>声明语句只令某个名字在当前作用域可见，而当作用于构造函数时，<code>using</code>声明语句将令编译器产生代码，对于基类每个构造函数，编译器都生成一个与之对应的派生类构造函数。（形参列表相同、派生类自己的成员会被默认初始化，会自动调用基类构造函数初始化基类部分）</p></li> <li><p>和普通成员的<code>using</code>声明不一样，构造函数的<code>using</code>声明不会改变该构造函数的访问级别</p></li> <li><p>基类构造函数有默认实参时，这些实参不会被继承，而是得到多个继承的构造函数，每个构造函数分别省略掉一个含有默认实参的形参</p></li> <li><p>默认、拷贝和移动构造函数不会被继承</p></li> <li><p>使用容器存放继承体系中的对象时，通常必须采用间接存储的方式。即在容器中存放继承体系对象时，通常存放的是基类的指针</p></li></ul> <h2 id="_2023-10-08"><a href="#_2023-10-08" class="header-anchor">#</a> 2023/10/08</h2> <ul><li><p>对于比较函数，可定义函数模板</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span>v1<span class="token punctuation">,</span> <span class="token keyword">const</span> T <span class="token operator">&amp;</span>v2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>v1 <span class="token operator">&lt;</span> v2<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>v2 <span class="token operator">&lt;</span> v1<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>模板定义以关键字<code>template</code>开始，后跟模板参数列表（都好分割的多个模板参数），使用<code>&lt;&gt;</code>包裹</p></li> <li><p>类型模板参数前必须使用<code>class</code>或<code>typename</code>关键字修饰，在模板参数中这两个关键字含义相同，可以互换使用</p></li> <li><p>除了定义类型模板参数，还可以定义非类型模板参数，非类型模板参数表示一个值而非一个类型，可通过特定的类型名而非关键字<code>class/typename</code>指定非类型参数</p></li> <li><p>当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断的值代替，这些值必须是常量表达式，从而在编译时确定</p></li> <li><p>如处理字符串的compare版本，希望比较不同长度的数组，可以使用非类型参数来传递数组长度</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">unsigned</span> N<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> M<span class="token operator">&gt;</span>
<span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>p1<span class="token punctuation">)</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>当使用<code>compare(&quot;hi&quot;,&quot;hello&quot;)</code>这种形式时，编译器会用字面量的长度来代替N和M，从而实例化模板</p></li> <li><p>非类型参数可以是一个整型，后者一个指向对象或函数类型的指针或左值引用。绑定到非类型整型参数的实参必须是一个常量表达式；绑定到指针或引用非类型参数的实参必须具有静态的生存期；不能使用一个普通（非static）局部变量或动态对象作为指针或引用非类型模板参数的实参，指针参数也可以用<code>nullptr</code>或一个值为0的常量表达式实例化</p></li> <li><p>模板定义中，非类型参数是一个常量值，需要常量表达式的地方都可以使用</p></li> <li><p>函数模板可以声明为<code>inline</code>或<code>constexpr</code>的，将说明符放到模板参数列表后，返回类型前</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//正确</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">inline</span> T <span class="token function">min</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span><span class="token punctuation">,</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//错误</span>
<span class="token keyword">inline</span> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> T <span class="token function">min</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span><span class="token punctuation">,</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>编译器遇到模板定义时并不会生成代码，只有当实例化模板的一个特定版本时编译器才会生成代码</p></li> <li><p>为生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义，因此，与非模板代码不同，模板的头文件通常既包含声明也包含定义。即函数模板和类模板成员函数的定义通常放在头文件中</p></li> <li><p>类模板是用于生成类的蓝图，与函数模板不同，编译器不能为类模板推断模板参数类型</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Blob</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">typedef</span> T value_type<span class="token punctuation">;</span>
    <span class="token comment">//这里通过typename来指出std::vector&lt;T&gt;::size_type是类型而不是变量</span>
    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>size_type size_type<span class="token punctuation">;</span>

    <span class="token function">Blob</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">Blob</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>initializer_list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> il<span class="token punctuation">)</span><span class="token punctuation">;</span>

    size_type <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> data<span class="token operator">-&gt;</span>size<span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> data<span class="token operator">-&gt;</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span> data<span class="token operator">-&gt;</span><span class="token function">push_back</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token comment">//...</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;&gt;</span> data<span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token function">check</span><span class="token punctuation">(</span>size_type i<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//在类外定义类模板成员函数时，需要加上template关键字，且要指定该函数是哪个类作用域下（这里是Blob&lt;T&gt;）</span>
<span class="token comment">//构造函数</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token class-name">Blob</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">Blob</span><span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> il<span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
<span class="token comment">//成员函数</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token class-name">Blob</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">check</span><span class="token punctuation">(</span>Blob<span class="token double-colon punctuation">::</span>size_type i<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>默认情况下，一个实例化了的类模板，其成员只有在使用时才被实例化</p></li> <li><p>一个类包含一个友元声明时，类与友元各自是否是模板相互无关。若一个类模板包含一个非模板友元，则该友元被授权可访问所有模板实例；若友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例</p></li> <li><p>模板类型别名</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//正确</span>
<span class="token keyword">typedef</span> Blob<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> StrBlob<span class="token punctuation">;</span>
<span class="token comment">//错误</span>
<span class="token keyword">typedef</span> Blob<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> TBlob<span class="token punctuation">;</span>

<span class="token comment">//新标准允许为类模板定义类型别名</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">using</span> twin <span class="token operator">=</span> pair<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> T<span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>类模板可以定义静态成员，每个类模板的实例都各自有一个静态成员，相同类型的实例共享一个静态成员</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">static</span> T static_mem<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> T Foo<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>static_mem <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>

<span class="token comment">//共用一个Foo&lt;string&gt;::static_mem;</span>
Foo<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> f1<span class="token punctuation">,</span>f2<span class="token punctuation">;</span>
<span class="token comment">//公用一个Foo&lt;int&gt;::static_mem</span>
Foo<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> f3<span class="token punctuation">,</span>f4<span class="token punctuation">;</span>
<span class="token comment">//不能直接通过 Foo::static_mem访问静态成员</span>
</code></pre></div></li> <li><p>模板相关的声明（函数、变量）必须要包含模板参数</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> T <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>一个特定文件所需要的所有模板声明通常一起放置在文件的开始位置，出现于任何使用这些模板的代码之前</p></li> <li><p>默认情况下C++假定通过作用域运算符访问的名字不是类型，因此如果希望使用一个模板类型参数的类型成员，就必须使用<code>typename</code>显式指明这是类型而不是变量</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token double-colon punctuation">::</span>value_type <span class="token function">top</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> c<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>c<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> <span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token double-colon punctuation">::</span><span class="token function">value_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>允许为函数和类模板提供默认模板实参</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">F</span> <span class="token operator">=</span> less<span class="token operator">&lt;</span>T<span class="token operator">&gt;&gt;</span>
<span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span>v1<span class="token punctuation">,</span> <span class="token keyword">const</span> T <span class="token operator">&amp;</span>v2<span class="token punctuation">,</span> F f <span class="token operator">=</span> <span class="token function">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>v1<span class="token punctuation">,</span> v2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>v2<span class="token punctuation">,</span> v1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="_2023-10-09"><a href="#_2023-10-09" class="header-anchor">#</a> 2023/10/09</h2> <ul><li><p>不管是普通类还是类模板，都可以包含本身是模板的成员函数，这种成员称为成员模板，成员模板不能是虚函数</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">DebugDelete</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">DebugDelete</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span>s <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>cerr<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">os</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>T <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
        os <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;deleting unique_ptr&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
        <span class="token keyword">delete</span> p<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>可使用上述类代替<code>delete</code></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">double</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">double</span><span class="token punctuation">;</span>
    DebugDelete d<span class="token punctuation">;</span>
    <span class="token function">d</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用DebugDelete::operator()(double*)</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>ip <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>
    <span class="token function">DebugDelete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//临时对象上调用operator()(int*)</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>在类模板中，也可以定义成员模板，此情况下类和成员各自有各自的独立模板参数</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Blob</span><span class="token punctuation">{</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">It</span><span class="token operator">&gt;</span><span class="token function">Blob</span><span class="token punctuation">(</span>It b<span class="token punctuation">,</span>It e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>与类模板普通函数成员不同，成员模板是函数模板，在类外定义一个成员模板时，必须同时为类模板和成员模板提供模板参数列表，类模板参数在前，成员模板参数在后</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token comment">//类模板参数列表</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">It</span><span class="token operator">&gt;</span><span class="token comment">//成员模板参数列表</span>
<span class="token class-name">Blob</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">Blob</span><span class="token punctuation">(</span>It b<span class="token punctuation">,</span> It e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//...</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>当模板被使用时才会进行实例化，这一特性意味着相同的实例可能出现在多个对象文件中，当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中就都会有该模板的一个实例</p></li> <li><p>在大系统中，在多个文件中实例化相同模板的额外开销可能非常大，在新标准中，可通过显式实例化来避免这种开销。显式实例化的形式如下</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">extern</span> <span class="token keyword">template</span> declaration<span class="token punctuation">;</span><span class="token comment">//实例化声明</span>
<span class="token keyword">template</span> declaration<span class="token punctuation">;</span><span class="token comment">//实例化定义</span>
</code></pre></div></li> <li><p><code>declaration</code>是一个类或函数声明，其中所有模板参数已被替换为模板实参，如</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">extern</span> <span class="token keyword">template</span> <span class="token keyword">class</span> <span class="token class-name">Blob</span><span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword">template</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>当编译器遇到<code>extern</code>模板声明时，不会在本文件中生成实例代码。将一个实例化声明为<code>extern</code>就表示承诺在程序在程序其他位置有该实例化的一个非<code>extern</code>声明（定义）</p></li> <li><p>因为编译器在使用一个模板时自动对其实例化，因此<code>extern</code>声明必须出现在任何使用此实例版本的代码前</p></li> <li><p>在类模板的显式实例化定义中，所用类型必须能用于模板的所有成员函数</p></li> <li><p>效率与灵活性的选择：</p> <ul><li><code>shared_ptr</code>在运行时绑定删除器，使得用户重载删除器更为方便，但析构执行delete时需要跳转到别处执行代码，有额外开销</li> <li><code>unique_ptr</code>在编译时绑定删除器，避免了间接调用删除器的运行时开销，删除器编译时可确定，可能还能被编译为内联的</li></ul></li></ul> <h2 id="_2023-10-10"><a href="#_2023-10-10" class="header-anchor">#</a> 2023/10/10</h2> <ul><li><p>像函数模板一样，从函数实参来确定模板实参的过程被称为模板实参推断</p></li> <li><p>模板函数中通常只存在两种类型的转换</p> <ul><li>const转换：可将一个非const对象的引用（或指针）传递给一个const的引用（或指针）形参</li> <li>数组或函数指针转换：若函数形参<strong>不是</strong>引用类型，则数组实参可转换为一个指向其首元素的指针；函数实参可以转换为该函数类型的指针</li></ul></li> <li><p>其他类型的转换，如算术、派生类向基类的转换、用户自定义的转换都不能应用于函数模板</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> T <span class="token function">fobj</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> T <span class="token function">fref</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span><span class="token punctuation">,</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span>b<span class="token punctuation">[</span><span class="token number">18</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">//正确，两个数组都被转为指针类型，调用fobj(int*,int*)</span>
    <span class="token function">fobj</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//错误，a、b大小不一样，不是同类型，因为是引用所以不会自动转为指针</span>
    <span class="token function">fref</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>函数模板可以指定显式的实参类型，如</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T2</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T3</span><span class="token operator">&gt;</span>
T1 <span class="token function">sum</span><span class="token punctuation">(</span>T2<span class="token punctuation">,</span> T3<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>上述函数模板没有任何参数可用于推断T1，因此需要显式指定，指定方法也是在<code>&lt;&gt;</code>中指明类型</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">auto</span> r <span class="token operator">=</span> <span class="token generic-function"><span class="token function">sum</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>lng<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//long long sum(int,long)</span>
</code></pre></div></li> <li><p>只有最右边的显式模板参数才可以忽略，而且前提是都能从函数推断，如果sum为</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T2</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T3</span><span class="token operator">&gt;</span>
T3 <span class="token function">sum2</span><span class="token punctuation">(</span>T2<span class="token punctuation">,</span> T1<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>此时总是需要为所有三个形参指定实参</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">auto</span> r <span class="token operator">=</span> <span class="token generic-function"><span class="token function">sum2</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>lng<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//错误，不能推断前几个模板参数</span>
<span class="token keyword">auto</span> r <span class="token operator">=</span> <span class="token generic-function"><span class="token function">sum2</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">long</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>lng<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//正确</span>
</code></pre></div></li> <li><p>有时并不知道返回结果的准确类型，但知道所需类型是所处理的序列的元素类型</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">It</span><span class="token operator">&gt;</span>
<span class="token operator">?</span><span class="token operator">?</span><span class="token operator">?</span> <span class="token operator">&amp;</span><span class="token function">fn</span><span class="token punctuation">(</span>It beg<span class="token punctuation">,</span>It end<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//处理序列</span>
    <span class="token keyword">return</span> <span class="token operator">*</span>beg<span class="token punctuation">;</span><span class="token comment">//返回序列中一个元素的引用</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> vi <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Blob<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> ca <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;hi&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">auto</span> <span class="token operator">&amp;</span>i <span class="token operator">=</span> <span class="token function">fcn</span><span class="token punctuation">(</span>vi<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>vi<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//fcn应该返回int&amp;</span>
<span class="token keyword">auto</span> <span class="token operator">&amp;</span>s <span class="token operator">=</span> <span class="token function">fcn</span><span class="token punctuation">(</span>ca<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>ca<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//fcn应该返回string&amp;</span>
</code></pre></div></li> <li><p>上述代码中可确定函数应该返回<code>*begin</code>，且可使用<code>decltype(*beg)</code>来获取此表达式的类型，但编译器遇到函数的参数列表前，<code>beg</code>都是不存在的，为了定义此函数，必须使用尾置返回类型</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">auto</span> <span class="token function">fcn</span><span class="token punctuation">(</span>It beg<span class="token punctuation">,</span>It end<span class="token punctuation">)</span><span class="token operator">-&gt;</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token operator">*</span>beg<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//处理序列</span>
    <span class="token keyword">return</span> <span class="token operator">*</span>beg<span class="token punctuation">;</span><span class="token comment">//返回序列中一个元素的引用</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>迭代器总是返回元素的引用，如果要获得具体元素类型，即让上述函数返回元素的拷贝而非引用，则需要使用标准库的类型转换模板，这些模板定义在<code>type_traits</code>头文件中</p></li> <li><p>如上述例子可以使用<code>remove_reference</code>来获取元素类型，其拥有一个模板类型参数和一个名为<code>type</code>的成员，若用引用初始化它，则<code>type</code>将表示被引用的类型，如<code>remove_reference&lt;int&amp;&gt;</code>的<code>type</code>为<code>int</code></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">auto</span> <span class="token function">fcn</span><span class="token punctuation">(</span>It beg<span class="token punctuation">,</span>It end<span class="token punctuation">)</span><span class="token operator">-&gt;</span> <span class="token keyword">typename</span> <span class="token class-name">remove_reference</span><span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token operator">*</span>beg<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token punctuation">{</span>
    <span class="token comment">//..</span>
    <span class="token keyword">return</span> <span class="token operator">*</span>beg<span class="token punctuation">;</span><span class="token comment">//返回元素的拷贝</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>标准库类型转换模板表</p> <table><thead><tr><th>对Mod&lt;T&gt;，Mod可取值</th> <th>若T为</th> <th>则Mod&lt;T&gt;::type为</th></tr></thead> <tbody><tr><td>remove_reference</td> <td>X&amp;或X&amp;&amp;<br>否则</td> <td>X<br>T</td></tr> <tr><td>add_const</td> <td>X&amp;、const X或函数<br>否则</td> <td>T<br>const T</td></tr> <tr><td>add_lvalue_reference</td> <td>X&amp;<br>X&amp;&amp;<br>否则</td> <td>T<br>X&amp;<br>T&amp;</td></tr> <tr><td>add_rvalue_reference</td> <td>X&amp;或X&amp;&amp;<br>否则</td> <td>T<br>T&amp;&amp;</td></tr> <tr><td>remove_pointer</td> <td>X*<br>否则</td> <td>X<br>T*</td></tr> <tr><td>add_pointer</td> <td>X&amp;或X&amp;&amp;<br>否则</td> <td>X*<br>T*</td></tr> <tr><td>make_signed</td> <td>unsigned X<br>否则</td> <td>X<br>T</td></tr> <tr><td>make_unsigned</td> <td>带符号类型<br>否则</td> <td>unsigned X<br>T</td></tr> <tr><td>remove_extent</td> <td>X[n]<br>否则</td> <td>X<br>T</td></tr> <tr><td>remove_all_extends</td> <td>X[n1][n2]...<br>否则</td> <td>X<br>T</td></tr></tbody></table></li> <li><p>若一个函数参数是指向模板参数类型的右值引用（如T&amp;&amp;），则可传递给它任意类型的实参。如果将一个左值传递给这样的参数，则函数参数被实例化为一个普通的左值引用（T&amp;）</p></li> <li><p>若间接创建（不能直接定义引用的引用，但可以间接通过类型别名和模板类型参数可以创建）一个引用的引用，则这些引用形成<strong>折叠</strong>。在所有情况下，引用会折叠成一个普通的左值引用类型，只有一种特殊情况会折叠成右值引用，即右值引用的右值引用会被折叠成右值引用</p> <ul><li><code>X&amp; &amp;、X&amp; &amp;&amp;和X&amp;&amp; &amp;</code>都折叠成<code>X&amp;</code></li> <li><code>X&amp;&amp; &amp;&amp;</code>被折叠成<code>X&amp;&amp;</code></li></ul></li> <li><p>理解<code>std::move</code></p> <ul><li>标准库中<code>std::move</code>的定义</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">typename</span> <span class="token class-name">remove_reference</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;&amp;</span> <span class="token function">move</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">remove_reference</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;&amp;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>其参数<code>T&amp;&amp;</code>是一个指向模板类型的参数的右值引用，通过引用折叠，此参数可以与任何类型的实参匹配，既可以传递一个左值，又可以传递一个右值</li> <li>一个左值static_cast为右值是允许的</li></ul></li> <li><p>某些函数需要将其一个或多个实参连同类型不变地转发给其他函数，在此情况下，我们需要保持被转发实参的所有性质，包括实参类型是否是const的以及实参是左值还是右值</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//接受一个可调用对象和两个参数，将参数逆序传递给可调用对象</span>
<span class="token comment">//flip是一个不完整的实现，顶层const和引用丢失了</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">F</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T2</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">flip</span><span class="token punctuation">(</span>F f<span class="token punctuation">,</span> T1 t1<span class="token punctuation">,</span> T2 t2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">f</span><span class="token punctuation">(</span>t2<span class="token punctuation">,</span> t1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>此函数在一般情况下工作没问题，担当我们希望用它调用一个接受引用参数的函数时就会出现问题</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//v2是引用</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> v1<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>v2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> v1 <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">++</span>v2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>上述函数f改变了参数v2的值，但如果通过flip调用f，f所做的改变就不会影响到v2实参</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//f改变了i</span>
<span class="token function">flip</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span>j<span class="token punctuation">,</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//通过flip不会改变j</span>
</code></pre></div></li> <li><p>问题是j被传递给flip的参数t1，此参数是一个普通的、非引用的类型int，而非int&amp;，因此，flip的调用会实例化为</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">flip</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span>fcn<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">int</span> t1<span class="token punctuation">,</span><span class="token keyword">int</span> t2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>为了通过flip传递一个引用，需要重写函数，使其参数能保持给定实参的左值性质，更进一步，某些情况下也希望保持参数的const属性</p></li> <li><p>通过将一个函数参数定义为一个指向模板类型参数的右值引用，我们可以保持其对应的实参的所有类型信息。而使用引用参数（无论左值还是右值）使得我们可以保持const属性，因为在引用类型中的const是底层的。若将函数参数定义为<code>T1&amp;&amp;</code>和<code>T2&amp;&amp;</code>，通过<strong>引用折叠</strong>就可以保持反转实参的左值/右值属性</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">F</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T2</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">flip</span><span class="token punctuation">(</span>F f<span class="token punctuation">,</span> T1<span class="token operator">&amp;&amp;</span> t1<span class="token punctuation">,</span> T2<span class="token operator">&amp;&amp;</span> t2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">f</span><span class="token punctuation">(</span>t2<span class="token punctuation">,</span> t1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>上述版本的flip解决了一半的问题，它对于接受一个左值引用的函数可以正常工作，但不能用于接受右值引用参数的函数</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>i<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span> <span class="token operator">&lt;&lt;</span> j <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>若试图通过上述版本的flip调用g，则参数t2将被传递给g的右值引用参数</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token function">flip</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span>i<span class="token punctuation">,</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//错误，不能从一个左值实例化int&amp;&amp;</span>
</code></pre></div></li> <li><p>传递给g的将是flip中的t2参数，<strong>函数参数</strong>和其他任何变量一样，<strong>都是左值表达式</strong>，因此，flip中对g的调用将传递给g的右值引用参数一个左值</p></li> <li><p>我们可以使用一个名为<code>forward</code>的新标准库设施来传递flip的参数，它能保持原始参数的类型，类似move，<code>forward</code>定义在<code>utility</code>头文件中。<code>forward</code>必须通过显式模板实参来调用，返回该显式实参类型的右值引用，即<code>forward&lt;T&gt;</code>返回的类型为<code>T&amp;&amp;</code></p></li> <li><p>通常使用<code>forward</code>传递哪些定义为模板类型参数的右值引用的函数参数，通过其返回类型上的引用折叠，<code>forward</code>可以保持给定实参的左值/右值属性</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Type</span><span class="token operator">&gt;</span> R <span class="token function">intermediary</span><span class="token punctuation">(</span>Type<span class="token operator">&amp;&amp;</span>arg<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token function">finalFcn</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>Type<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>当用于一个指向模板参数类型的右值引用函数参数（T&amp;&amp;）时，forward会保持实参类型的所有细节</p></li> <li><p>使用forward重写的flip版本：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">F</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T2</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">flip</span><span class="token punctuation">(</span>F f<span class="token punctuation">,</span> T1 <span class="token operator">&amp;&amp;</span>t1<span class="token punctuation">,</span> T2 <span class="token operator">&amp;&amp;</span>t2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T2<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>t2<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T1<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>类似std::move，对std::forward不使用using声明比较好，带上命名空间能保证调用正确版本的forward</p></blockquote></li></ul> <h2 id="_2023-10-16"><a href="#_2023-10-16" class="header-anchor">#</a> 2023/10/16</h2> <ul><li><p>当有多个重载模板对一个调用提供同样好的匹配时，应选择最特例化的版本</p></li> <li><p>对一个调用，若非模板函数与一个函数模板提供同样好的匹配，则选择非模板版本</p></li> <li><p>可变参数模板就是接受一个可变数目参数的模板函数或模板类，可变数目的参数被称为参数包，存在两种参数包</p> <ul><li>模板参数包，表示零个或多个模板参数</li> <li>函数参数包，表示零个或多个函数参数</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> t<span class="token punctuation">,</span><span class="token keyword">const</span> Args<span class="token operator">&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> rest<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>可使用<code>sizeof...</code>运算符计算有多少个参数</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">g</span><span class="token punctuation">(</span>Args <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span><span class="token punctuation">{</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>Args<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment">//类型参数数目</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment">//函数参数数目</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>可变参数函数通常是递归的</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
ostream <span class="token operator">&amp;</span><span class="token function">print</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword">const</span> T <span class="token operator">&amp;</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> os <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">;</span><span class="token comment">//最后一个元素不打印分隔符</span>
<span class="token punctuation">}</span>
<span class="token comment">//上一个可变参数模板必须在这个函数的作用域中，不然可能会无限递归</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">&gt;</span>
ostream <span class="token operator">&amp;</span><span class="token function">print</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword">const</span> T <span class="token operator">&amp;</span>t<span class="token punctuation">,</span> <span class="token keyword">const</span> Args <span class="token operator">&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>rest<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    os <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;, &quot;</span><span class="token punctuation">;</span>
    <span class="token comment">//递归调用，打印其他实参</span>
    <span class="token keyword">return</span> <span class="token function">print</span><span class="token punctuation">(</span>os<span class="token punctuation">,</span> rest<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//rest...这种语法称为包扩展或包展开（expand）</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>C++还支持更复杂的扩展模式</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>string <span class="token function">debug_rep</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">&quot;'&quot;</span> <span class="token operator">+</span> s <span class="token operator">+</span> <span class="token string">&quot;'&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">&gt;</span>
ostream <span class="token operator">&amp;</span><span class="token function">errMsg</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword">const</span> Args <span class="token operator">&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>rest<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//将对rest中每个元素调用debug_rep。不能写成debug_rep(rest...)</span>
    <span class="token comment">//这种称为扩展的模式</span>
    <span class="token keyword">return</span> <span class="token function">print</span><span class="token punctuation">(</span>os<span class="token punctuation">,</span> <span class="token function">debug_rep</span><span class="token punctuation">(</span>rest<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div></li> <li><p>新标准下，可以组合使用可变参数模板与<code>forward</code>机制来编写函数，实现将其实参不变地传递给其他函数</p></li> <li><p>可变参数函数通常将它们的参数转发给其他函数，这种函数通常具有以下形式</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>Args <span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//将Args扩展为一个右值引用列表</span>
    <span class="token comment">//work实参既扩展Args又扩展args</span>
    <span class="token function">work</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>Args<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>模板的特例化就是模板的一个独立定义，因为某些时候定义好的模板并非对所有实参都能实例化</p></li> <li><p>特例化一个函数模板时，必须为原模板中每个模板参数都提供实参，为了指明我们在实例化一个模板，需要使用<code>template&lt;&gt;</code>标识</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span>
<span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> <span class="token operator">&amp;</span>p1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> <span class="token operator">&amp;</span>p2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>一个特例化版本本质上是一个模板实例，而非函数名的一个重载版本</p></li> <li><p>类模板也能特例化，如可将标准库hash模板定义一个特例化版本，可以用它来将自己的类型保存在无序容器中。默认情况下，无序容器使用<code>hash&lt;key_type&gt;</code>来组织其元素，为了让自己的类也能使用这种方式，必须定义hash模板的一个特例化版本。其中，必须定义：</p> <ul><li>一个重载的调用运算符，接受一个容器关键字类型的对象，返回一个size_t</li> <li>两个类型成员，<code>result_type</code>和<code>argument_type</code>，分别调用运算符的返回类型和参数类型</li> <li>默认构造函数和拷贝赋值运算符</li></ul></li> <li><p>特例化hash版本必须在原模板定义的命名空间中特例化</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">MyType</span> <span class="token punctuation">{</span>
    <span class="token comment">//声明为友元，以便访问私有成员</span>
    <span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">std</span><span class="token operator">:</span><span class="token base-clause"><span class="token operator">:</span><span class="token class-name">hash</span><span class="token operator">&lt;</span><span class="token class-name">MyType</span><span class="token operator">&gt;</span></span><span class="token punctuation">;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    string y<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">namespace</span> std <span class="token punctuation">{</span><span class="token comment">//打开命名空间</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span>
    <span class="token keyword">struct</span> <span class="token class-name">hash</span><span class="token operator">&lt;</span>MyType<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">//必须定义的类型</span>
        <span class="token keyword">typedef</span> size_t result_type<span class="token punctuation">;</span>
        <span class="token keyword">typedef</span> MyType argument_type<span class="token punctuation">;</span>
        <span class="token comment">//提供一个hash函数。通常还要提供 == 运算符</span>
        size_t <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyType <span class="token operator">&amp;</span>m<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    size_t <span class="token class-name">hash</span><span class="token operator">&lt;</span>MyType<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyType <span class="token operator">&amp;</span>m<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">hash</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token generic-function"><span class="token function">hash</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token comment">//结束命名空间</span>
</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//会使用hash&lt;MyType&gt;和 == 运算符</span>
unordered_multiset<span class="token operator">&lt;</span>MyType<span class="token operator">&gt;</span> myset<span class="token punctuation">;</span>
</code></pre></div></li> <li><p>类模板可部分特例化</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">remove_reference</span> <span class="token punctuation">{</span>
    <span class="token keyword">typedef</span> T type<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">remove_reference</span><span class="token operator">&lt;</span>T <span class="token operator">&amp;</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token comment">//特例化，左值引用</span>
    <span class="token keyword">typedef</span> T type<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">remove_reference</span><span class="token operator">&lt;</span>T <span class="token operator">&amp;&amp;</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token comment">//特例化，右值引用</span>
    <span class="token keyword">typedef</span> T type<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>类成员也可以单独特例化</p></li></ul> <h2 id="_2023-10-21"><a href="#_2023-10-21" class="header-anchor">#</a> 2023/10/21</h2> <ul><li><p><code>tuple</code>是标准库中类似<code>pair</code>的模板，不同<code>tuple</code>类型的成员类型不同，一个<code>tuple</code>可以有任意数量的成员</p></li> <li><p><code>tuple</code>通常用于我们想将一些数据组合成单个对象，但又不想麻烦地定义一个新数据结构来表示这些数据的场景</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;tuple&gt;</span></span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>tuple<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">t</span><span class="token punctuation">(</span><span class="token string">&quot;ok&quot;</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//使用模板函数 get 来获取指定成员</span>
    std<span class="token double-colon punctuation">::</span>string s <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span>s<span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>不知道元素和数量时，可通过<code>tuple_element</code>和<code>tuple_size</code>两个模板函数辅助</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>tuple<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">t</span><span class="token punctuation">(</span><span class="token string">&quot;ok&quot;</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>string s <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    <span class="token keyword">typedef</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> tp_type<span class="token punctuation">;</span>
    <span class="token comment">//获取指定tuple的元素个数</span>
    size_t tp_size <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>tuple_size<span class="token operator">&lt;</span>tp_type<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">;</span>
    <span class="token comment">//second_type_val的类型和 t 中第二个成员相同</span>
    std<span class="token double-colon punctuation">::</span>tuple_element<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">,</span> tp_type<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type second_type_val <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p><code>tuple</code>的一个常见用途是从一个函数返回多个值</p></li> <li><p>标准库定义了<code>bitset</code>类，使得位运算使用更容易，并能处理超过最长整型类型大小的位集合</p></li> <li><p><code>bitset</code>类是一个类模板，类似<code>array</code>，具有固定的大小</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>bitset<span class="token operator">&lt;</span><span class="token number">32</span><span class="token operator">&gt;</span> <span class="token function">bitvec</span><span class="token punctuation">(</span><span class="token number">1U</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//32位，低位为1，其他位为0</span>
</code></pre></div></li> <li><p><code>bitset</code>通过下标访问位，0~n的顺序是从低位到高位</p></li> <li><p>初始化<code>bitset</code></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bitset&gt;</span></span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//bitvec1比初始化值小，高位将被丢弃</span>
    std<span class="token double-colon punctuation">::</span>bitset<span class="token operator">&lt;</span><span class="token number">13</span><span class="token operator">&gt;</span> <span class="token function">bitvec1</span><span class="token punctuation">(</span><span class="token number">0xbeef</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//bitvec2比初始化值大，高位被置为 0</span>
    std<span class="token double-colon punctuation">::</span>bitset<span class="token operator">&lt;</span><span class="token number">20</span><span class="token operator">&gt;</span> <span class="token function">bitvec2</span><span class="token punctuation">(</span><span class="token number">0xbeef</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//64位机器中 long long 0ULL是64个0 bit，因此~OULL是64个 1</span>
    std<span class="token double-colon punctuation">::</span>bitset<span class="token operator">&lt;</span><span class="token number">127</span><span class="token operator">&gt;</span> <span class="token function">bitvec3</span><span class="token punctuation">(</span><span class="token operator">~</span><span class="token number">0ULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//使用string初始化bitset</span>
    std<span class="token double-colon punctuation">::</span>bitset<span class="token operator">&lt;</span><span class="token number">32</span><span class="token operator">&gt;</span> <span class="token function">bitvec4</span><span class="token punctuation">(</span><span class="token string">&quot;01010&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>C++的正则表达式库（RE库）定义在头文件<code>regex</code>中，包含多个组件：</p> <ul><li><code>regex</code>：表示有一个正则表达式的类</li> <li><code>regex_match</code>：将一个字符序列与一个正则表达式匹配</li> <li><code>regex_search</code>：寻找第一个与正则表达式匹配的子序列</li> <li><code>regex_replace</code>：使用给定格式替换一个正则表达式</li> <li><code>sregex_iterator</code>：迭代器适配器，调用<code>regex_search</code>来遍历一个<code>string</code>中所有匹配的子串</li> <li><code>smatch</code>：容器类，保存在string中搜索的结果</li> <li><code>ssub_match</code>：string中匹配的子表达式结果</li></ul></li> <li><p>示例</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    string <span class="token function">pattern</span><span class="token punctuation">(</span><span class="token string">&quot;[^c]ei&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    pattern <span class="token operator">=</span> <span class="token string">&quot;[[:alpha:]]*&quot;</span><span class="token operator">+</span>pattern<span class="token operator">+</span><span class="token string">&quot;[[:alpha:]]*&quot;</span><span class="token punctuation">;</span>
    regex <span class="token function">r</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token punctuation">;</span>
    smatch results<span class="token punctuation">;</span>

    string test_str <span class="token operator">=</span> <span class="token string">&quot;receipt freind theif receive&quot;</span><span class="token punctuation">;</span>
    <span class="token comment">//调用search，将结果存放在results中</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">regex_search</span><span class="token punctuation">(</span>test_str<span class="token punctuation">,</span> results<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> results<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>定义regex对象时可以指定一些选项，如指定正则表达式所使用的语言，默认情况下<code>ECMAScript</code>被设置。使用<code>regex(re,f)</code>可通过 f 指定一些标志，定义在<code>regex</code>和<code>regex_constants::syntax_option_type</code>中</p> <ul><li><code>icase</code>：匹配时忽略大小写</li> <li><code>nosubs</code>：不保存匹配的子表达式</li> <li><code>optimize</code>：执行速度优先于构造速度</li> <li><code>ECMAScript</code>：使用<code>ECMA-262</code>指定语法</li> <li><code>basic</code>：使用POSIX基本的正则表达式语法</li> <li><code>extended</code>：使用POSIX扩展的正则表达式语法</li> <li><code>awk</code>：使用POSIX版本的<code>awk</code>语言语法</li> <li><code>grep</code>：使用POSIX版本的<code>grep</code>语法</li> <li><code>egrep</code>：使用POSIX版本的<code>egrep</code>语法</li></ul></li> <li><p>如指定忽略大小写：<code>regex r(pattern,regex::icase);</code></p></li> <li><p>定义在<code>random</code>中的随机数库通过一组协作的类来解决随机数相关的问题（如需要非均匀分布、指定范围随机数等），包括随机数引擎类和随机数分布类</p> <ul><li>引擎：类型，生产随机<code>unsigned</code>整型序列</li> <li>分布：类型，使用引擎返回服从特定概率分布的随机数</li></ul> <blockquote><p>C++程序不应该使用库函数rand，而应该使用default_random_engine类和恰当的分布类对象</p></blockquote></li> <li><p>随机数引擎是一个函数对象类，其定义了一个调用运算符号，该运算符不接受参数，返回一个随机unsigned整数</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    default_random_engine e<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//调用可调用对象e就会生成一个随机数</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token function">e</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//一些引擎相关的操作：</span>
Engine <span class="token function">e</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用整型值s作为种子</span>
e<span class="token punctuation">.</span><span class="token function">seed</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用种子 s 重置引擎状态</span>
e<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//引擎能生成的最大值和最小值</span>
e<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Engine<span class="token double-colon punctuation">::</span>result_type <span class="token comment">//引擎生产的unsigned类型</span>
e<span class="token punctuation">.</span><span class="token function">discard</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token comment">//将引擎推进 u 步，u的类型为unsigned long long</span>
</code></pre></div></li> <li><p>为了获得指定范围内的随机数，可使用一个分布类型的对象：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//生成0~9之间（包含）均匀分布的随机数</span>
    uniform_int_distribution<span class="token operator">&lt;</span><span class="token keyword">unsigned</span><span class="token operator">&gt;</span> <span class="token function">u</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    default_random_engine e<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//将u作为随机数源，每个调用返回指定范围内并服从均匀分布的值</span>
        <span class="token comment">//注意不是e(u)或者u(e())</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token function">u</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>可使用<code>uniform_real_distribution</code>类型对象来生成随机实数，让标准库处理随机整数到浮点数的映射</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//生成0~1之间的浮点数</span>
    uniform_real_distribution<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> <span class="token function">u</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    default_random_engine e<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//将u作为随机数源，每个调用返回指定范围内并服从均匀分布的值</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token function">u</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>除了均匀分布，还可以指定其他20多种分布，如正态分布</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//均值为4，标准差为1.5</span>
    <span class="token comment">//这种参数的正态分布得到的值99%在0~8之间</span>
    default_random_engine e<span class="token punctuation">;</span>
    normal_distribution<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> <span class="token function">u</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span><span class="token operator">&gt;</span> <span class="token function">vals</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token number">200</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//lround舍入到最近的整数</span>
        <span class="token keyword">unsigned</span> v <span class="token operator">=</span> <span class="token function">lround</span><span class="token punctuation">(</span><span class="token function">u</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">&lt;</span> vals<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token operator">++</span>vals<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">!=</span> vals<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> j <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;: &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token function">string</span><span class="token punctuation">(</span>vals<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token char">'*'</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="_2023-10-22"><a href="#_2023-10-22" class="header-anchor">#</a> 2023/10/22</h2> <ul><li><p>标准库定义了一组**操纵符（manipulator）**来修改流的格式状态，一个操纵符是一个函数或是一个对象，会影响流的状态，并能用作输入输出运算符的运算对象</p></li> <li><p>如<code>endl</code>操纵符，其不是一个普通值，而是一个操作，其输出一个换行符并刷新缓冲区</p></li> <li><p>当操纵符改变流格式状态时，这种改变通常会影响所有后续的IO</p></li> <li><p>除了条件状态，每个<code>iostream</code>对象还维护了一个格式状态来控制IO如何格式化的细节</p></li> <li><p>对于bool值，默认情况下打印为 0 或 1，<code>boolalpha</code>操纵符可用于改变这种行为，使得输出为true或false</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//输出 1 0</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token boolean">true</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token boolean">false</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token comment">//输出 true false</span>
    cout <span class="token operator">&lt;&lt;</span> boolalpha <span class="token operator">&lt;&lt;</span> <span class="token boolean">true</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;  &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token boolean">false</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>默认对整型数输出是十进制，可通过<code>hex/oct/dec</code>改为十六进制、八进制或十进制</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;hex: &quot;</span><span class="token operator">&lt;&lt;</span>hex<span class="token operator">&lt;&lt;</span><span class="token number">20</span><span class="token operator">&lt;&lt;</span><span class="token string">&quot; &quot;</span><span class="token operator">&lt;&lt;</span><span class="token number">1024</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
</code></pre></div></li> <li><p>若需要打印整型结果时显示该值使用的进制，可使用<code>showbase</code>操作符</p> <ul><li>前导<code>0x</code>表示十六进制</li> <li>前导<code>0</code>表示八进制</li> <li>无前导字符表示十进制</li></ul></li> <li><p>默认浮点数按 6 位数字精度打印，若浮点数值没有小数部分，则不打印小数点。</p></li> <li><p>可通过IO对象的<code>precision</code>成员或使用<code>setprecision</code>操作符来改变精度。指定精度得到的值是四舍五入的而不是直接截断</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//Precision: 6, Value: 1.41421</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Precision: &quot;</span> <span class="token operator">&lt;&lt;</span> cout<span class="token punctuation">.</span><span class="token function">precision</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
         <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;, Value: &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token comment">//设置进精度</span>
cout<span class="token punctuation">.</span><span class="token function">precision</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//Precision: 12, Value: 1.41421356237</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Precision: &quot;</span> <span class="token operator">&lt;&lt;</span> cout<span class="token punctuation">.</span><span class="token function">precision</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;, Value: &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

<span class="token comment">//设置精度</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token function">setprecision</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//Precision: 3, Value: 1.41</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Precision: &quot;</span> <span class="token operator">&lt;&lt;</span> cout<span class="token punctuation">.</span><span class="token function">precision</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;, Value: &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>


</code></pre></div></li> <li><p>当按列打印数据时，长需要控制数据格式</p> <ul><li><code>setw</code>指定下一个数字或字符串值的最小空间（注意，只影响下一个值）</li> <li><code>left</code>表示左对齐输出</li> <li><code>right</code>表示右对齐输出，右对齐是默认格式</li> <li><code>internal</code>控制负数的符号位置，其左对齐符号，右对齐值，用空格填满所有中间空间</li> <li><code>setfill</code>允许指定一个字符代替默认的空格来填充空白</li></ul></li> <li><p>默认输入运算符会忽略空白字符（空格、制表符、换行符、回车符等），操作符<code>noskipws</code>会令输入运算符读取空白符而不是跳过，使用<code>skipws</code>可恢复默认行为</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>cin<span class="token operator">&gt;&gt;</span>noskipws<span class="token punctuation">;</span><span class="token comment">//设置cin读取空白符</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>cin<span class="token operator">&gt;&gt;</span>ch<span class="token punctuation">)</span>
    cout<span class="token operator">&lt;&lt;</span>ch<span class="token punctuation">;</span>
cin<span class="token operator">&gt;&gt;</span>skipws<span class="token punctuation">;</span><span class="token comment">//重置cin为默认行为</span>
</code></pre></div></li> <li><p>标准库提供一组底层操作，支持未格式化IO，这些操作允许我们将一个流当作一个无解释的字节序列来处理</p></li> <li><p>下述操作每次读取一个字节地处理流，这些操作不会忽略空白</p> <table><thead><tr><th>操作</th> <th>描述</th></tr></thead> <tbody><tr><td>is.get(ch)</td> <td>从istream中读取下一个字节放入ch，返回is</td></tr> <tr><td>os.put(ch)</td> <td>将字符ch输出到ostream，返回os</td></tr> <tr><td>is.get()</td> <td>将is的下一个字节作为int返回</td></tr> <tr><td>is.putback(ch)</td> <td>将字符ch放回is，返回is</td></tr> <tr><td>is.unget()</td> <td>将is向后移动一个字节，返回is</td></tr> <tr><td>is.peek()</td> <td>将下一个字节作为int返回，但不从流中删除它</td></tr></tbody></table></li> <li><p>多字节底层IO操作</p> <table><thead><tr><th>操作</th> <th>描述</th></tr></thead> <tbody><tr><td>is.get(sink,size,delim)</td> <td>从is中读取至多size个字节并保留到字符数组中，字符数组起始地址由sink给出，读取过程直至遇到delim或读取了size个字节或遇到文件尾时停止。若遇到delim，则将其保留在流中，不读取出来放到sink中</td></tr> <tr><td>is.getline(sink,size,delim)</td> <td>类似上述get，但会读取并丢弃delim</td></tr> <tr><td>is.read(sink,size)</td> <td>读取之多size个字符，存入字符数组sink中，返回is</td></tr> <tr><td>is.gcount()</td> <td>返回上一个未格式化读取操作从is读取的字节数</td></tr> <tr><td>os.write(source,size)</td> <td>将字符数组source中的size个字节写入os，返回os</td></tr> <tr><td>is.ignore(size,delim)</td> <td>读取并忽略最多size个字符，包括delim，参数size默认值为 1 ，delim默认值为文件尾</td></tr></tbody></table></li> <li><p>为支持随机访问，IO类型维护了一个标记来确定下一个读写操作要在哪里进行。标注库定义了几对seek函数和tell函数，区别在于名称后缀，其中<code>g</code>为get，表示我们正在获取数据；<code>p</code>表示put，表示我们正在写入数据</p> <table><thead><tr><th>操作</th> <th>描述</th></tr></thead> <tbody><tr><td>tellg()</td> <td>返回一个输入流（g）中或输入流（p）中标记的当前位置</td></tr> <tr><td>tellp()</td> <td></td></tr> <tr><td>seekg(pos)</td> <td>在一个输入流（g）或输出流（p）中将标记重定位到给定的绝对地址，post通常是前一个tellg或tellp的值</td></tr> <tr><td>seekp(pos)</td> <td></td></tr> <tr><td>seekp(off,from)</td> <td>在一个输入流（g）或输出流（p）中将标记定位到from之前或之后offset个字符，from可取：<br>beg：偏移量相对于流的开始位置<br>cur：偏移量相对于流的当前位置<br>end：偏移量相对于流的结束位置</td></tr> <tr><td>seekg(off,from)</td> <td></td></tr></tbody></table></li></ul> <h2 id="_2023-10-26"><a href="#_2023-10-26" class="header-anchor">#</a> 2023/10/26</h2> <ul><li><p>一个异常如果没有被捕获，则它将终止当前的程序</p></li> <li><p>发生异常时析构函数总是会被执行，但函数中负责释放资源的代码可能被跳过。类对象分配的资源将由类的析构函数负责释放，因此若使用类来控制分配的资源，就能保证无论函数正常结束还是遭遇异常，资源都能被正确释放</p></li> <li><p>析构函数中不应该抛出不能被自己处理的异常，若要执行需要抛出异常的代码，也应该放在try语句块中自己处理</p></li> <li><p>异常对象（exception object）是一种特殊对象，编译器使用异常抛出表达式来对异常对象进行<strong>拷贝初始化</strong>，因此<code>throw</code>语句中的表达式必须拥有完全类型，且若该表达式是类类型，则相应的类必须含有一个可访问的析构函数和一个可访问的拷贝或移动构造函数；若该表达式时数组类型或函数类型，则表达式将被转换成与之对应的指针类型</p></li> <li><p>异常处理完毕后，异常对象会被销毁</p></li> <li><p>当抛出一条表达式时，该表达式的静态编译时类型决定了异常对象的类型，如果一条throw表达式解引用一个基类指针，而该指针实际指向派生类对象，则抛出的对象将被切掉一部分，只有基类部分被抛出</p></li> <li><p>抛出指向局部变量的指针是一种错误行为，因为异常会沿调用调用链传播，栈退出时局部变量将会被销毁</p></li> <li><p>当进入一个<code>catch</code>后，通过异常对象初始化异常声明中的参数，和函数参数类似，若catch的参数类型是非引用类型，则该参数是异常对象的一个副本；若是引用类型，则该参数是异常对象的一个别名，修改参数对异常对象有效</p></li> <li><p>若catch的参数是基类类型，则可使用派生类对象初始化，此时若是非引用，则对象被切掉一部分；若是引用，则会以常规方式绑定</p></li> <li><p>catch匹配规则</p> <ul><li>允许从非常量向常量的类型转换，非常量的throw可以匹配一个常量引用的catch</li> <li>允许从派生类向基类类型转化</li> <li>数组被转换为指向数组（元素）类型的指针，函数被转换为指向该函数类型的指针</li></ul></li> <li><p>当单独catch块语法完整处理某个异常时，可重新抛出异常给下一级处理，重新抛出无需表达式</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">throw</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>空<code>throw</code>只能出现在<code>catch</code>语句或<code>catch</code>语句直接或间接调用的函数之内。若在处理代码外的区域遇到了空throw，则编译器将调用<code>terminate</code></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">catch</span> <span class="token punctuation">(</span>my_error <span class="token operator">&amp;</span>obj<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//引用类型</span>
    obj<span class="token punctuation">.</span>status <span class="token operator">=</span> errCodes<span class="token double-colon punctuation">::</span>serverErr<span class="token punctuation">;</span><span class="token comment">//修改了异常对象</span>
    <span class="token keyword">throw</span><span class="token punctuation">;</span><span class="token comment">//异常对象的status成员是serverErr</span>
<span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span>other_error obj<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//非引用类型</span>
    obj<span class="token punctuation">.</span>status <span class="token operator">=</span> errCodes<span class="token double-colon punctuation">::</span>badErr<span class="token punctuation">;</span><span class="token comment">//只修改了异常对象的局部副本</span>
    <span class="token keyword">throw</span><span class="token punctuation">;</span><span class="token comment">//异常对象status成员没变</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>捕获所有异常时，使用<code>catch(...)</code>匹配。<code>catch(...)</code>和其他<code>catch</code>块一起出现时，必须放在最后</p></li> <li><p>构造函数在进入其函数体之前首先执行初始值列表，因为在初始值列表抛出异常时构造函数体内的<code>try</code>语句块还未生效，所以构造函数体内的catch块无法处理构造函数初始值列表抛出的异常</p></li> <li><p>想要处理构造函数初始值抛出的异常，必须将构造函数写成<strong>函数try语句块</strong>（也称为函数测试块）形式，函数try语句块使得一组catch既能处理构造函数体或析构函数体，也能处理构造函数初始化过程或析构函数析构过程</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">MyType</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">int</span> y<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">MyType</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token keyword">try</span><span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//构造函数体</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//catch处理</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>对于用户以及编译器而言，预先知道某个函数不会抛出异常很有用，知道函数不会抛出异常有助于简化调用该函数的代码；同时，如果编译器确认函数不会抛出异常，就能执行某些特殊的优化操作</p></li> <li><p>C++11中可通过<code>noexcept</code>说明某个函数不会抛出异常</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">recoup</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>一旦一个<code>noexcept</code>函数抛出了异常，程序就会调用<code>terminate</code>以确保遵守不在运行时抛出异常的承诺。因此<code>noexcept</code>可以用在两种情况下：</p> <ul><li>确认函数确实不会抛出异常</li> <li>我们不知道如何处理某异常</li></ul></li> <li><p>上述两种情况都中调用者都无需为异常负责</p></li> <li><p><code>noexcept</code>说明符的实参常常与<code>noexcept</code>运算符混合使用，<code>noexcept</code>运算符是一个一元运算符，返回值是一个<code>bool</code>类型的右值常量表达式，用于表示给定表达式是否会抛出异常</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token function">recoup</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>；<span class="token comment">//若recoupe不抛出异常则结果为true，否则为false</span>
</code></pre></div></li> <li><p>函数指针和该指针指向的函数必须由一致的异常说明</p></li> <li><p>虚函数承诺不会抛出异常，则派生类的虚函数也必须做出同样的承诺</p></li> <li><p>异常类层次</p> <p><img src="F:%5Cxiao's%5Cnotes%5Ccpp%5C1.png" alt="image-20231026224600569"></p></li> <li><p>类型<code>exception</code>仅定义了拷贝构造函数、拷贝赋值运算符、一个虚析构函数和一个名为<code>what</code>的虚成员，其中<code>what</code>函数返回一个<code>const char*</code>，该指针指向一个以null结尾的字符数组，并确保不会抛出异常</p></li></ul> <h2 id="_2023-10-29"><a href="#_2023-10-29" class="header-anchor">#</a> 2023/10/29</h2> <ul><li><p>命名空间为防止名字冲突提供了更加可控的机制，其分割了全局命名空间，其中每个命名空间是一个作用域</p></li> <li><p>出现在全局作用域的声明都可以放到命名空间中，包括类型、变量、函数、模板和其他命名空间</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">namespace</span> cplusplus_primer<span class="token punctuation">{</span>
    <span class="token keyword">class</span> <span class="token class-name">MyType</span> <span class="token punctuation">{</span><span class="token comment">/*...*/</span><span class="token punctuation">}</span>
    MyType <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyType<span class="token operator">&amp;</span><span class="token punctuation">,</span><span class="token keyword">const</span> MyType<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>命名空间既可以定义在全局作用域中，也可以定义在其他命名空间中（嵌套），但不能定义在函数或类中</p></li> <li><p>命名空间可以是不连续的，每次定义可能是新建命名空间或向已有命名空间中添加成员</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//若已有nsp，则表示打开命名空间nsp并向nsp中添加成员，</span>
<span class="token comment">//否则表示新建命名空间nsp</span>
<span class="token keyword">namespace</span> nsp<span class="token punctuation">{</span>
    <span class="token comment">//声明</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>通常<code>#include</code>不会放在命名空间中，放在命名空间中表示将<code>#include</code>的东西全部放到当前命名空间下</p></li> <li><p>模板特例化必须在原始模板所属命名空间中</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//hash是std中的，特例化必须在std中</span>
<span class="token keyword">namespace</span> std<span class="token punctuation">{</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">hash</span><span class="token operator">&lt;</span>MyType<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//在原始命名空间std中特例化后，可在其他命名空间中使用</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">std</span><span class="token operator">:</span><span class="token base-clause"><span class="token operator">:</span><span class="token class-name">hash</span><span class="token operator">&lt;</span><span class="token class-name">MyType</span><span class="token operator">&gt;</span></span><span class="token punctuation">{</span>
    size_t <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyType<span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">hash</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>全局作用域是隐式的，没有名字，下面的形式表示全局作用域的成员</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token double-colon punctuation">::</span>member_name
</code></pre></div></li> <li><p>C++11引入了<strong>内联命名空间</strong>，其中的名字可以被外层命名空间直接访问，无需添加前缀</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">inline</span> <span class="token keyword">namespace</span> insp<span class="token punctuation">{</span>
    <span class="token comment">//</span>
<span class="token punctuation">}</span>
<span class="token keyword">namespace</span> insp<span class="token punctuation">{</span><span class="token comment">//隐式内联</span>
    <span class="token comment">//...</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p><code>inline</code>必须出现在命名空间第一次定义的地方，后续再打开的时候可写<code>inline</code>可不写</p></li> <li><p>当应用程序的代码在一次发布和另一次发布之间发生了改变，常会用到内联命名空间</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">namespace</span> FourthEd<span class="token punctuation">{</span>
    <span class="token keyword">class</span> <span class="token class-name">Item_base</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">class</span> <span class="token class-name">Query_base</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span class="token keyword">inline</span> <span class="token keyword">namespace</span> FifthEd<span class="token punctuation">{</span>
    <span class="token keyword">class</span> <span class="token class-name">Item_base</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">class</span> <span class="token class-name">Query_base</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">namespace</span> cpp_primer<span class="token punctuation">{</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;FifthEd.h&quot;</span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;FourthEd.h&quot;</span></span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>上述情况下，FifthEd是内联的，因此<code>cpp_primer::</code>这种形式的代码就能直接访问到FifthEd中定义的成员，而若要访问之前的版本，就需要使用<code>cpp_primer::FourthEd::</code>这种形式</p></li> <li><p><code>namespace</code>关键字后紧跟花括号而没有名字的命名空间称为 未命名命名空间，未命名的命名空间中定义的变量拥有静态声明周期，即在第一次使用前创建，知道程序结束才销毁</p></li> <li><p>未命名命名空间在同一个文件中可以不是不连续的，但不能跨越多个文件</p></li> <li><p>可以使用未命名的命名空间代替<code>static</code>来声明单文件作用域变量</p></li> <li><p>命名空间可以指定别名</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">namespace</span> primer <span class="token operator">=</span> cpp_primer<span class="token punctuation">;</span>
</code></pre></div></li> <li><p>可以使用<code>using</code>一次引入一个命名空间的成员。<code>using</code>声明的作用域是从声明开始，到声明using所在作用域结束</p></li> <li><p><code>using</code>可以出现在全局作用域、局部作用域、名空间作用域和类作用域中。在类作用域中，这种声明语句只能指向基类成员</p></li> <li><p>当类声明了一个友元时，该声明并没有使得友元本身可见，当一个另外的未声明的类或函数第一次出现在友元声明中，则认为它是最近的外层命名空间的成员</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">namespace</span> A<span class="token punctuation">{</span>
    <span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">{</span>
        <span class="token comment">//两个友元，在友元之外没有其他声明，这些函数将隐式地成为A的成员</span>
        <span class="token keyword">friend</span> <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//除非另有声明，否则找不到</span>
        <span class="token keyword">friend</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> C<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//根据实参相关的查找规则可以被找到</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    A<span class="token double-colon punctuation">::</span>C cobj<span class="token punctuation">;</span>
    <span class="token function">f</span><span class="token punctuation">(</span>cobj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//正确，通过在A::C中的友元声明找到A::f</span>
    <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//错误，A::f2没有被声明。需要使用A::f2()</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>对于接受类类型实参的函数来说，其名字查找将在<strong>实参类所属命名空间</strong>（及其基类所属命名空间）中进行</p></li> <li><p><code>using</code>声明只能声明一个名字，而不能声明一个函数版本，因此一个<code>using</code>声明会引入同名的所有版本</p></li> <li><p>C++中通过<strong>虚继承</strong>机制来解决多继承情况下同一个祖先基类多次出现的问题，共享的基类子对象称为虚基类。这种机制下，无论虚基类在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Raccoon</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token class-name">ZooAnimal</span></span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Bear</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">ZooAninal</span></span><span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div></li> <li><p><code>virtual</code>指明的是一种愿景，即后续的派生类中共享虚基类的同一份实例，并不会影响到当前的派生类</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//Panda继承了Raccoon和Bear，因为这两个都是虚继承，因此Panda中只会有一份ZooAnimal基类部分</span>
<span class="token keyword">class</span> <span class="token class-name">Panda</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Bear</span><span class="token punctuation">,</span><span class="token keyword">public</span> <span class="token class-name">Raccoon</span><span class="token punctuation">,</span><span class="token keyword">public</span> <span class="token class-name">Endangered</span></span><span class="token punctuation">{</span>
    
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>多继承就跳过了....</p></li></ul> <h2 id="_2023-10-30"><a href="#_2023-10-30" class="header-anchor">#</a> 2023/10/30</h2> <ul><li><p>某些应用堆内存分配有特殊需求，常需要自己定义内存分配细节，比如使用关键字<code>new</code>将对象防止在特定的内存空间中。为了实现此目的，需要重载<code>new</code>和<code>delete</code>运算符</p></li> <li><p>当使用一条<code>new</code>表达式时</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//分配并初始化一个string对象</span>
string <span class="token operator">*</span>sp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">&quot;str&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//分配10个默认初始化的string对象</span>
string <span class="token operator">*</span>arr <span class="token operator">=</span> <span class="token keyword">new</span> string<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>上述过程实际执行了三步操作</p> <ul><li><code>new</code>表达式调用名为<code>operator new</code>（或<code>operator new[]</code>）的标准库函数，该函数分配一块足够大的、原始的、未命名的内存空间以便存储特定类型的对象（或数组）</li> <li>编译器运行相应的构造函数以构造这些对象，并传入初始值</li> <li>对象被分配了空间并构造完成，返回一个指向该对象的指针</li></ul></li> <li><p>当使用<code>delete</code>表达式删除一个动态分配的对象时</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//销毁*sp，然后释放sp指向的内存空间</span>
<span class="token keyword">delete</span> sp<span class="token punctuation">;</span>
<span class="token comment">//销毁数组中的元素，然后释放对应的内存空间</span>
<span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">;</span>
</code></pre></div></li> <li><p>上述过程实际执行了两步操作</p> <ul><li>对sp所指向对象或arr所指向数组中的元素执行对应的析构函数</li> <li>编译器调用名为<code>operator delete</code>（或<code>operator delete[]</code>）的标准库函数释放内存空间</li></ul></li> <li><p>若应用程序需要控制内存分配过程，则需要自定义自己的<code>operator new</code>和<code>operator delete</code>函数</p></li> <li><p>应用程序可在全局作用域中定义<code>operator new</code>函数和<code>operator delete</code>函数，也可以将它们定义为成员函数。当编译器发现一条<code>new</code>或<code>delete</code>表达式后，将在程序中查找可供调用的<code>operator</code>函数，若分配的对象是类类型，则编译器首先在类及其基类的作用域中查找，此时如果该类含有<code>operator new</code>或<code>operator delete</code>成员，则相应的表达式将调用这些成员，否则，编译器在全局作用域查找匹配函数，若找到用户自定义的版本，则使用该版本，没找到则使用标准库定义的版本</p></li> <li><p>可使用作用域运算符令<code>new</code>或<code>delete</code>表达式忽略定义在类中的函数，直接执行全局作用域中的版本，如<code>::new</code>旨在全局作用域中查找</p></li> <li><p>标准库定义了<code>operator new</code>和<code>operator delete</code>函数的8个重载版本，前4个可能抛出<code>bad_alloc</code>异常，后4个版本则不会抛出异常</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token operator">*</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//分配一个对象</span>
<span class="token keyword">void</span> <span class="token operator">*</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>size_t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//分配一个数组</span>
<span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token keyword">noexcept</span><span class="token punctuation">;</span><span class="token comment">//释放一个对象</span>
<span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token keyword">noexcept</span><span class="token punctuation">;</span><span class="token comment">//释放一个数组</span>
</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token operator">*</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t<span class="token punctuation">,</span>nothrow_t<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token keyword">noexcept</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token operator">*</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>size_t<span class="token punctuation">,</span>nothrow_t<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token keyword">noexcept</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">,</span>nothrow_t<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token keyword">noexcept</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">,</span>nothrow_t<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token keyword">noexcept</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>类型<code>nothrow_t</code>是定义在<code>new</code>头文件中的一个struct，此类型不包含任何成员。<code>new</code>头文件还定义一个名为<code>nothrow</code>的const对象，用户可以通过这个对象请求<code>new</code>的非抛出版本。类似析构函数，<code>operator delete</code>也不能抛出异常，重载时需要注意</p></li> <li><p><code>operator new</code>和<code>operator delete</code>定义在类中时隐式是静态的</p></li> <li><p>在C++的早期版本中，<code>allocator</code>类还不是标准库的一部分，要将内存分配和初始化分离开的的话需要调用<code>operator new</code>和<code>operator delete</code>，这两个函数的行为和<code>allocator</code>的<code>allocate</code>成员和<code>deallocate</code>成员十分类似，只负责分配或释放空间，而不管构造或销毁对象</p></li> <li><p>与<code>allocator</code>不同的是，对于<code>operator new</code>分配的内存空间，无法使用<code>construct</code>函数构造对象，相反，我们应该使用new的<strong>定位new</strong>（placement new）形式构造对象</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">new</span> <span class="token punctuation">(</span>place_address<span class="token punctuation">)</span> type
<span class="token keyword">new</span> <span class="token punctuation">(</span>place_address<span class="token punctuation">)</span> <span class="token function">type</span> <span class="token punctuation">(</span>initializers<span class="token punctuation">)</span>
<span class="token keyword">new</span> <span class="token punctuation">(</span>place_address<span class="token punctuation">)</span> type <span class="token punctuation">[</span>size<span class="token punctuation">]</span>
<span class="token keyword">new</span> <span class="token punctuation">(</span>place_address<span class="token punctuation">)</span> type <span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token punctuation">{</span>braced initializer list<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>其中，<code>place_address</code>必须是一个指针，同时在<code>initializers</code>中提供一个以逗号分割的初始值列表，该初始值列表用于构造新分配的对象</p></li> <li><p>当仅通过一个地址调用时，定位new使用<code>operator new(size_t,void*)</code>“分配”其内存，这个版本我们无法自定义。该函数不分配任何内存，只是简单地返回指针实参，然后由new表达式负责在指定的地址初始化对象以完成整个工作</p></li> <li><p>实际上，定位new允许我们在一个特定的、预先分配的内存地址上构造对象</p></li> <li><p>当只传入一个指针类型的实参时，定位new表达式构造对象但不分配内存</p></li> <li><p>大多数情况下，定位new和allocator的construct成员十分相似。一个重要的区别是，传给construct的指针必须指向同一个allocator对象分配的空间，但传递给定位new的指针无需指向operator new分配的内存</p></li> <li><p>传递个定位new表达式的指针甚至不需要指向动态内存</p></li> <li><p>对析构函数的显式调用也与使用destroy类似，既可以通过对象调用析构函数，也可以通过对象的指针或引用调用析构函数</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>string <span class="token operator">*</span>sp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">&quot;str&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
sp<span class="token operator">-&gt;</span><span class="token operator">~</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>和调用destroy类似，调用析构函数可以清除给定对象但不会释放该对象所在的空间</p></li> <li><p>重载示例</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token operator">*</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;use custom new&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>mem <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> mem<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> std<span class="token double-colon punctuation">::</span><span class="token function">bad_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;use custom delete&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>string <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token keyword">new</span> std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">&quot;str&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>s <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">delete</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>使用定位new的示例</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//只分配内存，不构建对象</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//在已分配的内存s处构建对象</span>
    std<span class="token double-colon punctuation">::</span>string <span class="token operator">*</span>ss <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">&quot;str&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>ss <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="_2023-10-31"><a href="#_2023-10-31" class="header-anchor">#</a> 2023/10/31</h2> <ul><li><p>运行时类型识别（run-time type identification，RTTI）的功能由两个运算符实现</p> <ul><li><code>typeid</code>运算符，用于返回表达式的类型</li> <li><code>dynamic_cast</code>运算符，用于将基类的指针或引用安全地转换为派生类的指针或引用</li></ul></li> <li><p>当将这两个运算符用于某种类型的指针或引用，并且该类型含有虚函数时，运算符将使用指针或引用所绑定对象的动态类型</p></li> <li><p>这两个运算符特别适用于：想使用基类对象的指针或引用执行某个派生类操作并且该操作不是虚函数</p></li> <li><p>与使用虚函数相比，RTTI运算符蕴含更多潜在的风险，必须要清除地知道转换的模板类型并且必须检查类型转换是否被成功执行</p></li> <li><p><code>dynamic_cast</code>运算符的使用形式：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>type<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
<span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>type<span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
<span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>type<span class="token operator">&amp;&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
</code></pre></div></li> <li><p>其中<code>type</code>必须是一个类类型，并且通常情况下该类型应该含有虚函数，在第一种形式中，e必须是一个有效的指针；在第二种形式中，e必须是一个左值；第三种形式中，e不能是左值</p></li> <li><p>上述所有形式中，e的类型必须符合三个条件中的任意一个</p> <ul><li>e的类型是目标type的公有派生类</li> <li>e的类型是目标type的公有基类</li> <li>或者e的类型就是目标type的类型</li></ul></li> <li><p>如果一条<code>dynamic_cast</code>语句的转换目标是指针类型并且失败了，则结果为 0 ，若转换目标是引用类型并且失败了，则<code>dynamic_cast</code>抛出一个<code>bad_cast</code></p></li> <li><p>若Base类至少有一个虚函数，Derived是Base的公有派生类，若有一个指向Base的指针bp，则可在运行时将它转换成指向Derived的指针</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">if</span><span class="token punctuation">(</span>Derived <span class="token operator">*</span>dp <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Derived<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//使用dp指向的Derived对象</span>
<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
    <span class="token comment">//使用bp指向的Base对象</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>若是引用，则</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> Base <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">try</span><span class="token punctuation">{</span>
        <span class="token keyword">const</span> Derived <span class="token operator">&amp;</span>d <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">const</span> Derived<span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//使用b引用Derived对象</span>
    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>bad_cast<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//处理转换失败的情况</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p><code>typeid</code>表达式的形式是<code>typeid(e)</code>，其中e可以是任意表达式或类型的名字，<code>typeid</code>操作的结果是一个常量对象的引用，该对象的类型是标准库类型<code>type_info</code>或<code>type_info</code>的公有派生类，定义在<code>typeinfo</code>头文件中</p></li> <li><p>若表达式是一个引用，则<code>typeid</code>返回该引用所引用对象的类型，当用于数组或函数时，并不会执行向指针的标准类型转换，即对数组a执行<code>typeid(a)</code>，得到的结果是数组类型而非指针类型</p></li> <li><p>当运算对象不属于类类型或者是一个不包含任何虚函数的类时，<code>typeid</code>运算符指示的是运算对象的静态类型，而当运算对象是定义了至少一个虚函数的类的左值时，<code>typeid</code>的结果知道运行时才会求得</p></li> <li><p>通常<code>typeid</code>用于比较两个表达式类型是否相同，或比较一条表达式类型是否与指定类型相同</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>Derived <span class="token operator">*</span>dp <span class="token operator">=</span> <span class="token keyword">new</span> Derived<span class="token punctuation">;</span>
Base <span class="token operator">*</span>bp <span class="token operator">=</span> dp<span class="token punctuation">;</span>

<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeid</span><span class="token punctuation">(</span><span class="token operator">*</span>bp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span><span class="token operator">*</span>dp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//同一类型对象</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeid</span><span class="token punctuation">(</span><span class="token operator">*</span>bp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>Derived<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//bp实际指向Derived对象</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>注意，<code>typeid</code>应该作用于对象，因此使用<code>*bp</code>而不是bp</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//bp类型是指向Base的指针（Base*），下述条件永远不成立</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeid</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>Derived<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p><code>typeid</code>只有当类型含有虚函数时编译器才会对表达式求值，若类型不含虚函数，则typeid返回表达式的静态类型</p></li> <li><p>RTTI的一种使用：需要定义判断两个对象是否相等的函数，此函数判断两个对象的类型然后再判断内容是否相等</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{</span>
    <span class="token keyword">friend</span> <span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> Base<span class="token operator">&amp;</span><span class="token punctuation">,</span><span class="token keyword">const</span> Base<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">//...</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">bool</span> <span class="token function">equal</span><span class="token punctuation">(</span><span class="token keyword">const</span> Base<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">//...</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token keyword">bool</span> <span class="token function">equal</span><span class="token punctuation">(</span><span class="token keyword">const</span> Base<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>类型敏感的相等运算符</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> Base<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span><span class="token keyword">const</span> Base<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//先判断类型，再调用equal</span>
    <span class="token keyword">return</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>lhs<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> lhs<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>继承体系中每个类必须定义自己的<code>equal</code>函数，派生类的所有函数要做的第一件事都是将实参的类型转换为派生类的类型</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">bool</span> <span class="token class-name">Derived</span><span class="token double-colon punctuation">::</span><span class="token function">equal</span><span class="token punctuation">(</span><span class="token keyword">const</span> Base <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">{</span>
    <span class="token keyword">auto</span> r <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">const</span> Derived<span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//执行比较两个Derived对象的操作并返回</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p><code>type_info</code>类的精确定义随着编译器的不同而略有差异，C++标准规定<code>type_info</code>必须定义在头文件<code>typeinfo</code>中，并且至少提供下列操作</p> <table><thead><tr><th>操作</th> <th>描述</th></tr></thead> <tbody><tr><td>t1 == t2</td> <td>type_info对象t1和t2表示同类型，则返回true，否则返回false</td></tr> <tr><td>t1 != t2</td> <td></td></tr> <tr><td>t.name()</td> <td>返回C风格字符串，表示类型名字的可打印形式，类型名字生成因系统而异</td></tr> <tr><td>t1.before(t2)</td> <td>返回bool值，表示t1是否位于t2前，before采用的顺序关系是依赖于编译器的</td></tr></tbody></table></li> <li><p><code>type_info</code>没有默认构造函数，且拷贝和移动构造函数都被定义为删除的。创建type_info的唯一途径是使用<code>typeid</code>运算符</p></li></ul> <h2 id="_2023-11-1"><a href="#_2023-11-1" class="header-anchor">#</a> 2023/11/1</h2> <ul><li><p>C++包含两种枚举：限定作用域和不限定作用域的。C++11新标准引入了限定作用域的枚举类型（Scoped enumeration）</p></li> <li><p>定义限定作用域的枚举类型形式为</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//enum class也可使用enum struct</span>
<span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">open_modes</span> <span class="token punctuation">{</span>input<span class="token punctuation">,</span>output<span class="token punctuation">,</span>append<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>定义不限定作用域的枚举类型时省略掉关键字class或struct，枚举类型的名字是可选的</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">enum</span> <span class="token class-name">color</span> <span class="token punctuation">{</span>red<span class="token punctuation">,</span>yellow<span class="token punctuation">,</span>green<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//未命名、不限定作用域的枚举类型</span>
<span class="token keyword">enum</span> <span class="token punctuation">{</span>floatPrec <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">,</span>doublePrec <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span>double_doublePrec <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>若enum是未命名的，则只能在定义该enum时定义它的对象</p></li> <li><p>在限定作用域的枚举类型中，枚举成员的名字遵循常规的作用域准则，并且在枚举类型的作用域外是不可访问的；而在不限定作用域的枚举中，枚举成员的作用域与枚举类型本身作用域相同</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">enum</span> <span class="token class-name">color</span> <span class="token punctuation">{</span>red<span class="token punctuation">,</span>yellow<span class="token punctuation">,</span>green<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//不限定作用域枚举</span>
<span class="token keyword">enum</span> <span class="token class-name">stoplight</span> <span class="token punctuation">{</span>red<span class="token punctuation">,</span>yellow<span class="token punctuation">,</span>green<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//错误，重复定了以枚举成员</span>
<span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">peppers</span> <span class="token punctuation">{</span>red<span class="token punctuation">,</span>yellow<span class="token punctuation">,</span>green<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//正确，枚举成员被隐藏</span>
color eyes <span class="token operator">=</span> green<span class="token punctuation">;</span><span class="token comment">//正确，不限定作用域枚举类型的枚举成员位于有效作用域中</span>
peppers p <span class="token operator">=</span> green<span class="token punctuation">;</span><span class="token comment">//错误，peppers枚举成员不再有效作用域中;color::green在有效作用域中但是类型不匹配</span>
color hair <span class="token operator">=</span> color<span class="token double-colon punctuation">::</span>red<span class="token punctuation">;</span><span class="token comment">//正确，允许显式地访问枚举成员</span>
peppers p2 <span class="token operator">=</span> peppers<span class="token double-colon punctuation">::</span>red<span class="token punctuation">;</span><span class="token comment">//正确</span>
</code></pre></div></li> <li><p>默认情况下枚举值从0开始依次+1，但也能指定专门的值</p> <div class="language-;c++ extra-class"><pre class="language-text"><code>enum class intTypes{
    charTyp = 8,shortTyp = 16,intTyp = 16
};
</code></pre></div></li> <li><p>若没有显式指定枚举值，则其值为前一个枚举值+1</p></li> <li><p>一个不限定作用域的枚举类型的对象或成员自动转换为整型</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> i <span class="token operator">=</span> color<span class="token double-colon punctuation">::</span>red<span class="token punctuation">;</span><span class="token comment">//正确</span>
<span class="token keyword">int</span> j <span class="token operator">=</span> peppers<span class="token double-colon punctuation">::</span>red<span class="token punctuation">;</span><span class="token comment">//错误，限定作用域的枚举不会隐式转换</span>
</code></pre></div></li> <li><p>尽管每个enum都定义了唯一的类型，但实际上enum是由某种整数类型表示的。C++11中，可以在enum名字后加上冒号以及我们向在该enum中使用的类型</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">enum</span> <span class="token class-name">intValues</span><span class="token operator">:</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">{</span>
    charType <span class="token operator">=</span> <span class="token number">255</span><span class="token punctuation">,</span>long_longTyp <span class="token operator">=</span> <span class="token number">18446744073709551615ULL</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>C++11中可以提前声明enum，enum的前置声明必须指定成员大小</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">enum</span> <span class="token class-name">intValues</span><span class="token operator">:</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">;</span><span class="token comment">//不限定作用域必须指定成员类型</span>
<span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">open_modes</span><span class="token punctuation">;</span><span class="token comment">//限定作用域的枚举可以使用默认成员类型int</span>
</code></pre></div></li> <li><p>要初始化一个enum对象，必须使用该enum类型的另一个对象或它的一个枚举成员</p> <hr></li> <li><p>成员指针是可以指向类的非静态成员的指针，其类型包括类的类型以及成员的类型。当初始化一个这样的指针时，我们令其指向类的某个成员，但是不指定该成员所属的对象，直到使用成员指针时才提供所属对象</p></li> <li><p>下文将使用下面的类型</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Screen</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">typedef</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>size_type pos<span class="token punctuation">;</span>

    <span class="token keyword">char</span> <span class="token function">get_cursor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> contents<span class="token punctuation">[</span>cursor<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">char</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>

    <span class="token keyword">char</span> <span class="token function">get</span><span class="token punctuation">(</span>pos ht<span class="token punctuation">,</span> pos wd<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>string contents<span class="token punctuation">;</span>
    pos cursor<span class="token punctuation">;</span>
    pos height<span class="token punctuation">,</span> width<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>和其他指针一样，成员指针也用<code>*</code>表示当前声明的名字是一个指针，成员指针需要包含成员所属类，在<code>*</code>之前添加<code>classname::</code>以表示当前定义的指针可以指向classname的成员</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//pdata可以指向一个常量Screen对象的string成员</span>
<span class="token keyword">const</span> string Screen<span class="token double-colon punctuation">::</span><span class="token operator">*</span>pdata<span class="token punctuation">;</span>
</code></pre></div></li> <li><p>初始化一个成员指针时需要指定它所属的成员</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//将取地址符 &amp; 用于Screen类的成员而非内存中的一个该类对象</span>
pdata <span class="token operator">=</span> <span class="token operator">&amp;</span>Screen<span class="token double-colon punctuation">::</span>contents<span class="token punctuation">;</span>
<span class="token comment">//C++11中可以直接用auto</span>
<span class="token keyword">auto</span> pdata <span class="token operator">=</span> <span class="token operator">&amp;</span>Screen<span class="token double-colon punctuation">::</span>contents<span class="token punctuation">;</span>
</code></pre></div></li> <li><p>成员指针只有在解引用时才提供对象的信息。与成员访问运算符<code>.</code>和<code>-&gt;</code>类似，成员指针访问运算符为<code>.*</code>和<code>-&gt;*</code></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>Screen myScreen<span class="token punctuation">,</span> <span class="token operator">*</span>pScreen <span class="token operator">=</span> <span class="token operator">&amp;</span>myScreen<span class="token punctuation">;</span>
<span class="token comment">//.*解引用获取myScreen对象的contents成员</span>
<span class="token keyword">auto</span> s <span class="token operator">=</span> myScreen<span class="token punctuation">.</span><span class="token operator">*</span>pdata<span class="token punctuation">;</span>
<span class="token comment">//-&gt;*解引用获取</span>
s <span class="token operator">=</span> pScreen<span class="token operator">-&gt;</span><span class="token operator">*</span>pdata<span class="token punctuation">;</span>
</code></pre></div></li> <li><p>常规访问控制对成员指针同样有效。因为数据成员通常是私有的，不能直获取数据成员的指针，若希望访问，最好定义一个函数令其返回值时指向该成员的指针</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Screen</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">static</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string Screen<span class="token double-colon punctuation">::</span><span class="token operator">*</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">&amp;</span>Screen<span class="token double-colon punctuation">::</span>contents<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>成员函数指针</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">auto</span> pmf <span class="token operator">=</span> <span class="token operator">&amp;</span>Screen<span class="token double-colon punctuation">::</span>get_cursor<span class="token punctuation">;</span>
</code></pre></div></li> <li><p>和普通函数指针一样，若成员存在重载问题，则必须显式地声明函数类型以明确想要哪个函数</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">char</span> <span class="token punctuation">(</span>Screen<span class="token double-colon punctuation">::</span><span class="token operator">*</span>pmf2<span class="token punctuation">)</span><span class="token punctuation">(</span>Screen<span class="token double-colon punctuation">::</span>pos<span class="token punctuation">,</span>Screen<span class="token double-colon punctuation">::</span>pos<span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">;</span>
pmf2 <span class="token operator">=</span> <span class="token operator">&amp;</span>Screen<span class="token double-colon punctuation">::</span>get<span class="token punctuation">;</span>
</code></pre></div></li> <li><p>和普通函数不同，成员函数和指向该函数的指针不存在自动转换规则</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>pmf <span class="token operator">=</span> <span class="token operator">&amp;</span>Screen<span class="token double-colon punctuation">::</span>get<span class="token punctuation">;</span><span class="token comment">//必须显式使用取地址运算符</span>
pmf <span class="token operator">=</span> Screen<span class="token double-colon punctuation">::</span>get<span class="token punctuation">;</span><span class="token comment">//错误</span>
</code></pre></div></li> <li><p>使用成员函数指针</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>Screen myScreen<span class="token punctuation">,</span> <span class="token operator">*</span>pScreen <span class="token operator">=</span> <span class="token operator">&amp;</span>myScreen<span class="token punctuation">;</span>

<span class="token comment">//调用运算符()优先级高于解引用，因此要加括号</span>
<span class="token keyword">char</span> c1 <span class="token operator">=</span> <span class="token punctuation">(</span>pScreen<span class="token operator">-&gt;</span><span class="token operator">*</span>pmf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> c2 <span class="token operator">=</span> <span class="token punctuation">(</span>myScreen<span class="token punctuation">.</span><span class="token operator">*</span>pmf2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>使用类型别名或<code>typedef</code>可以让成员指针更容易理解</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">using</span> Action <span class="token operator">=</span> <span class="token keyword">char</span> <span class="token punctuation">(</span>Screen<span class="token double-colon punctuation">::</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Screen<span class="token double-colon punctuation">::</span>pos<span class="token punctuation">,</span>Screen<span class="token double-colon punctuation">::</span>pos<span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>上述Action就可表示指向Screen类型的常量成员函数的指针，接收两个pos参数，返回一个char</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>Action get <span class="token operator">=</span> <span class="token operator">&amp;</span>Screen<span class="token double-colon punctuation">::</span>get<span class="token punctuation">;</span>
</code></pre></div></li> <li><p>要想通过一个指向成员函数的指针进行函数调用，必须首先使用<code>.*</code>或<code>-&gt;*</code>运算符将该指针绑定到特定对象上，因此与普通函数指针不同，成员指针不是一个可调用对象，这样的指针不支持函数调用运算符</p></li> <li><p>因为成员指针不是可调用对象，所以不能直接将一个指向成员函数的指针传递给算法</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">auto</span> fp <span class="token operator">=</span> <span class="token operator">&amp;</span>string<span class="token double-colon punctuation">::</span>empty<span class="token punctuation">;</span>
<span class="token comment">//错误，必须使用.*或-&gt;*调用成员指针</span>
<span class="token function">find_if</span><span class="token punctuation">(</span>svec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>svec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>使用<code>function</code>可以生成一个可调用对象</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>function<span class="token operator">&lt;</span><span class="token keyword">bool</span> <span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> fcn <span class="token operator">=</span> <span class="token operator">&amp;</span>string<span class="token double-colon punctuation">::</span>empty<span class="token punctuation">;</span>
<span class="token function">find_if</span><span class="token punctuation">(</span>svec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>svec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>fcn<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>当funtion对象包含一个指向成员函数的指针时，function知道它必须使用正确的指向成员的指针运算符来执行函数调用，可认为find_if中实际有如下代码</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">fcn</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div></li> <li><p>本质上function类将函数调用转换为</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>
</code></pre></div></li> <li><p>定义function对象时，必须指定该对象所能表示的函数类型，即可调用对象的形式，若可调用对象是一个成员函数，则第一个形参必须是表示该成员是在哪个对象上执行的。如上述的<code>string&amp;</code></p></li> <li><p>使用<code>mem_fn</code>也可以生成一个可调用对象。类似<code>function</code>，此标准库功能也定义在头文件<code>functional</code>中，可以从成员指针生成一个可调用对象，其可以自动推断可调用对象的类型，无需显式指定</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token function">find_if</span><span class="token punctuation">(</span>svec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>svec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">mem_fn</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>string<span class="token double-colon punctuation">::</span>empty<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p><code>mem_fn</code>生成的可调用对象可通过对象调用，也可通过指针调用</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token function">mem_fn</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>string<span class="token double-colon punctuation">::</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token operator">*</span>svec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//传入的是string对象，通过.*调用empty</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>svec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//传入的是string指针，通过-&gt;*调用empty</span>
</code></pre></div></li> <li><p>使用<code>bind</code>生成可调用对象</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">auto</span> it <span class="token operator">=</span> <span class="token function">find_if</span><span class="token punctuation">(</span>svec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>svec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>string<span class="token double-colon punctuation">::</span>empty<span class="token punctuation">,</span>_1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>和function类似的地方是，使用bind时，必须将函数中用于表示执行对象的隐式形参转换为显式的；和mem_fn类似的地方在于bind生成的可调用对象第一个实参既可以是string指针，也可以是string引用</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>string<span class="token double-colon punctuation">::</span>empty<span class="token punctuation">,</span>_1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token operator">*</span>svec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//传入的是string对象，通过.*调用empty</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>svec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//传入的是string指针，通过-&gt;*调用empty</span>
</code></pre></div></li></ul> <h2 id="_2023-11-02"><a href="#_2023-11-02" class="header-anchor">#</a> 2023/11/02</h2> <ul><li><p>外层类对嵌套类成员没有特殊的访问权限，嵌套类对外层类成员也没有特殊的访问权限</p></li> <li><p>嵌套类在外层类外完成真正的定义前，他都是一个不完全类型</p></li> <li><p><code>union</code>是一种特殊的类型，一个<code>union</code>可以有多个数据成员，但是在任意时刻，只有一个数据成员可以有值，当给<code>union</code>的某个成员赋值后，该<code>union</code>的其他成员就变成未定义状态，分配给<code>union</code>对象的存储空间至少要能容纳它的最大数据成员，和其他类一样，一个<code>union</code>定义了一种新类型</p></li> <li><p><code>union</code>不能含有引用类型的成员，在C++11中，含有构造或析构函数的类类型也能作为union的成员类型，union可以指定成员的public、protected、private等权限，默认全都是public的</p></li> <li><p>union可以定义包括构造函数和析构函数在内的成员函数，但是由于union不能继承其他类，也不能作为基类使用，所以在union中不能含有虚函数</p></li> <li><p>定义示例</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//Token只能保存一个值，这个值可能是char、int或double</span>
<span class="token keyword">union</span> Token<span class="token punctuation">{</span>
    <span class="token keyword">char</span> cval<span class="token punctuation">;</span>
    <span class="token keyword">int</span> ival<span class="token punctuation">;</span>
    <span class="token keyword">double</span> dval<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code>Token first_token <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token char">'a'</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//初始化cval成员</span>
Token lask_token<span class="token punctuation">;</span><span class="token comment">//未初始化的Token对象</span>
Token <span class="token operator">*</span>pt <span class="token operator">=</span> <span class="token keyword">new</span> Token<span class="token punctuation">;</span><span class="token comment">//指向未初始化的Token对象的指针</span>
</code></pre></div></li> <li><p>匿名union是一个未命名unino，一旦定义未命名union，编译器就会自动创建一个未命名对象</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">union</span><span class="token punctuation">{</span>
    <span class="token keyword">char</span> cval<span class="token punctuation">;</span>
    <span class="token keyword">int</span> ival<span class="token punctuation">;</span>
    <span class="token keyword">double</span> dval<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//定义一个未命名对象，可以直接访问其成员</span>
cval <span class="token operator">=</span> <span class="token char">'c'</span><span class="token punctuation">;</span><span class="token comment">//为刚定义的匿名对象赋值一个新值</span>
ival <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token comment">//该对象当前值为42</span>
</code></pre></div></li> <li><p>匿名union不能包含受保护或私有的成员，也不能定义成员函数</p></li> <li><p>对于含有特殊类型（非内置类型）成员的union，若想将其值改变为该类类型对应的值，则必须运行该类型的构造函数；若想改变为其他值，则必须运行该类型的析构函数</p></li> <li><p>作为union组成部分的类成员无法自动销毁，因为析构函数不清楚union存储的值类型</p></li> <li><p>union中含有自定义类型时管理比较复杂，一般将其定义为匿名union放在另一个类中进行管理。并定义一个枚举作为“判别式”来记录union当前存储值的类型</p></li> <li><p>类可以定义在某个函数的内部，称为局部类，局部类定义的类型只能在定义它的作用域可见，不同于嵌套类，局部类成员有严格限制</p></li> <li><p>局部类所有成员（包括函数）都必须完整定义在类的内部</p></li> <li><p>局部类不允许声明静态数据成员</p></li> <li><p>局部类只能访问外层作用域定义的类型名、静态变量以及枚举成员，若定义在函数内部，该函数的普通局部变量不能被该局部类访问</p></li> <li><p>类可以将其非静态数据成员定义为<strong>位域（bit-field）</strong>，在一个位域中含有一定数量的二进制位，当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域</p></li> <li><p>位域在内存中的布局是与机器相关的</p></li> <li><p>位域必须是整型或枚举类型，因为带符号位域的行为是有具体实现决定的，所以通常情况下我们使用无符号类型保存一个位域</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> Bit<span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">File</span><span class="token punctuation">{</span>
    Bit mode<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>
    Bit modified<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>
    Bit prot_owner<span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">;</span>
    Bit prot_group<span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">;</span>
    Bit prot_world<span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">//文件类型以八进制形式表示</span>
    <span class="token keyword">enum</span> <span class="token class-name">modes</span> <span class="token punctuation">{</span>READ <span class="token operator">=</span> <span class="token number">01</span><span class="token punctuation">,</span> WRITE <span class="token operator">=</span> <span class="token number">02</span><span class="token punctuation">,</span> EXECUTE <span class="token operator">=</span> <span class="token number">03</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    File <span class="token operator">&amp;</span><span class="token function">open</span><span class="token punctuation">(</span>modes<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">erite</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">bool</span> <span class="token function">isRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">setWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>取地址运算符 &amp; 不能作用域位域，因此任何指针都无法指向类的位域</p></li> <li><p><code>volatile</code>的确切语义与机器有关，只能通过阅读编译器文档理解，要想从一个机器移植到另一个机器，通常需要对程序进行一些改变</p></li> <li><p>直接处理硬件的程序常常包含volatile数据元素，它们的值由程序直接控制之外的过程控制，如程序可能包含一个由系统时钟定时更新的变量，当对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为<code>volatile</code>，此关键字告诉编译器不要对这样的对象进行优化</p></li> <li><p>volatile类似const，起到对类型额外修饰作用</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">volatile</span> <span class="token keyword">int</span> display_register<span class="token punctuation">;</span><span class="token comment">//该int值可能发生改变</span>
<span class="token keyword">volatile</span> Task <span class="token operator">*</span>curr_task<span class="token punctuation">;</span><span class="token comment">//curr_task指向一个volatile对象</span>
<span class="token keyword">volatile</span> <span class="token keyword">int</span> iax<span class="token punctuation">[</span>max_size<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//iax每个元素都是volatile的</span>
<span class="token keyword">volatile</span> Screen bitmapBuf<span class="token punctuation">;</span><span class="token comment">//bitmapBuf每个成员都是volatile的</span>
</code></pre></div></li> <li><p>类成员可以定义为volatile的，只有volatile成员函数才能被volatile对象调用</p></li> <li><p>不能使用合成的拷贝/移动构造函数和赋值运算符初始化volatile对象或从volatile对象赋值。要想使用这些功能必须显式定义这些操作</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">//从一个volatile对象拷贝</span>
    <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">volatile</span> Foo<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//将volatile赋值给非volatile对象</span>
    Foo<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">const</span> Foo<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//将volatile对象赋值给一个volatile对象</span>
    Foo<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">const</span> Foo<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token keyword">volatile</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>C++程序有时需要调用其他语言编写的函数，最常见的是调用C语言编写的函数。像所有其他名字一样，其他语言的函数名字也必须在C++中进行声明，并且该声明必须指定返回类型和参数列表。对于其他语言编写的函数，编译器检查其调用方式与处理普通C++函数的方式相同，但是生成的代码有所区别，C++使用<strong>链接指示</strong>指出任意非C++函数所使用的语言</p></li> <li><p>链接指示可以有两种形式：单个或复合的。链接指示不能出现在类定义或函数定义内部，同样的链接指示必须在函数的每个声明中都出现</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//cstring头文件的某些c函数的声明</span>
<span class="token comment">//单语句链接指示</span>
<span class="token keyword">extern</span> <span class="token string">&quot;C&quot;</span> size_t <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//符合语句链接指示</span>
<span class="token keyword">extern</span> <span class="token string">&quot;C&quot;</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> <span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">strcat</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>当一个<code>#include</code>指示被放置在符合链接指示的花括号中时，头文件中的所有普通函数声明都被认为是由链接指示的语言编写的，链接指示可嵌套</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">extern</span> <span class="token string">&quot;C&quot;</span> <span class="token punctuation">{</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>编写函数所用的语言是函数类型的一部分，因此对于使用链接指示定义的函数来说，它的每个声明都必须使用相同的链接指示，且指向其他语言编写的函数的指针必须与函数本身使用相同的链接指示</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//pf指向一个C函数，接收int返回void</span>
<span class="token keyword">extern</span> <span class="token string">&quot;C&quot;</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>链接指示对函数的参数和返回值都有效，若需要给C++函数传递指向C函数的指针，则必须使用类型别名</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//FC是一个指向C函数的指针</span>
<span class="token keyword">extern</span> <span class="token string">&quot;C&quot;</span> <span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token function">FC</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//f2是一个C++函数，形参是指向C函数的指针</span>
<span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span>FC<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>通过使用链接指示对函数进行定义，就可以令一个C++函数在其他语言编写的程序中可用</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//calc函数可被C程序调用</span>
<span class="token keyword">extern</span> <span class="token string">&quot;C&quot;</span> <span class="token keyword">double</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token keyword">double</span> dparam<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//...</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>有时需要在C/C++中编译同一个源文件，为实现此目的，在编译C++版本的程序时预处理器定义<code>__cplusplus</code>，使用此变量可以在编译C++程序时有条件地包含进一些代码</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__cplusplus</span></span>
<span class="token keyword">extern</span> <span class="token string">&quot;C&quot;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token keyword">int</span> <span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>C语言不支持函数重载，因此不难理解为什么一个C链接指示只能用于说明一组重载函数中的某一个</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//错误，两个extern函数名相同</span>
<span class="token keyword">extern</span> <span class="token string">&quot;C&quot;</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token string">&quot;C&quot;</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>如果在一组重载函数中有一个是C函数，则其余必定都是C++函数</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">SmallInt</span><span class="token punctuation">{</span><span class="token comment">/*...*/</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">BigNum</span><span class="token punctuation">{</span><span class="token comment">/*...*/</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//C函数可在C或C++中使用</span>
<span class="token comment">//C++重载了该函数，只能在C++中使用</span>
<span class="token keyword">extern</span> <span class="token string">&quot;C&quot;</span> <span class="token keyword">double</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">extern</span> SmallInt <span class="token function">calc</span><span class="token punctuation">(</span><span class="token keyword">const</span> SmallInt<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">extern</span> BigNum <span class="token function">calc</span><span class="token punctuation">(</span><span class="token keyword">const</span> BigNum<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.80bf8062.js" defer></script><script src="/assets/js/2.0c4bddf9.js" defer></script><script src="/assets/js/1.50b457b8.js" defer></script><script src="/assets/js/23.c4452db2.js" defer></script>
  </body>
</html>
